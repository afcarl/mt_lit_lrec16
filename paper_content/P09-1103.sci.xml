<PAPER>
  <FILENO/>
  <TITLE>A non-contiguous Tree Sequence Alignment-based Model for Statistical Machine Translation</TITLE>
  <AUTHORS/>
  <ABSTRACT>
    <A-S ID="S-27582">The tree sequence based translation model allows the violation of syntactic boundaries in a rule to capture non-syntactic phrases, where a tree sequence is a contiguous sequence of subtrees.</A-S>
    <A-S ID="S-27583">This paper goes further to present a translation model based on non-contiguous tree sequence alignment, where a non-contiguous tree sequence is a sequence of sub-trees and gaps.</A-S>
    <A-S ID="S-27584">Compared with the contiguous tree sequencebased model, the proposed model can well handle non-contiguous phrases with any large gaps by means of non-contiguous tree sequence alignment.</A-S>
    <A-S ID="S-27585">An algorithm targeting the noncontiguous constituent decoding is also proposed.</A-S>
    <A-S ID="S-27586">Experimental results on the NIST MT-05 Chinese-English translation task show that the proposed model statistically significantly outperforms the baseline systems.</A-S>
  </ABSTRACT>
  <BODY>
    <DIV DEPTH="0">
      <HEADER>1 Introduction</HEADER>
      <P>
        <S ID="S-27587">Current research in statistical machine translation (SMT) mostly settles itself in the domain of either phrase-based or syntax-based.</S>
        <S ID="S-27588">Between them, the phrase-based approach (<REF ID="R-08" RPTR="8">Marcu and Wong, 2002</REF>; <REF ID="R-05" RPTR="5">Koehn et al, 2003</REF>; <REF ID="R-09" RPTR="9">Och and Ney, 2004</REF>) allows local reordering and contiguous phrase translation.</S>
        <S ID="S-27589">However, it is hard for phrase-based models to learn global reorderings and to deal with noncontiguous phrases.</S>
        <S ID="S-27590">To address this issue, many syntax-based approaches (Yamada and Knight, 2001; Eisner, 2003; Gildea, 2003; Ding and Palmer, 2005; <REF ID="R-11" RPTR="10">Quirk et al, 2005</REF>; Zhang et al, 2007, 2008a; <REF ID="R-00" RPTR="0">Bod, 2007</REF>; <REF ID="R-07" RPTR="6">Liu et al, 2006</REF>, 2007; <REF ID="R-03" RPTR="3">Hearne and Way, 2003</REF>) tend to integrate more syntactic information to enhance the non-contiguous phrase modeling.</S>
        <S ID="S-27591">In general, most of them achieve this goal by introducing syntactic non-terminals as translational equivalent placeholders in both source and target sides.</S>
        <S ID="S-27592">Nevertheless, the generated rules are strictly required to be derived from the contiguous translational equivalences (<REF ID="R-02" RPTR="2">Galley et al, 2006</REF>; Marcu et al, 2006; Zhang et al, 2007, 2008a, 2008b; <REF ID="R-07" RPTR="7">Liu et al, 2006</REF>, 2007).</S>
        <S ID="S-27593">Among them, <REF ID="R-15" RPTR="14">Zhang et al. (2008</REF>a) acquire the non-contiguous phrasal rules from the contiguous tree sequence pairs 1 , and find them useless via real syntax-based translation systems.</S>
        <S ID="S-27594">However, <REF ID="R-14" RPTR="11">Wellington et al. (2006)</REF> statistically report that discontinuities are very useful for translational equivalence analysis using binary branching structures under word alignment and parse tree constraints.</S>
        <S ID="S-27595">Bod (2007) also finds that discontinues phrasal rules make significant improvement in linguistically motivated STSG-based translation model.</S>
        <S ID="S-27596">The above observations are conflicting to each other.</S>
        <S ID="S-27597">In our opinion, the non-contiguous phrasal rules themselves may not play a trivial role, as reported in <REF ID="R-15" RPTR="15">Zhang et al. (2008</REF>a).</S>
        <S ID="S-27598">We believe that the effectiveness of non-contiguous phrasal rules highly depends on how to extract and utilize them.</S>
      </P>
      <P>
        <S ID="S-27599">To verify the above assumption, suppose there is only one tree pair in the training data with its alignment information illustrated as Fig.</S>
        <S ID="S-27600">1(a) 2 .</S>
        <S ID="S-27601">A test sentence is given in Fig.</S>
        <S ID="S-27602">1(b): the source sentence with its syntactic tree structure as the upper tree and the expected target output with its syntactic structure as the lower tree.</S>
        <S ID="S-27603">In the tree sequence alignment based model, in addition to the entire tree pair, it is capable to acquire the contiguous tree sequence pairs: TSP (1~4) 3 in Fig.</S>
        <S ID="S-27604">1.</S>
        <S ID="S-27605">By means of the rules derived from these contiguous tree sequence pairs, it is easy to translate the contiguous phrase &#8220; /he &#161;&#163;&#162; /show up &#164; /&#8217;s&#8221;.</S>
        <S ID="S-27606">As for the non-contiguous phrase &#8220;&#165; /at, ***, &#166;&#168;&#167; /time&#8221;, the only related rule is r 1 derived from TSP4 and the entire tree pair.</S>
        <S ID="S-27607">However, the source side of r 1 does not match the source tree structure of the test sentence.</S>
        <S ID="S-27608">Therefore, we can only partially translate the illustrated test sentence with this training sample.</S>
      </P>
      <P>
        <S ID="S-27609">1 A tree sequence pair in this context is a kind of translational</S>
      </P>
      <P>
        <S ID="S-27610">equivalence comprised of a pair of tree sequences.</S>
        <S ID="S-27611">2 We illustrate the rule extraction with an example from the</S>
      </P>
      <P>
        <S ID="S-27612">tree-to-tree translation model based on tree sequence alignment (<REF ID="R-15" RPTR="19">Zhang et al, 2008</REF>a) without losing of generality to most syntactic tree based models.</S>
        <S ID="S-27613">3 We only list the contiguous tree sequence pairs with one</S>
      </P>
      <P>
        <S ID="S-27614">single sub-tree in both sides without losing of generality.</S>
      </P>
      <P>
        <S ID="S-27615"></S>
      </P>
      <P>
        <S ID="S-27616">&#169; &#165; &#169; &#165;</S>
      </P>
      <P>
        <S ID="S-27617">VV AS PN</S>
      </P>
      <P>
        <S ID="S-27618">VP</S>
      </P>
      <P>
        <S ID="S-27619">NP</S>
      </P>
      <P>
        <S ID="S-27620">CP</S>
      </P>
      <P>
        <S ID="S-27621">IP</S>
      </P>
      <P>
        <S ID="S-27622">VV</S>
      </P>
      <P>
        <S ID="S-27623">DEC NN</S>
      </P>
      <P>
        <S ID="S-27624">&#161; &#166;&#168;&#167; &#162;&#164;&#163;</S>
      </P>
      <P>
        <S ID="S-27625">VV PN</S>
      </P>
      <P>
        <S ID="S-27626">VP</S>
      </P>
      <P>
        <S ID="S-27627">NP</S>
      </P>
      <P>
        <S ID="S-27628">CP</S>
      </P>
      <P>
        <S ID="S-27629">IP</S>
      </P>
      <P>
        <S ID="S-27630">VV</S>
      </P>
      <P>
        <S ID="S-27631">DEC NN</S>
      </P>
      <P>
        <S ID="S-27632">&#161; &#166;&#167; &#162;&#163;</S>
      </P>
      <P>
        <S ID="S-27633">TSP1: PN( )  PRP(he)</S>
      </P>
      <P>
        <S ID="S-27634">TSP2: VV( )  VP(VBZ(shows),RP(up))</S>
      </P>
      <P>
        <S ID="S-27635">TSP3: IP(PN( ),VV( ))  S((PRP(he), VP(VBZ(shows), RP(up))))</S>
      </P>
      <P>
        <S ID="S-27636">TSP4: CP(IP(PN( ),VV( )),DEC( ))  S((PRP(he), VP(VBZ(shows), RP(up))))</S>
      </P>
      <P>
        <S ID="S-27637">TSP5: VV( ), *** ,NN( )  WRB(when)</S>
      </P>
      <P>
        <S ID="S-27638">r 1 : VP(VV( ),AS( ),NP(CP[0],NN( )))  SBAR(WRB(when),S[0])</S>
      </P>
      <P>
        <S ID="S-27639">S</S>
      </P>
      <P>
        <S ID="S-27640">VP</S>
      </P>
      <P>
        <S ID="S-27641">S</S>
      </P>
      <P>
        <S ID="S-27642">VP</S>
      </P>
      <P>
        <S ID="S-27643">r 2 : VV( ), *** ,NN( )  WRB(when)</S>
      </P>
      <P>
        <S ID="S-27644">SBAR</S>
      </P>
      <P>
        <S ID="S-27645">(a)</S>
      </P>
      <P>
        <S ID="S-27646">SBAR</S>
      </P>
      <P>
        <S ID="S-27647">(b)</S>
      </P>
      <P>
        <S ID="S-27648">As discussed above, the problem lies in that the non-contiguous phrases derived from the contiguous tree sequence pairs demand greater reliance on the context.</S>
        <S ID="S-27649">Consequently, when applying those rules to unseen data, it may suffer from the data sparseness problem.</S>
        <S ID="S-27650">The expressiveness of the model also slacks due to their weak ability of generalization.</S>
      </P>
      <P>
        <S ID="S-27651">To address this issue, we propose a syntactic translation model based on non-contiguous tree sequence alignment.</S>
        <S ID="S-27652">This model extracts the translation rules not only from the contiguous tree sequence pairs but also from the non-contiguous tree sequence pairs where a non-contiguous tree sequence is a sequence of sub-trees and gaps.</S>
        <S ID="S-27653">With the help of the non-contiguous tree sequence, the proposed model can well capture the noncontiguous phrases in avoidance of the constraints of large applicability of context and enhance the non-contiguous constituent modeling.</S>
        <S ID="S-27654">As for the above example, the proposed model enables the non-contiguous tree sequence pair indexed as TSP5 in Fig.</S>
        <S ID="S-27655">1 and is allowed to further derive r 2 from TSP5.</S>
        <S ID="S-27656">By means of r 2 and the same processing to the contiguous phrase &#8220; /he &#161; &#162; /show up &#164; /&#8217;s&#8221; as the contiguous tree sequence based model, we can successfully translate the entire source sentence in Fig.</S>
        <S ID="S-27657">1(b).</S>
      </P>
      <P>
        <S ID="S-27658">We define a synchronous grammar, named Synchronous non-contiguous Tree Sequence Substitution Grammar (SncTSSG), extended from synchronous tree substitution grammar (STSG: <REF ID="R-01" RPTR="1">Chiang, 2006</REF>) to illustrate our model.</S>
        <S ID="S-27659">The proposed synchronous grammar is able to cover the previous proposed grammar based on tree (STSG, Eisner, 2003; Zhang et al, 2007) and tree sequence (STSSG, <REF ID="R-15" RPTR="20">Zhang et al, 2008</REF>a) alignment.</S>
        <S ID="S-27660">Besides, we modify the traditional parsing based decoding algorithm for syntax-based SMT to facilitate the non-contiguous constituent decoding for our model.</S>
      </P>
      <P>
        <S ID="S-27661">To the best of our knowledge, this is the first attempt to acquire the translation rules with rich syntactic structures from the non-contiguous Translational Equivalences (non-contiguous tree sequence pairs in this context).</S>
      </P>
      <P>
        <S ID="S-27662">The rest of this paper is organized as follows: Section 2 presents a formal definition of our model with detailed parameterization.</S>
        <S ID="S-27663">Sections 3 and 4 elaborate the extraction of the non-contiguous tree sequence pairs and the decoding algorithm respectively.</S>
        <S ID="S-27664">The experiments we conduct to assess the effectiveness of the proposed method are reported in Section 5.</S>
        <S ID="S-27665">We finally conclude this work in Section 6.</S>
      </P>
      <P>
        <S ID="S-27666">2 Non-Contiguous Tree sequence Alignment-based Model</S>
      </P>
      <P>
        <S ID="S-27667">In this section, we give a formal definition of SncTSSG and accordingly we propose the alignment based translation model.</S>
        <S ID="S-27668">The details of probabilistic parameterization are elaborated based on the log-linear framework.</S>
      </P>
      <P>
        <S ID="S-27669">x and are source and target nonterminal alphabets (linguistically syntactic tags, i.e. NP, VP) respectively; as well as the non-terminal to denote a gap,</S>
      </P>
      <P>
        <S ID="S-27670">r</S>
      </P>
      <P>
        <S ID="S-27671">x R is a production rule set consisting of rules derived from corresponding contiguous or non-contiguous tree sequence pairs, where a rule is a pair of contiguous or noncontiguous tree sequence with alignment relation between leaf nodes across the tree sequence pair.</S>
      </P>
      <P>
        <S ID="S-27672">A non-contiguous tree sequence translation rule R can be further defined as a triple</S>
      </P>
      <P>
        <S ID="S-27673">, where:</S>
      </P>
      <P>
        <S ID="S-27674">can represent any syntactic or nonsyntactic tree sequences, and</S>
      </P>
      <P>
        <S ID="S-27675">x</S>
      </P>
      <P>
        <S ID="S-27676">x</S>
      </P>
      <P>
        <S ID="S-27677">x</S>
      </P>
      <P>
        <S ID="S-27678">is a non-contiguous source tree</S>
      </P>
      <P>
        <S ID="S-27679">sequence, covering the span set in , where which means each subspan has nonzero width and which means there is a non-zero gap between each pair of consecutive intervals.</S>
        <S ID="S-27680">A gap of interval [ ] is denoted as , and</S>
      </P>
      <P>
        <S ID="S-27681">is a non-contiguous target tree</S>
      </P>
      <P>
        <S ID="S-27682">sequence, covering the span set in , where which means each subspan has non-zero width and which means there is a non-zero gap between each pair of consecutive intervals.</S>
        <S ID="S-27683">A gap of interval [ ] is denoted as , and</S>
      </P>
      <P>
        <S ID="S-27684">where and</S>
      </P>
      <P>
        <S ID="S-27685">In SncTSSG, the leaf nodes in a non-contiguous tree sequence rule can be either non-terminal symbols (grammar tags) or terminal symbols (lexical words) and the non-terminal symbols with the same index which are subsumed simultaneously are not required to be contiguous.</S>
        <S ID="S-27686">Fig.</S>
        <S ID="S-27687">4 shows two examples of non-contiguous tree sequence rules (&#8220;non-contiguous rule&#8221; for short in the following context) derived from the noncontiguous tree sequence pair (in Fig.</S>
        <S ID="S-27688">3) which is extracted from the bilingual tree pair in Fig.</S>
        <S ID="S-27689">2.</S>
        <S ID="S-27690">Between them, ncTSr1 is a tree rule with internal nodes non-contiguously subsumed from a contiguous tree sequence pair (dashed in Fig.</S>
        <S ID="S-27691">2) while ncTSr2 is a non-contiguous rule with a contiguous source side and a non-contiguous target side.</S>
        <S ID="S-27692">Obviously, the non-contiguous tree sequence rule ncTSr2 is more flexible by neglecting the context among the gaps of the tree sequence pair while capturing all aligned counterparts with the corresponding syntactic structure information.</S>
        <S ID="S-27693">We ,</S>
      </P>
      <P>
        <S ID="S-27694">expect these properties can well address the issues of non-contiguous phrase modeling.</S>
      </P>
      <P>
        <S ID="S-27695">2.2 SncTSSG based Translation Model</S>
      </P>
      <P>
        <S ID="S-27696">Given the source and target sentence and , as well as the corresponding parse trees  and , our approach directly approximates the posterior probability based on the log-linear framework:</S>
      </P>
      <P>
        <S ID="S-27697">&#8225;&#353;&#8217;</S>
      </P>
      <P>
        <S ID="S-27698">In this model, the feature function h m is loglinearly combined by the corresponding parameter</S>
      </P>
      <P>
        <S ID="S-27699">(Och and Ney, 2002).</S>
        <S ID="S-27700">The following features are utilized in our model:</S>
      </P>
      <P>
        <S ID="S-27701">1) The bi-phrasal translation probabilities</S>
      </P>
      <P>
        <S ID="S-27702">2) The bi-lexical translation probabilities</S>
      </P>
      <P>
        <S ID="S-27703">3) The target language model</S>
      </P>
      <P>
        <S ID="S-27704">4) The # of words in the target sentence</S>
      </P>
      <P>
        <S ID="S-27705">5) The # of rules utilized</S>
      </P>
      <P>
        <S ID="S-27706">6) The average tree depth in the source side of the rules adopted</S>
      </P>
      <P>
        <S ID="S-27707">7) The # of non-contiguous rules utilized</S>
      </P>
      <P>
        <S ID="S-27708">8) The # of reordering times caused by the utilization of the non-contiguous rules</S>
      </P>
      <P>
        <S ID="S-27709">Feature 1~6 can be applied to either STSSG or SncTSSG based models, while the last two targets SncTSSG only.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>3 Tree Sequence Pair Extraction</HEADER>
      <P>
        <S ID="S-27710">Algorithm 1: Tree Sequence Pair Extraction Input: source tree and target tree Output: the set of tree sequence pairs Data structure: p[j 1 , j 2 ] to store tree sequence pairs covering source span[j 1 , j 2 ] 1: foreach source span [j 1 , j 2 ], do 2: find a target span [i 1 ,i 2 ] with minimal length covering all the target words aligned to [j 1 , j 2 ] 3: if all the target words in [i 1 ,i 2 ] are aligned with</S>
      </P>
      <P>
        <S ID="S-27711">source words only in [j 1 , j 2 ], then 4: Pair each source tree sequence covering [j 1 , j 2 ] with those in target covering [i 1 ,i 2 ] as a contiguous tree sequence pair 5: Insert them into p[j 1 , j 2 ] 6: else 7: create sub-span set s([i 1 ,i 2 ]) to cover all the target words aligned to [j 1 , j 2 ] 8: Pair each source tree sequence covering [j 1 , j 2 ] with each target tree sequence covering s([i 1 ,i 2 ]) as a non-contiguous tree sequence pair 9: Insert them into p[j 1 , j 2 ] 10: end if 11:end do 12: foreach target span [i 1 ,i 2 ], do 13: find a source span [j 1 , j 2 ] with minimal length covering all the source words aligned to [i 1 ,i 2 ] 14: if any source word in [j 1 , j 2 ] is aligned with target words outside [i 1 ,i 2 ], then 15: create sub-span set s([j 1 , j 2 ]) to cover all the source words aligned to [i 1 ,i 2 ] 16: Pair each source tree sequence covering s([j 1 , j 2 ]) with each target tree sequence covering [i 1 ,i 2 ] as a non-contiguous tree sequence pair 17: Insert them into p[j 1 , j 2 ] 18: end if 19: end do</S>
      </P>
      <P>
        <S ID="S-27712">In training, other than the contiguous tree sequence pairs, we extract the non-contiguous ones as well.</S>
        <S ID="S-27713">Nevertheless, compared with the contiguous tree sequence pairs, the non-contiguous ones suffer more from the tree sequence pair redundancy problem that one non-contiguous tree sequence pair can be comprised of two or more unrelated and nonadjacent contiguous ones.</S>
        <S ID="S-27714">To model the contiguous phrases, this problem is actually trivial, since the contiguous phrases stay adjacently and share the related syntactic constraints; however, as for non-contiguous phrase modeling, the cohesion of syntactically and semantically unrelated tree sequence pairs is more likely to generate noisy rules which do not benefit at all.</S>
        <S ID="S-27715">In order to minimize the number of redundant tree sequence pairs, we limit the # of gaps of non-contiguous tree sequence pairs to be 0 in either source or target side.</S>
        <S ID="S-27716">In other words, we only allow one side to be noncontiguous (either source or target side) to partially reserve its syntactic and semantic cohesion 4 .</S>
        <S ID="S-27717">We further design a two-phase algorithm to extract the tree sequence pairs as described in Algorithm 1.</S>
      </P>
      <P>
        <S ID="S-27718">For the first phase (line 1-11), we extract the contiguous tree sequence pairs (line 3-5) and the non-contiguous ones with contiguous tree sequence in the source side (line 6-9).</S>
        <S ID="S-27719">In the second phase (line 12-19), the ones with contiguous tree sequence in the target side and non-contiguous tree sequence on the source side are extracted.</S>
      </P>
      <P>
        <S ID="S-27720">4 <REF ID="R-14" RPTR="12">Wellington et al. (2006)</REF> also reports that allowing gaps in</S>
      </P>
      <P>
        <S ID="S-27721">one side only is enough to eliminate the hierarchical alignment failure with word alignment and one side parse tree constraints.</S>
        <S ID="S-27722">This is a particular case of our definition of non-contiguous tree sequence pair since a non-contiguous tree sequence can be considered to overcome the structural constraint by neglecting the structural information in the gaps.</S>
      </P>
      <P>
        <S ID="S-27723">The extracted tree sequence pairs are then utilized to derive the translation rules.</S>
        <S ID="S-27724">In fact, both the contiguous and non-contiguous tree sequence pairs themselves are applicable translation rules; we denote these rules as Initial rules.</S>
        <S ID="S-27725">By means of the Initial rules, we derive the Abstract rules similarly as in <REF ID="R-15" RPTR="16">Zhang et al. (2008</REF>a).</S>
      </P>
      <P>
        <S ID="S-27726">Additionally, we develop a few constraints to limit the number of Abstract rules.</S>
        <S ID="S-27727">The depth of a tree in a rule is no greater than h.</S>
        <S ID="S-27728">The number of non-terminals as leaf nodes is no greater than c.</S>
        <S ID="S-27729">The tree number is no greater than d. Besides, the number of lexical words at leaf nodes in an Initial rule is no greater than l.</S>
        <S ID="S-27730">The maximal number of gaps for a non-contiguous rule is no greater than .</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>4 The Pisces decoder</HEADER>
      <P>
        <S ID="S-27731">We implement our decoder Pisces by simulating the span based CYK parser constrained by the rules of SncTSSG.</S>
        <S ID="S-27732">The decoder translates each span iteratively in a bottom up manner which guarantees that when translating a source span, any of its sub-spans is already translated.</S>
      </P>
      <P>
        <S ID="S-27733">For each source span [j 1 , j 2 ], we perform a threephase decoding process.</S>
        <S ID="S-27734">In the first phase, the source side contiguous translation rules are utilized as described in Algorithm 2.</S>
        <S ID="S-27735">When translating using a source side contiguous rule, the target tree sequence of the rule whether contiguous or noncontiguous is directly considered as a candidate translation for this span (line 3), if the rule is an Initial rule; otherwise, the non-terminal leaf nodes are replaced with the corresponding sub-spans&#8217; translations (line 5).</S>
      </P>
      <P>
        <S ID="S-27736">In the second phase, the source side noncontiguous rules 5 for [j 1 , j 2 ] are processed.</S>
        <S ID="S-27737">As for</S>
      </P>
      <P>
        <S ID="S-27738">5 A source side non-contiguous translation rules which cover a</S>
      </P>
      <P>
        <S ID="S-27739">list of n non-contiguous spans s([ , ], i=1,&#8230;,n) is considered to cover the source span [j 1 , j 2 ] if and only if = j 1 and</S>
      </P>
      <P>
        <S ID="S-27740">= j 2 .</S>
      </P>
      <P>
        <S ID="S-27741">Algorithm 2: Contiguous rule processing Data structure: h[j 1 , j 2 ]to store translations covering source span[j 1 , j 2 ] 1: foreach rule r contiguous in source span [j 1 , j 2 ], do 2: if r is an Initial rule, then 3: insert r into h[j 1 , j 2 ] 4: else //Abstract rule 5: generate translations by replacing the nonterminal leaf nodes of r with their corresponding spans&#8217; translation 6: insert the new translation into h[j 1 , j 2 ] 7: end if 8: end do</S>
      </P>
      <P>
        <S ID="S-27742">the ones with non-terminal leaf nodes, the replacement with corresponding spans&#8217; translations is initially performed in the same way as with the contiguous rules in the first phase.</S>
        <S ID="S-27743">After that, an operation specified for the source side noncontiguous rules named &#8220;Source gap insertion&#8221; is performed.</S>
        <S ID="S-27744">As illustrated in Fig.</S>
        <S ID="S-27745">5, to use the noncontiguous rule r 1 , which covers the source span set ([0,0], [4,4]), the target portion &#8220;IN(in)&#8221; is first attained, then the translations to the gap span [1,3] is acquired from the previous steps and is inserted either to the right or to the left of &#8220;IN(in)&#8221;.</S>
        <S ID="S-27746">The insertion is rather cohesion based but leaves a gap</S>
      </P>
      <P>
        <S ID="S-27747">&lt;***&gt; for further &#8220;Target tree sequence reordering&#8221;</S>
      </P>
      <P>
        <S ID="S-27748">in the next phase if necessary.</S>
      </P>
      <P>
        <S ID="S-27749">In the third phase, we carry out the other noncontiguous rule specific operation named &#8220;Target tree sequence reordering&#8221;.</S>
        <S ID="S-27750">Algorithm 3 gives an overview of this operation.</S>
        <S ID="S-27751">For each source span, we first binarize the span into the left one and the right one.</S>
        <S ID="S-27752">The translation hypothesis for this span is generated by firstly inserting the candidate translations of the right span to each gap in the ones of the left span respectively (line 2-9) and then repeating in the alternative direction (line10-17).</S>
        <S ID="S-27753">The gaps for the insertion of the tree sequences in the target side are generated from either the inherit-</S>
      </P>
      <P>
        <S ID="S-27754">ance of the target side non-contiguous tree sequence pairs or the production of the previous operations of &#8220;Source gap insertion&#8221;.</S>
        <S ID="S-27755">Therefore, the insertion for target gaps helps search for a better order of the non-contiguous constituents in the target side.</S>
        <S ID="S-27756">On the other hand, the non-contiguous tree sequences with rich syntactic information are reordered, nevertheless, without much consideration of the constraints of the syntactic structure.</S>
        <S ID="S-27757">Consequently, this distortional operation, like phrase-based models, is much more flexible in the order of the target constituents than the traditional syntax-based models which are limited by the syntactic structure.</S>
        <S ID="S-27758">As a result, &#8220;Target tree sequence reordering&#8221; enhances the reordering ability of the model.</S>
      </P>
      <P>
        <S ID="S-27759">To speed up the decoder, we use several thresholds to limit the searching space for each span.</S>
        <S ID="S-27760">The maximal number of the rules in a source span is no greater than .</S>
        <S ID="S-27761">The maximal number of translation candidates for a source span is no greater than .</S>
        <S ID="S-27762">On the other hand, to simplify the computation of language model, we only compute for source side contiguous translational hypothesis, while neglecting gaps in the target side if any.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>5 Experiments</HEADER>
      <P>
        <S ID="S-27815"></S>
      </P>
      <DIV DEPTH="1">
        <HEADER>5.1 Experimental Settings</HEADER>
        <P>
          <S ID="S-27763">In the experiments, we train the translation model on FBIS corpus (7.2M (Chinese) + 9.2M (English) words) and train a 4-gram language model on the Xinhua portion of the English Gigaword corpus (181M words) using the SRILM Toolkits (Stolcke, 2002).</S>
          <S ID="S-27764">We use these sentences with less than 50 characters from the NIST MT-2002 test set as the development set and the NIST MT-2005 test set as our test set.</S>
          <S ID="S-27765">We use the Stanford parser (<REF ID="R-04" RPTR="4">Klein and Manning, 2003</REF>) to parse bilingual sentences on the training set and Chinese sentences on the development and test set.</S>
          <S ID="S-27766">The evaluation metric is casesensitive BLEU-4 (Papineni et al., 2002).</S>
          <S ID="S-27767">We base on the m-to-n word alignments dumped by GI- ZA++ to extract the tree sequence pairs.</S>
          <S ID="S-27768">For the MER training, we modify Koehn&#8217;s version (Koehn, 2004).</S>
          <S ID="S-27769">We use Zhang et al&#8217;s implementation (Zhang et al, 2004) for 95% confidence intervals significant test.</S>
        </P>
        <P>
          <S ID="S-27770">We compare the SncTSSG based model against two baseline models: the phrase-based and the STSSG-based models.</S>
          <S ID="S-27771">For the phrase-based model, we use Moses (Koehn et al, 2007) with its default settings; for the STSSG and SncTSSG based models we use our decoder Pisces by setting the following parameters: , , , , , .</S>
          <S ID="S-27772">Additionally, for STSSG we set , and for SncTSSG, we set .</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>5.2 Experimental Results</HEADER>
        <P>
          <S ID="S-27773">Table 1 compares the performance of different models across the two systems.</S>
          <S ID="S-27774">The proposed SncTSSG based model significantly outperforms (p &lt; 0.05) the two baseline models.</S>
          <S ID="S-27775">Since the SncTSSG based model covers the STSSG based model in its modeling ability and obtains a superset in rules, the improvement empirically verifies the effectiveness of the additional non-contiguous rules.</S>
        </P>
        <P>
          <S ID="S-27776">Pisces</S>
        </P>
        <P>
          <S ID="S-27777">Table 2 measures the contribution of different combination of rules.</S>
          <S ID="S-27778">cR refers to the rules derived from contiguous tree sequence pairs (i.e., all STSSG rules); ncPR refers to non-contiguous phrasal rules derived from contiguous tree sequence pairs with at least one non-terminal leaf node between two lexicalized leaf nodes (i.e., all non-contiguous rules in STSSG defined as in <REF ID="R-15" RPTR="17">Zhang et al. (2008</REF>a)); srcncR refers to source side non-contiguous rules (SncTSSG rules only, not STSSG rules); tgtncR refers to target side noncontiguous rules (SncTSSG rules only, not STSSG rules) and src&amp;tgtncR refers non-contiguous rules</S>
        </P>
        <P>
          <S ID="S-27779">with gaps in either side (srcncR+ tgtncR).</S>
          <S ID="S-27780">The last three kinds of rules are all derived from noncontiguous tree sequence pairs.</S>
        </P>
        <P>
          <S ID="S-27781">1) From Exp 1 and 2 in Table 2, we find that non-contiguous phrasal rules (ncPR) derived from contiguous tree sequence pairs make little impact on the translation performance which is consistent with the discovery of <REF ID="R-15" RPTR="18">Zhang et al. (2008</REF>a).</S>
          <S ID="S-27782">However, if we append the non-contiguous phrasal rules derived from non-contiguous tree sequence pairs, no matter whether non-contiguous in source or in target, the performance statistically significantly (p &lt; 0.05) improves (as presented in Exp 2~5), which validates our prediction that the noncontiguous rules derived from non-contiguous tree sequence pairs contribute more to the performance than those acquired from contiguous tree sequence pairs.</S>
        </P>
        <P>
          <S ID="S-27783">2) Not only that, after comparing Exp 6,7,8 against Exp 3,4,5 respectively, we find that the ability of rules derived from non-contiguous tree sequence pairs generally covers that of the rules derived from the contiguous tree sequence pairs, due to the slight change in BLEU score.</S>
        </P>
        <P>
          <S ID="S-27784">3) The further comparison of the noncontiguous rules from non-contiguous spans in Exp.</S>
          <S ID="S-27785">6&amp;7 as well as Exp 3&amp;4, shows that noncontiguity in the target side in Chinese-English translation task is not so useful as that in the source side when constructing the non-contiguous phrasal rules.</S>
          <S ID="S-27786">This also validates the findings in <REF ID="R-14" RPTR="13">Wellington et al. (2006)</REF> that varying the gaps on the English side (the target side in this context) seldom reduce the hierarchical alignment failures.</S>
        </P>
        <P>
          <S ID="S-27787">Table 3 explores the contribution of the noncontiguous translational equivalence to phrasebased models (all the rules in Table 3 has no grammar tags, but a gap &lt;***&gt; is allowed in the last three rows).</S>
          <S ID="S-27788">tgtncBP refers to the bilingual phrases with gaps in the target side; srcncBP refers to the bilingual phrases with gaps in the source side; src&amp;tgtncBP refers to the bilingual phrases with gaps in either side.</S>
        </P>
        <P>
          <S ID="S-27789">1) As presented in Table 3, the effectiveness of the bilingual phrases derived from noncontiguous tree sequence pairs is clearly indicated.</S>
          <S ID="S-27790">Models adopting both tgtncBP and srcncBP significantly (p &lt; 0.05) outperform the model adopting cBP only.</S>
        </P>
        <P>
          <S ID="S-27791">2) Pisces underperforms Moses when utilizing cBPs only, since Pisces can only perform monotonic search with cBPs.</S>
        </P>
        <P>
          <S ID="S-27792">3) The bilingual phrase model with both tgtncBP and srcncBP even outperforms Moses.</S>
          <S ID="S-27793">Compared with Moses, we only utilize plain features in Pisces for the bilingual phrase model (Feature 1~5 for all phrases and additional 7, 8 only for non-contiguous bilingual phrases as stated in Section 2.2; None of the complex reordering features or distortion features are employed by Pisces while Moses uses them), which suggests the effectiveness of the non-contiguous rules and the advantages of the proposed decoding algorithm.</S>
        </P>
        <P>
          <S ID="S-27794">Table 4 studies the impact on performance when setting different maximal gaps allowed for either side in a tree sequence pair (parameter ) and the relation with the quantity of rule set.</S>
        </P>
        <P>
          <S ID="S-27795">Significant improvement is achieved when allowing at least one gap on either side compared with when only allowing contiguous tree sequence pairs.</S>
          <S ID="S-27796">However, the further increment of gaps does not benefit much.</S>
          <S ID="S-27797">The result exhibits the accordance with the growing amplitude of the rule set filtered for the test set, in which the rule size increases more slowly as the maximal number of gaps increments.</S>
          <S ID="S-27798">As a result, this slow increase against the increment of gaps can be probably attributed to the small augmentation of the effective</S>
        </P>
        <P>
          <S ID="S-27799"></S>
        </P>
        <P>
          <S ID="S-27800">Output &amp; References</S>
        </P>
        <P>
          <S ID="S-27801">non-contiguous rules.</S>
        </P>
        <P>
          <S ID="S-27802">In order to facilitate a better intuition to the ability of the SncTSSG based model against the STSSG based model, we present in Table 5, two translation outputs produced by both models.</S>
        </P>
        <P>
          <S ID="S-27803">In the first example, GIZA++ wrongly aligns the idiom word &#8220; &#162;&#161;&#164;&#163;&#166;&#165; /confront at court&#8221; to a noncontiguous phrase &#8220;confront other countries at court*** leisurely manner&#8221; in training, in which only the first constituent &#8220;confront other countries at court&#8221; is reasonable, indicated from the key rules of SncTSSG leant from the training set.</S>
          <S ID="S-27804">The STSSG or any contiguous translational equivalence based model is unable to attain the corresponding target output for this idiom word via the non-contiguous word alignment and consider it as an out-of-vocabulary (OOV).</S>
          <S ID="S-27805">On the contrary, the SncTSSG based model can capture the noncontiguous tree sequence pair consistent with the word alignment and further provide a reasonable target translation.</S>
          <S ID="S-27806">It suggests that SncTSSG can easily capture the non-contiguous translational candidates while STSSG cannot.</S>
          <S ID="S-27807">Besides, SncTSSG is less sensitive to the error of word alignment when extracting the translation candidates than the contiguous translational equivalence based models.</S>
        </P>
        <P>
          <S ID="S-27808">In the second example, &#8220;&#167; /in &#168;&#169; /recent &#164; /&#8217;s  /survey  /middle&#8221; is correctly translated into &#8220;in</S>
        </P>
        <P>
          <S ID="S-27809">the recent surveys&#8221; by both the STSSG and SncTSSG based models.</S>
          <S ID="S-27810">This suggests that the short non-contiguous phrase &#8220;&#167; /in ***  /middle&#8221; is well handled by both models.</S>
          <S ID="S-27811">Nevertheless, as for the one with a larger gap, &#8220; /will ***  /continue&#8221; is correctly translated and well reordering into &#8220;will continue&#8221; by SncTSSG but failed by</S>
        </P>
        <P>
          <S ID="S-27812">STSSG.</S>
          <S ID="S-27813">Although the STSSG is theoretically able to capture this phrase from the contiguous tree sequence pair, the richer context in the gap as in this example, the more difficult STSSG can correctly translate the non-contiguous phrases.</S>
          <S ID="S-27814">This exhibits the flexibility of SncTSSG to the rich context among the non-contiguous constituents.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>6 Conclusions and Future Work</HEADER>
      <P>
        <S ID="S-27816">In this paper, we present a non-contiguous tree sequence alignment model based on SncTSSG to enhance the ability of non-contiguous phrase modeling and the reordering caused by non-contiguous constituents with large gaps.</S>
        <S ID="S-27817">A three-phase decoding algorithm is developed to facilitate the usage of non-contiguous translational equivalences (tree sequence pairs in this work) which provides much flexibility for the reordering of the non-contiguous constituents with rich syntactic structural information.</S>
        <S ID="S-27818">The experimental results show that our model outperforms the baseline models and verify the effectiveness of non-contiguous translational equivalences to non-contiguous phrase modeling in both syntax-based and phrase-based systems.</S>
        <S ID="S-27819">We also find that in Chinese-English translation task, gaps are more effective in Chinese side than in the English side.</S>
        <S ID="S-27820">Although the characteristic of more sensitiveness to word alignment error enables SncTSSG to capture the additional non-contiguous language phenomenon, it also induces many redundant noncontiguous rules.</S>
        <S ID="S-27821">Therefore, further work of our studies includes the optimization of the large rule set of the SncTSSG based model.</S>
      </P>
    </DIV>
  </BODY>
  <ACKNOWLEDGMENTS/>
  <REFERENCES>
    <REFERENCE ID="0">
      <RAUTHOR>Rens Bod</RAUTHOR>
      <REFTITLE>Unsupervised Syntax-Based Machine Translation: The Contribution of Discontinuous Phrases.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="1">
      <RAUTHOR>David Chiang</RAUTHOR>
      <REFTITLE>An Introduction to Synchronous Grammars. Tutorial on</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="2">
      <RAUTHOR>Michel Galley</RAUTHOR>
      <REFTITLE>Scalable Inference and training of context-rich syntactic translation models.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="3">
      <RAUTHOR>Mary Hearne</RAUTHOR>
      <REFTITLE>Seeing the wood for the trees: data-oriented translation.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="4">
      <RAUTHOR>Dan Klein</RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="5">
      <RAUTHOR>Philipp Koehn</RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="6">
      <RAUTHOR>Chris Callison-Burch Birch</RAUTHOR>
      <REFTITLE>Statistical phrase-based translation. HLT-NAACL03. 127-133 Philipp Koehn, Hieu Hoang,</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="7">
      <RAUTHOR>Yang Liu</RAUTHOR>
      <REFTITLE>Tree-toString Alignment Template for Statistical Machine Translation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="8">
      <RAUTHOR>Daniel Marcu</RAUTHOR>
      <REFTITLE>A phrasebased, joint probability model for statistical machine translation. EMNLP-02,</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="9">
      <RAUTHOR>Franz J Och</RAUTHOR>
      <REFTITLE>The alignment template approach to statistical machine translation.</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="10">
      <RAUTHOR>Computational Linguistics</RAUTHOR>
      <REFTITLE>30(4):417-449 Kishore Papineni, Salim Roukos, ToddWard and WeiJing Zhu.</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="11">
      <RAUTHOR>Chris Quirk</RAUTHOR>
      <REFTITLE>Dependency treelet translation: syntactically informed phrasal SMT.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="12">
      <RAUTHOR>S Shieber</RAUTHOR>
      <REFTITLE>Synchronous grammars as tree transducers.</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="13">
      <RAUTHOR></RAUTHOR>
      <REFTITLE>SRILM - an extensible language modeling toolkit.</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="14">
      <RAUTHOR>Benjamin Wellington</RAUTHOR>
      <REFTITLE>Empirical Lower Bounds on the Complexity of Translational Equivalence.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="15">
      <RAUTHOR>Min Zhang</RAUTHOR>
      <REFTITLE>A tree sequence alignment-based tree-to-tree translation model.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="16">
      <RAUTHOR>Min Zhang</RAUTHOR>
      <REFTITLE>Aiti Aw, Sheng Li.</REFTITLE>
      <DATE></DATE>
    </REFERENCE>
  </REFERENCES>
</PAPER>
