<document>
  <filename>W10-3806</filename>
  <authors>
    <author>Ventsislav Zhechev</author>
  </authors>
  <title>Seeding Statistical Machine Translation with Translation Memory Output through Tree-Based Structural Alignment</title>
  <content>
    <sections>
      <section>
        <index>0</index>
        <title>Abstract</title>
        <text>With the steadily increasing demand for high-quality translation, the localisation industry is constantly searching for technologies that would increase translator throughput, with the current focus on the use of high-quality Statistical Machine Translation (SMT) as a supplement to the established Translation Memory (TM) technology. In this paper we present a novel modular approach that utilises state-of-the-art sub-tree alignment to pick out pre-translated segments from a TM match and seed with them an SMT system to produce a final translation. We show that the presented system can outperform pure SMT when a good TM match is found. It can also be used in a Computer-Aided Translation (CAT) environment to present almost perfect translations to the human user with markup highlighting the segments of the translation that need to be checked manually for correctness.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>With the steadily increasing demand for high-quality translation, the localisation industry is constantly searching for technologies that would increase translator throughput, with the current focus on the use of high-quality Statistical Machine Translation (SMT) as a supplement to the established Translation Memory (TM) technology.</text>
              <doc_id>0</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>In this paper we present a novel modular approach that utilises state-of-the-art sub-tree alignment to pick out pre-translated segments from a TM match and seed with them an SMT system to produce a final translation.</text>
              <doc_id>1</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>We show that the presented system can outperform pure SMT when a good TM match is found.</text>
              <doc_id>2</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>It can also be used in a Computer-Aided Translation (CAT) environment to present almost perfect translations to the human user with markup highlighting the segments of the translation that need to be checked manually for correctness.</text>
              <doc_id>3</doc_id>
              <sec_id>3</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>1</index>
        <title>1. Introduction</title>
        <text>As the world becomes increasingly interconnected, the major trend is to try to deliver ideas and products to the widest audience possible. This requires the localisation of products for as many countries and cultures as possible, with translation being one of the main parts of the localisation process. Because of this, the amount of data that needs professional high-quality translation is continuing to increase well beyond the capacity of the world&#8217;s human translators. Thus, current efforts in the localisation industry are mostly directed at the reduction of the amount of data that needs to be translated from scratch by hand. Such efforts mainly include the use of Translation Memory (TM) systems, where earlier translations are stored in a database and offered as suggestions when new data needs to be translated. As TM systems were originally limited to providing translations only for (almost) exact matches of the new data, the integration of Machine Translation (MT) techniques is seen as the only feasible development that has the potential to significantly reduce the amount of manual translation required. At the same time, the use of SMT is frowned upon by the users of CAT tools as they still do not trust the quality of the SMT output. There are two main reasons for that. First, currently there is no reliable way to automatically ascertain the quality of SMT-generated translations, so that the user could at a glance make a judgement as to the amount of effort that might be needed to postedit the suggested translation (Simard and Isabelle, 2009). Not having such automatic quality metrics also has the side effect of it being impossible for a Translation-Services Provider (TSP) company to reliably determine in advance the increase in translator productivity due to the use of MT and to adjust their resources-allocation and cost models correspondingly. The second major problem for users is that SMTgenerated translations are as a rule only obtained for cases where the TM system could not produce a good-enough translation (cf. Heyn, 1996). Given that the SMT system used is usually trained only on the data available in the TM, expectedly it also has few examples from which to construct the translation, thus producing low quality output.
in a single integrated tool. When a new sentence that needs to be translated is supplied, first a Fuzzy-Match Score (FMS &#8211; see Section 2.2) is obtained from the TM backend, together with the suggested matching sentence and its translation. For sentences that receive a reasonably high FMS, the STA backend is used to find the correspondences between the input sentence and the TM-suggested translation, marking up the parts of the input that are correctly translated by the TM. The SMT backend is then employed to obtain the final translation from the marked-up input sentence. In this way we expect to achieve a better result compared to using pure SMT. In Section 2, we present the technical details of the design of our system, together with motivation for the particular design choices. Section 3 details the experimental setup and the data set used for the evaluation results in Section 4. We present improvements that we plan to investigate in further work in Section 5, and provide concluding remarks in Section 6.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>As the world becomes increasingly interconnected, the major trend is to try to deliver ideas and products to the widest audience possible.</text>
              <doc_id>4</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>This requires the localisation of products for as many countries and cultures as possible, with translation being one of the main parts of the localisation process.</text>
              <doc_id>5</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Because of this, the amount of data that needs professional high-quality translation is continuing to increase well beyond the capacity of the world&#8217;s human translators.</text>
              <doc_id>6</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Thus, current efforts in the localisation industry are mostly directed at the reduction of the amount of data that needs to be translated from scratch by hand.</text>
              <doc_id>7</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Such efforts mainly include the use of Translation Memory (TM) systems, where earlier translations are stored in a database and offered as suggestions when new data needs to be translated.</text>
              <doc_id>8</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>As TM systems were originally limited to providing translations only for (almost) exact matches of the new data, the integration of Machine Translation (MT) techniques is seen as the only feasible development that has the potential to significantly reduce the amount of manual translation required.</text>
              <doc_id>9</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>At the same time, the use of SMT is frowned upon by the users of CAT tools as they still do not trust the quality of the SMT output.</text>
              <doc_id>10</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>There are two main reasons for that.</text>
              <doc_id>11</doc_id>
              <sec_id>7</sec_id>
            </sentence>
            <sentence>
              <text>First, currently there is no reliable way to automatically ascertain the quality of SMT-generated translations, so that the user could at a glance make a judgement as to the amount of effort that might be needed to postedit the suggested translation (Simard and Isabelle, 2009).</text>
              <doc_id>12</doc_id>
              <sec_id>8</sec_id>
            </sentence>
            <sentence>
              <text>Not having such automatic quality metrics also has the side effect of it being impossible for a Translation-Services Provider (TSP) company to reliably determine in advance the increase in translator productivity due to the use of MT and to adjust their resources-allocation and cost models correspondingly.</text>
              <doc_id>13</doc_id>
              <sec_id>9</sec_id>
            </sentence>
            <sentence>
              <text>The second major problem for users is that SMTgenerated translations are as a rule only obtained for cases where the TM system could not produce a good-enough translation (cf. Heyn, 1996).</text>
              <doc_id>14</doc_id>
              <sec_id>10</sec_id>
            </sentence>
            <sentence>
              <text>Given that the SMT system used is usually trained only on the data available in the TM, expectedly it also has few examples from which to construct the translation, thus producing low quality output.</text>
              <doc_id>15</doc_id>
              <sec_id>11</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>in a single integrated tool.</text>
              <doc_id>16</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>When a new sentence that needs to be translated is supplied, first a Fuzzy-Match Score (FMS &#8211; see Section 2.2) is obtained from the TM backend, together with the suggested matching sentence and its translation.</text>
              <doc_id>17</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>For sentences that receive a reasonably high FMS, the STA backend is used to find the correspondences between the input sentence and the TM-suggested translation, marking up the parts of the input that are correctly translated by the TM.</text>
              <doc_id>18</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>The SMT backend is then employed to obtain the final translation from the marked-up input sentence.</text>
              <doc_id>19</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>In this way we expect to achieve a better result compared to using pure SMT.</text>
              <doc_id>20</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>In Section 2, we present the technical details of the design of our system, together with motivation for the particular design choices.</text>
              <doc_id>21</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>Section 3 details the experimental setup and the data set used for the evaluation results in Section 4.</text>
              <doc_id>22</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>We present improvements that we plan to investigate in further work in Section 5, and provide concluding remarks in Section 6.</text>
              <doc_id>23</doc_id>
              <sec_id>7</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>2</index>
        <title>2. System Framework</title>
        <text>We present a system that uses a TM-match to pre-translate parts of the input sentence and guide an SMT system to the generation of a higher-quality translation.
We are not aware of any published research where TM output is used to improve the performance of an SMT system in a manner similar to the system presented in this paper. Most closely related to our approach are the systems by Bi&#231;ici and Dymetman (2008) and Simard and Isabelle (2009), where the authors use the TM output to extract new phrase pairs that supplement the SMT phrase table. Such an approach, however, does not guarantee that the SMT system will select the TM-motivated phrases even if a heavy bias is applied to them. Another related system is presented in (Smith and Clark, 2009). Here the authors use a syntaxbased EBMT system to pre-translate and markup parts of the input sentence and then supply this marked-up input to an SMT system. This differs to our system in two ways. First, Smith and Clark use EMBT techniques to obtain partial translations of the input from the complete example base, while we are only looking at the best TM match for the given input. Second, the authors use dependency structures for EMBT matching, while we employ phrase-based structures. 2.2. Translation Memory Backend Although the intention is to use a full-scale TM system as the translation memory backend, to have complete control over the process for this initial research we decided to build a simple prototype TM backend ourselves. We employ a database setup using the PostgreSQL v.8.4.3 1 relational database management (RDBM) system. The segment pairs from a given TM are stored in this database and assigned unique IDs for further reference. When a new sentence is supplied for translation, the database is searched for (near) matches, using an FMS based on normalised character-level Levenshtein edit distance (Levenshtein, 1965). Thus for each input sentence, from the database we obtain the matching segment with the highest FMS, its translation and the score itself.
The system presented in this paper uses phrasebased sub-tree structural alignment (Zhechev, 2010) to discover parts of the input sentence that correspond to parts of the suggested translation extracted from the TM database. We chose this particular tool, because it can produce aligned phrase-based-tree pairs from unannotated (i.e. unparsed) data. It can also function fully automatically without the need for any training data. The only auxiliary requirement it has is for a probabilistic dictionary for the languages that are being aligned. As described later in this section, in our case this is obtained automatically from the TM data during the training of the SMT backend. The matching between the input sentence and the TM-suggested translation is done in a threestep process. First, the plain TM match and its
44 translation are aligned, which produces a subtree-aligned phrase-based tree pair with all nonterminal nodes labelled &#8216;X&#8217; (cf. Zhechev, 2010). As we are only interested in the relations between the lexical spans of the non-terminal nodes, we can safely ignore their labels. We call this first step of our algorithm bilingual alignment. In the second step, called monolingual alignment, the phrase-based tree-annotated version of the TM match is aligned to the unannotated input sentence. The reuse of the tree structure for the TM match allows us to use it in the third step as an intermediary to establish the available subtree alignments between the input sentence and the translation suggested from the TM. During this final alignment, we identify matched and mismatched portions of the input sentence and their possible translations in the TM suggestion and, thus, this step is called matching. Additionally, the sub-tree alignments implicitly provide us with reordering information, telling us where the portions of the input sentence that we translate should be positioned in the final translation. The alignment process is exemplified in Figure 1. The tree marked &#8216;I&#8217; corresponds to the input sentence, the one marked &#8216;M&#8217; to the TM match and the one marked &#8216;T&#8217; to the TM translation. Due to space constraints, we only display the node ID numbers of the non-terminal nodes in the phrasestructure trees &#8212; in reality all nodes carry the label &#8216;X&#8217;. These IDs are used to identify the subsentential alignment links. The lexical items corresponding to the leaves of the trees are presented in the table below the graph. The alignment process can be visually represented as starting at a linked node in the I tree and following the link to the M tree. Then, if available, we follow the link to the T tree and this leads us to the T-tree node corresponding to the I-tree node we started from. In Figure 1, this results in the I&#8211;T alignments I1&#8211;T18, I2&#8211;T2, I3&#8211; T1, I4&#8211;T32 and I6&#8211;T34. The first three links are matches, because the lexical items covered by the I nodes correspond exactly to the lexical items covered by their M node counterparts. Such alignments provide us with direct TM translations for our input. The last two links in the group are mismatched, because there is no lexical correspondence between the I and M nodes (node I4 corresponds to the phrase sender email, while the linked node M10 corresponds to sender &#8217;s email). Such alignments can only be used to infer reordering information. In particular in this case, we can infer that the target word order for the input sentence is address email sender, which produces the translation adresse &#233;lectronique de l&#8217; exp&#233;diteur.
an input sentence, TM match and TM translation We decided to use sub-tree-based alignment, rather than plain word alignment (e.g. GIZA++ &#8211; Och and Ney, 2003), due to a number of factors. First, sub-tree-based alignment provides much better handling of long-distance reorderings, while word&#8211; and phrase-based alignment models always have a fixed limit on reordering distance that tends to be relatively low to allow efficient computation. The alignments produced by a sub-tree alignment model are also precision-oriented, rather than recall-oriented (cf. Tinsley, 2010). This is important in our case, where we want to only extract those parts of the translation suggested by the TM for which we are most certain that they are good translations. 45 As stated earlier, the only resource necessary for the operation of this system is a probabilistic bilingual dictionary covering the data that needs to be aligned. For the bilingual alignment step, such a bilingual dictionary is produced as a byproduct of the training of the SMT backend and therefore available. For the monolingual alignment step, the required probabilistic dictionary is generated by simply listing each unique token seen in the source-language data in the TM as translating only as itself with probability 1.
Once the matching step is completed, we have identified and marked-up the parts of the input sentence for which translations will be extracted from the TM suggestions, as well as the parts that need to be translated from scratch. The lengths of the non-translated segments vary depending on the FMS, but are in general relatively short (one to three tokens). The further processing of the input relies on a specific feature of the SMT backend we use, namely the Moses system (Koehn et al., 2007). We decided to use this particular system as it is the most widely adopted open-source SMT system, both for academic and commercial purposes. In this approach, we annotate the segments of the input sentence for which translations have been found from the TM suggestion using XML tags with the translation corresponding to each segment given as an attribute to the encapsulating XML tag, similarly to the system described in (Smith and Clark, 2009). The SMT backend is supplied with marked-up input in the form of a string consisting of the concatenation of the XML-enclosed translated segments and the plain non-translated segments in the targetlanguage word order, as established by the alignment process. The SMT backend is instructed to translate this input, while keeping the translations supplied via the XML annotation. This allows the SMT backend to produce translations informed by and conforming to actual examples from the TM, which should result in improvements in translation quality.
It must be noted that in general the SMT backend sees the data it needs to translate in the targetlanguage word order (e.g. it is asked to translate an English sentence that has French word order). This, however, does not correspond to the data found in the TM, which we use for deriving the SMT models. Because of this discrepancy, we developed a pre-processing tool that goes over the TM data performing bilingual alignment and outputting reordered versions of the sentences it processes by using the information implicitly encoded in the sub-tree alignments. In this way we obtain the necessary reordered data to train a translation model where the source language already has the target-language word order. In our system we than use this model &#8212; together with the proper-word-order model &#8212; for translation. One specific aspect of real-world TM data that we need to deal with is that they often contain meta-tag annotations of various sorts. Namely, annotation tags specific to the file format used for storing the TM data, XML tags annotating parts of the text as appearing in Graphical User Interface (GUI) elements, formatting tags specific to the file format the TM data was originally taken from, e.g. RTF, OpenDoc, etc. Letting any MT system try to deal with these tags in a probabilistic manner can easily result in ill-formed, mistranslated and/or out-of-order meta-tags in the translation. This motivates the implementation of a rudimentary handling of meta-tags in the system presented in this paper, in particular handling the XML tags found in the TM data we work with, as described in Section 3. The tool we developed for this purpose simply builds a map of all unique XML tags per language and replaces them in the data with short placeholders that are designed in such a way that they would not interfere with the rest of the TM data. 2 A special case that the tool has to take care of is when an XML tag contains an attribute whose value needs to be translated. In such situations, we decided to not perform any processing, but rather leave the XML tag as is, so that all text may be translated as needed. A complete treatment of meta-tags, however, is beyond the scope of the current paper. 2 In the current implementation, the XML tags are replaced with the string apple&lt;tag_id&gt;apple, where &lt;tag_id&gt; is a unique numeric identifier for the XML tag that is being replaced. 46 We also had to build a dedicated tokeniser/detokeniser pair to handle real world TM data containing meta-tags, e-mail addresses, file paths, etc., as described in Section 3. Both tools are implemented as a cascade of regular expression substitutions in Perl. Finally, we use a tool to extract the textual data from the TM. That is, we strip all tags specific to the format in which the TM is stored, as they can in general be recreated and thus do not need to be present during translation. In our particular case the TM is stored in the XML-based TMX format. 3
Besides the components described above, we also performed two further transformations on the data. First, we lowercase the TM data before using it to train the SMT backend models. This also means that the alignment steps from Section 2.3 are performed on lowercased data, as the bilingual dictionary used there is obtained during the SMT training process. 4 Additionally, the SMT and sub-tree alignment systems that we use cannot handle certain characters, which we need to mask in the data. For the SMT backend, this includes &#8216;|&#8217;, &#8216;&lt;&#8217; and &#8216;&gt;&#8217; and for the sub-tree aligner, &#8216;(&#8217; and &#8216;)&#8217;. The reason these characters cannot be handled is that the SMT system uses &#8216;|&#8217; internally to separate data fields in the trained models and &#8216;&lt;&#8217; and &#8216;&gt;&#8217; cannot be handled whilst using XML tags to annotate pre-translated portions of the input. The subtree aligner uses &#8216;(&#8217; and &#8216;)&#8217; to represent the phrase-based tree structures it generates and the presence of these characters in the data may create ambiguity when parsing the tree structures. All these characters are masked by substituting in high-Unicode counterparts, namely &#8216;&#9474;&#8217;, &#8216;&#65533;&#8217;, &#8216;&#65533;&#8217;, &#8216;&#65533;&#8217; and &#8216;&#65533;&#8217;. Visually, there is a very slight distinction and this is intentionally so to simplify debugging. However, the fact that the character codes are different alleviates the problems discussed above. Of course, in the final output, the masking is reversed and the translation contains the regular versions of the characters.
The complete pre-processing workflow is presented in Figure 2, where the rectangles with vertical bars represent the use of open-source tools, while the plain rectangles represent tools developed by the authors of this paper. First, the textual data is extracted from the original TM format, producing one plain-text file for each language side. These data can either be pre-loaded in a PostgreSQL database at this time, or during the first run of the translation system. Next, the meta-tag-handling tool is used to generate the substitution tables for the source and target languages, as well as new files for each language with the tags substituted by the corresponding identifiers (cf. Section 2.5). These files are then tokenised, lowercased and all conflicting characters are masked, as described above. The pre-processed files are then used to produce a file containing pairs of sentences in the input format of the sub-tree aligner, as well as to generate the probabilistic dictionary required for
will be added in a future version of the system. 47 the monolingual alignment and to train the SMT model on the data in the proper word order. The SMT training produces the necessary bilingual dictionary for use by the sub-tree aligner, which is run to obtain a parallel-treebank version of the TM data. The parallel treebank is then used to retrieve bilingual alignments for the TM data, rather than generate them on the fly during translation. This is an important design decision, as the complexity of the alignment algorithm is high for plain-text alignment (cf. Zhechev, 2010). Once we have generated the bilingual parallel treebank, we run the reordering tool, which generates a new plain-text file for the source language, where the sentences are modified to conform to the target-language word order, as implied by the data in the parallel treebank. This is then matched with the proper-order targetlanguage file to train the SMT backend for the actual use in the translation process.
Once all the necessary files have been generated and all pre-processing steps have been completed, the system is ready for use for translation. The translation workflow is shown in Figure 3, &#8216;I&#8217;, &#8216;M&#8217; and &#8216;T&#8217; having the same meanings as in Figure 1. Here, the first step after an input sentence has been read in is to find the TM match with the highest FMS. This is done using the original plain non-pre-processed data to simulate real-life operation with a proper TM backend. After the best TM match and its translation are extracted from the TM, they &#8212; together with the input sentence &#8212; are pre-processed by tokenisation, lowercasing, meta-tag and special-character substitution. Next, the corresponding tree pair is extracted from the bilingual parallel treebank to establish the tree structure for the TM sourcelanguage match. This tree structure is then used to perform the monolingual alignment, which allows us to perform the matching step next. After the matching is complete, we generate a final translation as described in Section 2.4. Finally, the translations are de-tokenised and the XML tags and special characters are unmasked.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>We present a system that uses a TM-match to pre-translate parts of the input sentence and guide an SMT system to the generation of a higher-quality translation.</text>
              <doc_id>24</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>We are not aware of any published research where TM output is used to improve the performance of an SMT system in a manner similar to the system presented in this paper.</text>
              <doc_id>25</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Most closely related to our approach are the systems by Bi&#231;ici and Dymetman (2008) and Simard and Isabelle (2009), where the authors use the TM output to extract new phrase pairs that supplement the SMT phrase table.</text>
              <doc_id>26</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Such an approach, however, does not guarantee that the SMT system will select the TM-motivated phrases even if a heavy bias is applied to them.</text>
              <doc_id>27</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Another related system is presented in (Smith and Clark, 2009).</text>
              <doc_id>28</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Here the authors use a syntaxbased EBMT system to pre-translate and markup parts of the input sentence and then supply this marked-up input to an SMT system.</text>
              <doc_id>29</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>This differs to our system in two ways.</text>
              <doc_id>30</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>First, Smith and Clark use EMBT techniques to obtain partial translations of the input from the complete example base, while we are only looking at the best TM match for the given input.</text>
              <doc_id>31</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>Second, the authors use dependency structures for EMBT matching, while we employ phrase-based structures.</text>
              <doc_id>32</doc_id>
              <sec_id>7</sec_id>
            </sentence>
            <sentence>
              <text>2.2.</text>
              <doc_id>33</doc_id>
              <sec_id>8</sec_id>
            </sentence>
            <sentence>
              <text>Translation Memory Backend Although the intention is to use a full-scale TM system as the translation memory backend, to have complete control over the process for this initial research we decided to build a simple prototype TM backend ourselves.</text>
              <doc_id>34</doc_id>
              <sec_id>9</sec_id>
            </sentence>
            <sentence>
              <text>We employ a database setup using the PostgreSQL v.8.4.3 1 relational database management (RDBM) system.</text>
              <doc_id>35</doc_id>
              <sec_id>10</sec_id>
            </sentence>
            <sentence>
              <text>The segment pairs from a given TM are stored in this database and assigned unique IDs for further reference.</text>
              <doc_id>36</doc_id>
              <sec_id>11</sec_id>
            </sentence>
            <sentence>
              <text>When a new sentence is supplied for translation, the database is searched for (near) matches, using an FMS based on normalised character-level Levenshtein edit distance (Levenshtein, 1965).</text>
              <doc_id>37</doc_id>
              <sec_id>12</sec_id>
            </sentence>
            <sentence>
              <text>Thus for each input sentence, from the database we obtain the matching segment with the highest FMS, its translation and the score itself.</text>
              <doc_id>38</doc_id>
              <sec_id>13</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The system presented in this paper uses phrasebased sub-tree structural alignment (Zhechev, 2010) to discover parts of the input sentence that correspond to parts of the suggested translation extracted from the TM database.</text>
              <doc_id>39</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>We chose this particular tool, because it can produce aligned phrase-based-tree pairs from unannotated (i.e. unparsed) data.</text>
              <doc_id>40</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>It can also function fully automatically without the need for any training data.</text>
              <doc_id>41</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>The only auxiliary requirement it has is for a probabilistic dictionary for the languages that are being aligned.</text>
              <doc_id>42</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>As described later in this section, in our case this is obtained automatically from the TM data during the training of the SMT backend.</text>
              <doc_id>43</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>The matching between the input sentence and the TM-suggested translation is done in a threestep process.</text>
              <doc_id>44</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>First, the plain TM match and its</text>
              <doc_id>45</doc_id>
              <sec_id>6</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>44 translation are aligned, which produces a subtree-aligned phrase-based tree pair with all nonterminal nodes labelled &#8216;X&#8217; (cf. Zhechev, 2010).</text>
              <doc_id>46</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>As we are only interested in the relations between the lexical spans of the non-terminal nodes, we can safely ignore their labels.</text>
              <doc_id>47</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>We call this first step of our algorithm bilingual alignment.</text>
              <doc_id>48</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>In the second step, called monolingual alignment, the phrase-based tree-annotated version of the TM match is aligned to the unannotated input sentence.</text>
              <doc_id>49</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>The reuse of the tree structure for the TM match allows us to use it in the third step as an intermediary to establish the available subtree alignments between the input sentence and the translation suggested from the TM.</text>
              <doc_id>50</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>During this final alignment, we identify matched and mismatched portions of the input sentence and their possible translations in the TM suggestion and, thus, this step is called matching.</text>
              <doc_id>51</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>Additionally, the sub-tree alignments implicitly provide us with reordering information, telling us where the portions of the input sentence that we translate should be positioned in the final translation.</text>
              <doc_id>52</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>The alignment process is exemplified in Figure 1.</text>
              <doc_id>53</doc_id>
              <sec_id>7</sec_id>
            </sentence>
            <sentence>
              <text>The tree marked &#8216;I&#8217; corresponds to the input sentence, the one marked &#8216;M&#8217; to the TM match and the one marked &#8216;T&#8217; to the TM translation.</text>
              <doc_id>54</doc_id>
              <sec_id>8</sec_id>
            </sentence>
            <sentence>
              <text>Due to space constraints, we only display the node ID numbers of the non-terminal nodes in the phrasestructure trees &#8212; in reality all nodes carry the label &#8216;X&#8217;.</text>
              <doc_id>55</doc_id>
              <sec_id>9</sec_id>
            </sentence>
            <sentence>
              <text>These IDs are used to identify the subsentential alignment links.</text>
              <doc_id>56</doc_id>
              <sec_id>10</sec_id>
            </sentence>
            <sentence>
              <text>The lexical items corresponding to the leaves of the trees are presented in the table below the graph.</text>
              <doc_id>57</doc_id>
              <sec_id>11</sec_id>
            </sentence>
            <sentence>
              <text>The alignment process can be visually represented as starting at a linked node in the I tree and following the link to the M tree.</text>
              <doc_id>58</doc_id>
              <sec_id>12</sec_id>
            </sentence>
            <sentence>
              <text>Then, if available, we follow the link to the T tree and this leads us to the T-tree node corresponding to the I-tree node we started from.</text>
              <doc_id>59</doc_id>
              <sec_id>13</sec_id>
            </sentence>
            <sentence>
              <text>In Figure 1, this results in the I&#8211;T alignments I1&#8211;T18, I2&#8211;T2, I3&#8211; T1, I4&#8211;T32 and I6&#8211;T34.</text>
              <doc_id>60</doc_id>
              <sec_id>14</sec_id>
            </sentence>
            <sentence>
              <text>The first three links are matches, because the lexical items covered by the I nodes correspond exactly to the lexical items covered by their M node counterparts.</text>
              <doc_id>61</doc_id>
              <sec_id>15</sec_id>
            </sentence>
            <sentence>
              <text>Such alignments provide us with direct TM translations for our input.</text>
              <doc_id>62</doc_id>
              <sec_id>16</sec_id>
            </sentence>
            <sentence>
              <text>The last two links in the group are mismatched, because there is no lexical correspondence between the I and M nodes (node I4 corresponds to the phrase sender email, while the linked node M10 corresponds to sender &#8217;s email).</text>
              <doc_id>63</doc_id>
              <sec_id>17</sec_id>
            </sentence>
            <sentence>
              <text>Such alignments can only be used to infer reordering information.</text>
              <doc_id>64</doc_id>
              <sec_id>18</sec_id>
            </sentence>
            <sentence>
              <text>In particular in this case, we can infer that the target word order for the input sentence is address email sender, which produces the translation adresse &#233;lectronique de l&#8217; exp&#233;diteur.</text>
              <doc_id>65</doc_id>
              <sec_id>19</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>an input sentence, TM match and TM translation We decided to use sub-tree-based alignment, rather than plain word alignment (e.g. GIZA++ &#8211; Och and Ney, 2003), due to a number of factors.</text>
              <doc_id>66</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>First, sub-tree-based alignment provides much better handling of long-distance reorderings, while word&#8211; and phrase-based alignment models always have a fixed limit on reordering distance that tends to be relatively low to allow efficient computation.</text>
              <doc_id>67</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>The alignments produced by a sub-tree alignment model are also precision-oriented, rather than recall-oriented (cf. Tinsley, 2010).</text>
              <doc_id>68</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>This is important in our case, where we want to only extract those parts of the translation suggested by the TM for which we are most certain that they are good translations.</text>
              <doc_id>69</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>45 As stated earlier, the only resource necessary for the operation of this system is a probabilistic bilingual dictionary covering the data that needs to be aligned.</text>
              <doc_id>70</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>For the bilingual alignment step, such a bilingual dictionary is produced as a byproduct of the training of the SMT backend and therefore available.</text>
              <doc_id>71</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>For the monolingual alignment step, the required probabilistic dictionary is generated by simply listing each unique token seen in the source-language data in the TM as translating only as itself with probability 1.</text>
              <doc_id>72</doc_id>
              <sec_id>6</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Once the matching step is completed, we have identified and marked-up the parts of the input sentence for which translations will be extracted from the TM suggestions, as well as the parts that need to be translated from scratch.</text>
              <doc_id>73</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>The lengths of the non-translated segments vary depending on the FMS, but are in general relatively short (one to three tokens).</text>
              <doc_id>74</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>The further processing of the input relies on a specific feature of the SMT backend we use, namely the Moses system (Koehn et al., 2007).</text>
              <doc_id>75</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>We decided to use this particular system as it is the most widely adopted open-source SMT system, both for academic and commercial purposes.</text>
              <doc_id>76</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>In this approach, we annotate the segments of the input sentence for which translations have been found from the TM suggestion using XML tags with the translation corresponding to each segment given as an attribute to the encapsulating XML tag, similarly to the system described in (Smith and Clark, 2009).</text>
              <doc_id>77</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>The SMT backend is supplied with marked-up input in the form of a string consisting of the concatenation of the XML-enclosed translated segments and the plain non-translated segments in the targetlanguage word order, as established by the alignment process.</text>
              <doc_id>78</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>The SMT backend is instructed to translate this input, while keeping the translations supplied via the XML annotation.</text>
              <doc_id>79</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>This allows the SMT backend to produce translations informed by and conforming to actual examples from the TM, which should result in improvements in translation quality.</text>
              <doc_id>80</doc_id>
              <sec_id>7</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>It must be noted that in general the SMT backend sees the data it needs to translate in the targetlanguage word order (e.g. it is asked to translate an English sentence that has French word order).</text>
              <doc_id>81</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>This, however, does not correspond to the data found in the TM, which we use for deriving the SMT models.</text>
              <doc_id>82</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Because of this discrepancy, we developed a pre-processing tool that goes over the TM data performing bilingual alignment and outputting reordered versions of the sentences it processes by using the information implicitly encoded in the sub-tree alignments.</text>
              <doc_id>83</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>In this way we obtain the necessary reordered data to train a translation model where the source language already has the target-language word order.</text>
              <doc_id>84</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>In our system we than use this model &#8212; together with the proper-word-order model &#8212; for translation.</text>
              <doc_id>85</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>One specific aspect of real-world TM data that we need to deal with is that they often contain meta-tag annotations of various sorts.</text>
              <doc_id>86</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>Namely, annotation tags specific to the file format used for storing the TM data, XML tags annotating parts of the text as appearing in Graphical User Interface (GUI) elements, formatting tags specific to the file format the TM data was originally taken from, e.g. RTF, OpenDoc, etc. Letting any MT system try to deal with these tags in a probabilistic manner can easily result in ill-formed, mistranslated and/or out-of-order meta-tags in the translation.</text>
              <doc_id>87</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>This motivates the implementation of a rudimentary handling of meta-tags in the system presented in this paper, in particular handling the XML tags found in the TM data we work with, as described in Section 3.</text>
              <doc_id>88</doc_id>
              <sec_id>7</sec_id>
            </sentence>
            <sentence>
              <text>The tool we developed for this purpose simply builds a map of all unique XML tags per language and replaces them in the data with short placeholders that are designed in such a way that they would not interfere with the rest of the TM data.</text>
              <doc_id>89</doc_id>
              <sec_id>8</sec_id>
            </sentence>
            <sentence>
              <text>2 A special case that the tool has to take care of is when an XML tag contains an attribute whose value needs to be translated.</text>
              <doc_id>90</doc_id>
              <sec_id>9</sec_id>
            </sentence>
            <sentence>
              <text>In such situations, we decided to not perform any processing, but rather leave the XML tag as is, so that all text may be translated as needed.</text>
              <doc_id>91</doc_id>
              <sec_id>10</sec_id>
            </sentence>
            <sentence>
              <text>A complete treatment of meta-tags, however, is beyond the scope of the current paper.</text>
              <doc_id>92</doc_id>
              <sec_id>11</sec_id>
            </sentence>
            <sentence>
              <text>2 In the current implementation, the XML tags are replaced with the string apple&lt;tag_id&gt;apple, where &lt;tag_id&gt; is a unique numeric identifier for the XML tag that is being replaced.</text>
              <doc_id>93</doc_id>
              <sec_id>12</sec_id>
            </sentence>
            <sentence>
              <text>46 We also had to build a dedicated tokeniser/detokeniser pair to handle real world TM data containing meta-tags, e-mail addresses, file paths, etc., as described in Section 3.</text>
              <doc_id>94</doc_id>
              <sec_id>13</sec_id>
            </sentence>
            <sentence>
              <text>Both tools are implemented as a cascade of regular expression substitutions in Perl.</text>
              <doc_id>95</doc_id>
              <sec_id>14</sec_id>
            </sentence>
            <sentence>
              <text>Finally, we use a tool to extract the textual data from the TM.</text>
              <doc_id>96</doc_id>
              <sec_id>15</sec_id>
            </sentence>
            <sentence>
              <text>That is, we strip all tags specific to the format in which the TM is stored, as they can in general be recreated and thus do not need to be present during translation.</text>
              <doc_id>97</doc_id>
              <sec_id>16</sec_id>
            </sentence>
            <sentence>
              <text>In our particular case the TM is stored in the XML-based TMX format.</text>
              <doc_id>98</doc_id>
              <sec_id>17</sec_id>
            </sentence>
            <sentence>
              <text>3</text>
              <doc_id>99</doc_id>
              <sec_id>18</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Besides the components described above, we also performed two further transformations on the data.</text>
              <doc_id>100</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>First, we lowercase the TM data before using it to train the SMT backend models.</text>
              <doc_id>101</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>This also means that the alignment steps from Section 2.3 are performed on lowercased data, as the bilingual dictionary used there is obtained during the SMT training process.</text>
              <doc_id>102</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>4 Additionally, the SMT and sub-tree alignment systems that we use cannot handle certain characters, which we need to mask in the data.</text>
              <doc_id>103</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>For the SMT backend, this includes &#8216;|&#8217;, &#8216;&lt;&#8217; and &#8216;&gt;&#8217; and for the sub-tree aligner, &#8216;(&#8217; and &#8216;)&#8217;.</text>
              <doc_id>104</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>The reason these characters cannot be handled is that the SMT system uses &#8216;|&#8217; internally to separate data fields in the trained models and &#8216;&lt;&#8217; and &#8216;&gt;&#8217; cannot be handled whilst using XML tags to annotate pre-translated portions of the input.</text>
              <doc_id>105</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>The subtree aligner uses &#8216;(&#8217; and &#8216;)&#8217; to represent the phrase-based tree structures it generates and the presence of these characters in the data may create ambiguity when parsing the tree structures.</text>
              <doc_id>106</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>All these characters are masked by substituting in high-Unicode counterparts, namely &#8216;&#9474;&#8217;, &#8216;&#65533;&#8217;, &#8216;&#65533;&#8217;, &#8216;&#65533;&#8217; and &#8216;&#65533;&#8217;.</text>
              <doc_id>107</doc_id>
              <sec_id>7</sec_id>
            </sentence>
            <sentence>
              <text>Visually, there is a very slight distinction and this is intentionally so to simplify debugging.</text>
              <doc_id>108</doc_id>
              <sec_id>8</sec_id>
            </sentence>
            <sentence>
              <text>However, the fact that the character codes are different alleviates the problems discussed above.</text>
              <doc_id>109</doc_id>
              <sec_id>9</sec_id>
            </sentence>
            <sentence>
              <text>Of course, in the final output, the masking is reversed and the translation contains the regular versions of the characters.</text>
              <doc_id>110</doc_id>
              <sec_id>10</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The complete pre-processing workflow is presented in Figure 2, where the rectangles with vertical bars represent the use of open-source tools, while the plain rectangles represent tools developed by the authors of this paper.</text>
              <doc_id>111</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>First, the textual data is extracted from the original TM format, producing one plain-text file for each language side.</text>
              <doc_id>112</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>These data can either be pre-loaded in a PostgreSQL database at this time, or during the first run of the translation system.</text>
              <doc_id>113</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Next, the meta-tag-handling tool is used to generate the substitution tables for the source and target languages, as well as new files for each language with the tags substituted by the corresponding identifiers (cf. Section 2.5).</text>
              <doc_id>114</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>These files are then tokenised, lowercased and all conflicting characters are masked, as described above.</text>
              <doc_id>115</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>The pre-processed files are then used to produce a file containing pairs of sentences in the input format of the sub-tree aligner, as well as to generate the probabilistic dictionary required for</text>
              <doc_id>116</doc_id>
              <sec_id>5</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>will be added in a future version of the system.</text>
              <doc_id>117</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>47 the monolingual alignment and to train the SMT model on the data in the proper word order.</text>
              <doc_id>118</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>The SMT training produces the necessary bilingual dictionary for use by the sub-tree aligner, which is run to obtain a parallel-treebank version of the TM data.</text>
              <doc_id>119</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>The parallel treebank is then used to retrieve bilingual alignments for the TM data, rather than generate them on the fly during translation.</text>
              <doc_id>120</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>This is an important design decision, as the complexity of the alignment algorithm is high for plain-text alignment (cf. Zhechev, 2010).</text>
              <doc_id>121</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Once we have generated the bilingual parallel treebank, we run the reordering tool, which generates a new plain-text file for the source language, where the sentences are modified to conform to the target-language word order, as implied by the data in the parallel treebank.</text>
              <doc_id>122</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>This is then matched with the proper-order targetlanguage file to train the SMT backend for the actual use in the translation process.</text>
              <doc_id>123</doc_id>
              <sec_id>6</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Once all the necessary files have been generated and all pre-processing steps have been completed, the system is ready for use for translation.</text>
              <doc_id>124</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>The translation workflow is shown in Figure 3, &#8216;I&#8217;, &#8216;M&#8217; and &#8216;T&#8217; having the same meanings as in Figure 1.</text>
              <doc_id>125</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Here, the first step after an input sentence has been read in is to find the TM match with the highest FMS.</text>
              <doc_id>126</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>This is done using the original plain non-pre-processed data to simulate real-life operation with a proper TM backend.</text>
              <doc_id>127</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>After the best TM match and its translation are extracted from the TM, they &#8212; together with the input sentence &#8212; are pre-processed by tokenisation, lowercasing, meta-tag and special-character substitution.</text>
              <doc_id>128</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Next, the corresponding tree pair is extracted from the bilingual parallel treebank to establish the tree structure for the TM sourcelanguage match.</text>
              <doc_id>129</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>This tree structure is then used to perform the monolingual alignment, which allows us to perform the matching step next.</text>
              <doc_id>130</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>After the matching is complete, we generate a final translation as described in Section 2.4.</text>
              <doc_id>131</doc_id>
              <sec_id>7</sec_id>
            </sentence>
            <sentence>
              <text>Finally, the translations are de-tokenised and the XML tags and special characters are unmasked.</text>
              <doc_id>132</doc_id>
              <sec_id>8</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>3</index>
        <title>3. Experimental Setup</title>
        <text>We use real-life TM data from an industrial partner. The TM was generated during the translation of RTF-formatted customer support documentation. The data is in TMX format and originally contains 108 967 English&#8211;French translation segments, out of which 14 segments either have an empty language side or have an extreme discrepancy in the number of tokens for each language side and were therefore discarded. A particular real-life trait of the data is the presence of a large number of XML tags. Running the tag-mapping tool described in Section 2.6, we gathered 2 049 distinct tags for the English side of the data and 2 653 for the French side. Still, there were certain XML tags that included a label argument whose value was translated from one language to the other. These XML tags were left intact so that our system could handle the translation correctly. The TM data also contain a large number of file paths, e-mail addresses, URLs and others, which makes bespoke tokenisation of the data necessary. Our tokenisation tool ensures that none of these elements are tokenised, keeps RTF formatting sequences non-tokenised and properly handles non-masked XML tags, minimising their fragmentation. As translation segments rarely occur more than once in a TM, we observe a high number of unique tokens (measured after pre-processing) &#8212; 41 379 for English and 49 971 for French &#8212; out of 48 108 953 segment pairs. The average sentence length is 13.2 for English and 15.0 for French. For evaluation, we use a data set of 4977 English&#8211;French segments from the domain of the TM. The sentences in the test set are significantly shorter on average, compared to the TM &#8212; 9.2 tokens for English and 10.9 for French. It must be noted that we used SMT models with maximum phrase length of 3 tokens, rather than the standard 5 tokens, and for decoding we used a 3-gram language model. This results in much smaller models than the ones usually used in mainstream SMT applications. (The standard for some tools goes as far as 7-token phaselength limit and 7-gram language models)</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>We use real-life TM data from an industrial partner.</text>
              <doc_id>133</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>The TM was generated during the translation of RTF-formatted customer support documentation.</text>
              <doc_id>134</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>The data is in TMX format and originally contains 108 967 English&#8211;French translation segments, out of which 14 segments either have an empty language side or have an extreme discrepancy in the number of tokens for each language side and were therefore discarded.</text>
              <doc_id>135</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>A particular real-life trait of the data is the presence of a large number of XML tags.</text>
              <doc_id>136</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Running the tag-mapping tool described in Section 2.6, we gathered 2 049 distinct tags for the English side of the data and 2 653 for the French side.</text>
              <doc_id>137</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Still, there were certain XML tags that included a label argument whose value was translated from one language to the other.</text>
              <doc_id>138</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>These XML tags were left intact so that our system could handle the translation correctly.</text>
              <doc_id>139</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>The TM data also contain a large number of file paths, e-mail addresses, URLs and others, which makes bespoke tokenisation of the data necessary.</text>
              <doc_id>140</doc_id>
              <sec_id>7</sec_id>
            </sentence>
            <sentence>
              <text>Our tokenisation tool ensures that none of these elements are tokenised, keeps RTF formatting sequences non-tokenised and properly handles non-masked XML tags, minimising their fragmentation.</text>
              <doc_id>141</doc_id>
              <sec_id>8</sec_id>
            </sentence>
            <sentence>
              <text>As translation segments rarely occur more than once in a TM, we observe a high number of unique tokens (measured after pre-processing) &#8212; 41 379 for English and 49 971 for French &#8212; out of 48 108 953 segment pairs.</text>
              <doc_id>142</doc_id>
              <sec_id>9</sec_id>
            </sentence>
            <sentence>
              <text>The average sentence length is 13.2 for English and 15.0 for French.</text>
              <doc_id>143</doc_id>
              <sec_id>10</sec_id>
            </sentence>
            <sentence>
              <text>For evaluation, we use a data set of 4977 English&#8211;French segments from the domain of the TM.</text>
              <doc_id>144</doc_id>
              <sec_id>11</sec_id>
            </sentence>
            <sentence>
              <text>The sentences in the test set are significantly shorter on average, compared to the TM &#8212; 9.2 tokens for English and 10.9 for French.</text>
              <doc_id>145</doc_id>
              <sec_id>12</sec_id>
            </sentence>
            <sentence>
              <text>It must be noted that we used SMT models with maximum phrase length of 3 tokens, rather than the standard 5 tokens, and for decoding we used a 3-gram language model.</text>
              <doc_id>146</doc_id>
              <sec_id>13</sec_id>
            </sentence>
            <sentence>
              <text>This results in much smaller models than the ones usually used in mainstream SMT applications.</text>
              <doc_id>147</doc_id>
              <sec_id>14</sec_id>
            </sentence>
            <sentence>
              <text>(The standard for some tools goes as far as 7-token phaselength limit and 7-gram language models)</text>
              <doc_id>148</doc_id>
              <sec_id>15</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>4</index>
        <title>4. Evaluation Results</title>
        <text>For the evaluation of our system, we used a number of widely accepted automatic metrics, namely BLEU (Papineni et al., 2002), METEOR (Banerjee and Lavie, 2005), TER (Snover et al., 2006) and inverse F-Score based on token-level precision and recall. We setup our system to only fully process input sentences for which a TM match with an FMS over 50% was found, although all sentences were translated directly using the SMT backend to check the overall pure SMT performance. The TM-suggested translations were also output for all input sentences. The results of the evaluation are given in Figure 4, where the tm and direct scores are also given for the FMS range [0%; 50%)&#8746;{100%}. Across all metrics we see a uniform drop in the quality of TM-suggested translations, which is what we expected, given that these translations contain one or more wrong words. We believe that the relatively high scores recorded for the TM-suggested translations at the high end of the FMS scale are a result of the otherwise perfect word order and lexical choice. For n-grammatch-based metrics like the ones we used such a result is expected and predictable. Although the inverse F-score results show the potential of our setup to translate the outstanding tokens in a 90%&#8211;100% TM match, it appears that the SMT system produces word order that does not correspond to the reference translation and because of this receives lower scores on the other metrics. The unexpected drop in scores for perfect TM matches is due to discrepancies between the reference translations in our test set and the translations stored in the TM. We believe that this issue
for non-perfect matches. Unfortunately, the exact impact cannot be ascertained without human evaluation. We observe a significant drop-off in translation quality for the direct output below FMS 50%. This suggests that sentences with such low FMS should be translated either by a human translator from scratch, or by an SMT system trained on different/more data. Our system (i.e. the xml setup) clearly outperforms the direct SMT translation for FMS between 80 and 100 and has comparable performance between FMS 70 and 80. Below FMS 70, the SMT backend has the best performance. Although these results are positive, we still need to investigate why our system has poor performance at lower FMS ranges. Theoretically, it should outperform the SMT backend across all ranges, as its output is generated by supplying the SMT backend with good pre-translated fragments. The Inverse F-Score graph suggest that this is due to worse lexical choice, but only manual evaluation can provide us with clues for solving the issue. The discrepancy in the results in the Inverse F- Score graph with the other metrics suggest that the biggest problem for our system is producing output in the expected word-order.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>For the evaluation of our system, we used a number of widely accepted automatic metrics, namely BLEU (Papineni et al., 2002), METEOR (Banerjee and Lavie, 2005), TER (Snover et al., 2006) and inverse F-Score based on token-level precision and recall.</text>
              <doc_id>149</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>We setup our system to only fully process input sentences for which a TM match with an FMS over 50% was found, although all sentences were translated directly using the SMT backend to check the overall pure SMT performance.</text>
              <doc_id>150</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>The TM-suggested translations were also output for all input sentences.</text>
              <doc_id>151</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>The results of the evaluation are given in Figure 4, where the tm and direct scores are also given for the FMS range [0%; 50%)&#8746;{100%}.</text>
              <doc_id>152</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Across all metrics we see a uniform drop in the quality of TM-suggested translations, which is what we expected, given that these translations contain one or more wrong words.</text>
              <doc_id>153</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>We believe that the relatively high scores recorded for the TM-suggested translations at the high end of the FMS scale are a result of the otherwise perfect word order and lexical choice.</text>
              <doc_id>154</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>For n-grammatch-based metrics like the ones we used such a result is expected and predictable.</text>
              <doc_id>155</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>Although the inverse F-score results show the potential of our setup to translate the outstanding tokens in a 90%&#8211;100% TM match, it appears that the SMT system produces word order that does not correspond to the reference translation and because of this receives lower scores on the other metrics.</text>
              <doc_id>156</doc_id>
              <sec_id>7</sec_id>
            </sentence>
            <sentence>
              <text>The unexpected drop in scores for perfect TM matches is due to discrepancies between the reference translations in our test set and the translations stored in the TM.</text>
              <doc_id>157</doc_id>
              <sec_id>8</sec_id>
            </sentence>
            <sentence>
              <text>We believe that this issue</text>
              <doc_id>158</doc_id>
              <sec_id>9</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>for non-perfect matches.</text>
              <doc_id>159</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Unfortunately, the exact impact cannot be ascertained without human evaluation.</text>
              <doc_id>160</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>We observe a significant drop-off in translation quality for the direct output below FMS 50%.</text>
              <doc_id>161</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>This suggests that sentences with such low FMS should be translated either by a human translator from scratch, or by an SMT system trained on different/more data.</text>
              <doc_id>162</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Our system (i.e. the xml setup) clearly outperforms the direct SMT translation for FMS between 80 and 100 and has comparable performance between FMS 70 and 80.</text>
              <doc_id>163</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Below FMS 70, the SMT backend has the best performance.</text>
              <doc_id>164</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>Although these results are positive, we still need to investigate why our system has poor performance at lower FMS ranges.</text>
              <doc_id>165</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>Theoretically, it should outperform the SMT backend across all ranges, as its output is generated by supplying the SMT backend with good pre-translated fragments.</text>
              <doc_id>166</doc_id>
              <sec_id>7</sec_id>
            </sentence>
            <sentence>
              <text>The Inverse F-Score graph suggest that this is due to worse lexical choice, but only manual evaluation can provide us with clues for solving the issue.</text>
              <doc_id>167</doc_id>
              <sec_id>8</sec_id>
            </sentence>
            <sentence>
              <text>The discrepancy in the results in the Inverse F- Score graph with the other metrics suggest that the biggest problem for our system is producing output in the expected word-order.</text>
              <doc_id>168</doc_id>
              <sec_id>9</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>5</index>
        <title>5. Future Work</title>
        <text>There are a number of possible directions for improvement that can be explored. As mentioned earlier, we plan to integrate our system with a full-featured open-source or commercial TM product that will supply the TM matches and translations. We expect this to improve our results, as the quality of the TM matches will better correspond to the reported FMS. Such an integration will also be the first necessary step to perform a user study evaluating the effect of the use of our system on post-editing speeds. We expect the findings of such a study to show a significant increase of throughput that will significantly reduce the costs of translation for large-scale projects. It would be interesting to also conduct a user study where our system is used to additionally mark up the segments that need to be edited in the final SMT translation. We expect this to provide additional speedup to the post-editing process. Such a study will require tight integration between our system and a CAT tool and the modular design we presented will facilitate this significantly. The proposed treatment of meta-tags is currently very rudimentary and may be extended with additional features and to handle additional types of tags. The design of our system currently allows the meta-tag-handling tool to be developed independently, thus giving the user the choice of using a different meta-tag tool for each type of data they work with. In addition, the reordering tool needs to be developed further, with emphasis on properly handling situations where the appropriate position of an input-sentence segment cannot be reliably established. In general, further research is needed into the reordering errors introduced by the SMT system into otherwise good translations.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>There are a number of possible directions for improvement that can be explored.</text>
              <doc_id>169</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>As mentioned earlier, we plan to integrate our system with a full-featured open-source or commercial TM product that will supply the TM matches and translations.</text>
              <doc_id>170</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>We expect this to improve our results, as the quality of the TM matches will better correspond to the reported FMS.</text>
              <doc_id>171</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Such an integration will also be the first necessary step to perform a user study evaluating the effect of the use of our system on post-editing speeds.</text>
              <doc_id>172</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>We expect the findings of such a study to show a significant increase of throughput that will significantly reduce the costs of translation for large-scale projects.</text>
              <doc_id>173</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>It would be interesting to also conduct a user study where our system is used to additionally mark up the segments that need to be edited in the final SMT translation.</text>
              <doc_id>174</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>We expect this to provide additional speedup to the post-editing process.</text>
              <doc_id>175</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>Such a study will require tight integration between our system and a CAT tool and the modular design we presented will facilitate this significantly.</text>
              <doc_id>176</doc_id>
              <sec_id>7</sec_id>
            </sentence>
            <sentence>
              <text>The proposed treatment of meta-tags is currently very rudimentary and may be extended with additional features and to handle additional types of tags.</text>
              <doc_id>177</doc_id>
              <sec_id>8</sec_id>
            </sentence>
            <sentence>
              <text>The design of our system currently allows the meta-tag-handling tool to be developed independently, thus giving the user the choice of using a different meta-tag tool for each type of data they work with.</text>
              <doc_id>178</doc_id>
              <sec_id>9</sec_id>
            </sentence>
            <sentence>
              <text>In addition, the reordering tool needs to be developed further, with emphasis on properly handling situations where the appropriate position of an input-sentence segment cannot be reliably established.</text>
              <doc_id>179</doc_id>
              <sec_id>10</sec_id>
            </sentence>
            <sentence>
              <text>In general, further research is needed into the reordering errors introduced by the SMT system into otherwise good translations.</text>
              <doc_id>180</doc_id>
              <sec_id>11</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>6</index>
        <title>6. Conclusions</title>
        <text>In this paper, we presented a novel modular approach to the utilisation of Translation Memory data to improve the quality of Statistical Machine Translation. The system we developed uses precise subtree-based alignments to reliably determine and mark up correspondences between an input sentence and a TM-suggested translation, which ensures the utilisation of the high-quality translation data stored in the TM database. An SMT backend then translates the marked-up input sentence to produce a final translation with improved quality. Our evaluation shows that the system presented in this paper significantly improves the quality of SMT output when using TM matches with FMS above 80 and produces results on par with the pure SMT output for SMT between 70 and 80. TM matches with FMS under 70 seem to provide insufficient reordering information and too few matches to improve on the SMT output. Still, further investigation is needed to properly diagnose the drop in quality for FMS below 70. We expect further improvements to the reordering functionality of our system to result in higher-quality output even for lower FMS ranges.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>In this paper, we presented a novel modular approach to the utilisation of Translation Memory data to improve the quality of Statistical Machine Translation.</text>
              <doc_id>181</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>The system we developed uses precise subtree-based alignments to reliably determine and mark up correspondences between an input sentence and a TM-suggested translation, which ensures the utilisation of the high-quality translation data stored in the TM database.</text>
              <doc_id>182</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>An SMT backend then translates the marked-up input sentence to produce a final translation with improved quality.</text>
              <doc_id>183</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Our evaluation shows that the system presented in this paper significantly improves the quality of SMT output when using TM matches with FMS above 80 and produces results on par with the pure SMT output for SMT between 70 and 80.</text>
              <doc_id>184</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>TM matches with FMS under 70 seem to provide insufficient reordering information and too few matches to improve on the SMT output.</text>
              <doc_id>185</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Still, further investigation is needed to properly diagnose the drop in quality for FMS below 70.</text>
              <doc_id>186</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>We expect further improvements to the reordering functionality of our system to result in higher-quality output even for lower FMS ranges.</text>
              <doc_id>187</doc_id>
              <sec_id>6</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>7</index>
        <title>50 Acknowledgements</title>
        <text>This research is funded under the 7 th Framework Programme of the European Commission within the EuroMatrixPlus project (grant &#8470; 231720). The data used for evaluation was generously provided by Symantec Ireland.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>This research is funded under the 7 th Framework Programme of the European Commission within the EuroMatrixPlus project (grant &#8470; 231720).</text>
              <doc_id>188</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>The data used for evaluation was generously provided by Symantec Ireland.</text>
              <doc_id>189</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
    </sections>
    <tables/>
    <references>
      <reference>
        <id>0</id>
        <authors>
          <author>Satanjeev Banerjee</author>
          <author>Alon Lavie</author>
        </authors>
        <title>METEOR: An Automatic Metric for MT Evaluation with Improved Correlation with Human Judgements.</title>
        <publication>In Proceedings of the Workshop on Intrinsic and Extrinsic Evaluation Measures for MT and/or Summarization at the 43rd Annual Meeting of the Association for Computational Linguistics (ACL &#8217;05),</publication>
        <pages>65--72</pages>
        <date>2005</date>
      </reference>
      <reference>
        <id>1</id>
        <authors>
          <author>Ergun Bi&#231;ici</author>
          <author>Marc Dymetman</author>
        </authors>
        <title>Dynamic Translation Memory: Using Statistical Machine Translation to improve Translation Memory Fuzzy Matches.</title>
        <publication>In Proceedings of the 9th International Conference on Intelligent Text Processing and Computational Linguistics (CICLing &#8217;08),</publication>
        <pages>454--465</pages>
        <date>2008</date>
      </reference>
      <reference>
        <id>2</id>
        <authors>
          <author>Matthias Heyn</author>
        </authors>
        <title>Integrating Machine Translation into Translation Memory Systems.</title>
        <publication>In Proceedings of the EAMT Machine Translation Workshop, TKE &#8217;96,</publication>
        <pages>113--126</pages>
        <date>1996</date>
      </reference>
      <reference>
        <id>3</id>
        <authors>
          <author>Philipp Koehn</author>
          <author>Hieu Hoang</author>
          <author>Alexandra Birch</author>
          <author>Chris Callison-Burch</author>
          <author>Marcello Federico</author>
          <author>Nicola Bertoldi</author>
          <author>Brooke Cowan</author>
          <author>Wade Shen</author>
          <author>Christine Moran</author>
          <author>Richard Zens</author>
          <author>Chris Dyer</author>
        </authors>
        <title>Ond&#345;ej Bojar, Alexandra Constantin and Evan Herbst.</title>
        <publication>In Proceedings of the Demo and Poster Sessions of the 45th Annual Meeting of the Association for Computational Linguistics (ACL &#8217;07),</publication>
        <pages>177--180</pages>
        <date>2007</date>
      </reference>
      <reference>
        <id>4</id>
        <authors>
          <author>Vladimir I Levenshtein</author>
        </authors>
        <title>&#1044;&#1074;&#1086;&#1080;&#1095;&#1085;&#1099;&#1077; &#1082;&#1086;&#1076;&#1099; &#1089; &#1080;&#1089;&#1087;&#1088;&#1072;&#1074;&#1083;&#1077;&#1085;&#1080;&#1077;&#1084; &#1074;&#1099;&#1087;&#1072;&#1076;&#1077;&#1085;&#1080;&#1081;, &#1074;&#1089;&#1090;&#1072;&#1074;&#1086;&#1082; &#1080; &#1079;&#1072;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1081; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;&#1086;&#1074; (Binary Codes Capable of Correcting Deletions, Insertions, and Reversals). &#1044;&#1086;&#1082;&#1083;&#1072;&#1076;&#1099; &#1040;&#1082;&#1072;&#1076;&#1077;&#1084;&#1080;&#1081; &#1053;&#1072;&#1091;&#1082; &#1057;&#1057;&#1057;&#1056;,</title>
        <publication>None</publication>
        <pages>845--848</pages>
        <date>1965</date>
      </reference>
      <reference>
        <id>5</id>
        <authors>
          <author>Franz Josef Och</author>
          <author>Hermann Ney</author>
        </authors>
        <title>reprinted in: Soviet Physics Doklady,</title>
        <publication>None</publication>
        <pages>707--710</pages>
        <date>2003</date>
      </reference>
      <reference>
        <id>6</id>
        <authors>
          <author>Kishore Papineni</author>
          <author>Salim Roukos</author>
          <author>Todd Ward</author>
          <author>Wei-Jing Zhu</author>
        </authors>
        <title>BLEU: A Method for Automatic Evaluation of Machine Translation.</title>
        <publication>In Proceedings of the 40th Annual Meeting of the Association of Computational Linguistics (ACL &#8217;02),</publication>
        <pages>311--318</pages>
        <date>2002</date>
      </reference>
      <reference>
        <id>7</id>
        <authors>
          <author>Michel Simard</author>
          <author>Pierre Isabelle</author>
        </authors>
        <title>Phrasebased Machine Translation in a Computer-assisted Translation Environment.</title>
        <publication>In The Twelfth Machine Translation Summit (MT Summit XII),</publication>
        <pages>120--127</pages>
        <date>2009</date>
      </reference>
      <reference>
        <id>8</id>
        <authors>
          <author>James Smith</author>
          <author>Stephen Clark</author>
        </authors>
        <title>EBMT for SMT: A New EBMT&#8211;SMT Hybrid.</title>
        <publication>In Proceedings of the 3rd International Workshop on ExampleBased Machine Translation (EBMT &#8217;09),</publication>
        <pages>3--10</pages>
        <date>2009</date>
      </reference>
      <reference>
        <id>9</id>
        <authors>
          <author>Matthew Snover</author>
          <author>Bonnie J Dorr</author>
          <author>Richard Schwartz</author>
          <author>Linnea Micciulla</author>
          <author>John Makhoul</author>
        </authors>
        <title>A Study of Translation Edit Rate with Targeted Human Annotation.</title>
        <publication>In Proceedings of the 7th Conference of the Association for Machine Translation in the Americas (AMTA &#8217;06),</publication>
        <pages>223--231</pages>
        <date>2006</date>
      </reference>
      <reference>
        <id>10</id>
        <authors>
          <author>John Tinsley</author>
        </authors>
        <title>Resourcing Machine Translation with Parallel Treebanks. School of Computing, Dublin City Univercity: PhD Thesis.</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>2010</date>
      </reference>
    </references>
    <citations>
      <citation>
        <id>0</id>
        <reference_id>0</reference_id>
        <string>Banerjee and Lavie, 2005</string>
        <sentence_id>44392</sentence_id>
        <char_offset>134</char_offset>
      </citation>
      <citation>
        <id>1</id>
        <reference_id>1</reference_id>
        <string>Bi&#231;ici and Dymetman (2008)</string>
        <sentence_id>44269</sentence_id>
        <char_offset>56</char_offset>
      </citation>
      <citation>
        <id>2</id>
        <reference_id>2</reference_id>
        <string>Heyn, 1996</string>
        <sentence_id>44257</sentence_id>
        <char_offset>176</char_offset>
      </citation>
      <citation>
        <id>3</id>
        <reference_id>3</reference_id>
        <string>Koehn et al., 2007</string>
        <sentence_id>44318</sentence_id>
        <char_offset>117</char_offset>
      </citation>
      <citation>
        <id>4</id>
        <reference_id>4</reference_id>
        <string>Levenshtein, 1965</string>
        <sentence_id>44280</sentence_id>
        <char_offset>170</char_offset>
      </citation>
      <citation>
        <id>5</id>
        <reference_id>5</reference_id>
        <string>Och and Ney, 2003</string>
        <sentence_id>44309</sentence_id>
        <char_offset>139</char_offset>
      </citation>
      <citation>
        <id>6</id>
        <reference_id>6</reference_id>
        <string>Papineni et al., 2002</string>
        <sentence_id>44392</sentence_id>
        <char_offset>102</char_offset>
      </citation>
      <citation>
        <id>7</id>
        <reference_id>7</reference_id>
        <string>Simard and Isabelle (2009)</string>
        <sentence_id>44269</sentence_id>
        <char_offset>87</char_offset>
      </citation>
      <citation>
        <id>8</id>
        <reference_id>7</reference_id>
        <string>Simard and Isabelle, 2009</string>
        <sentence_id>44255</sentence_id>
        <char_offset>251</char_offset>
      </citation>
      <citation>
        <id>9</id>
        <reference_id>8</reference_id>
        <string>Smith and Clark, 2009</string>
        <sentence_id>44271</sentence_id>
        <char_offset>40</char_offset>
      </citation>
      <citation>
        <id>10</id>
        <reference_id>8</reference_id>
        <string>Smith and Clark, 2009</string>
        <sentence_id>44320</sentence_id>
        <char_offset>283</char_offset>
      </citation>
      <citation>
        <id>11</id>
        <reference_id>9</reference_id>
        <string>Snover et al., 2006</string>
        <sentence_id>44392</sentence_id>
        <char_offset>166</char_offset>
      </citation>
      <citation>
        <id>12</id>
        <reference_id>10</reference_id>
        <string>Tinsley, 2010</string>
        <sentence_id>44311</sentence_id>
        <char_offset>116</char_offset>
      </citation>
    </citations>
  </content>
</document>
