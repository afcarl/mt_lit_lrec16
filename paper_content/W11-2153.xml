<document>
  <filename>W11-2153</filename>
  <authors>
    <author>Martin Popel</author>
    <author>David Mare&#269;ek</author>
    <author>Nathan Green</author>
  </authors>
  <title>Influence of Parser Choice on Dependency-Based MT</title>
  <content>
    <sections>
      <section>
        <index>0</index>
        <title>Abstract</title>
        <text>Accuracy of dependency parsers is one of the key factors limiting the quality of dependencybased machine translation. This paper deals with the influence of various dependency parsing approaches (and also different training data size) on the overall performance of an English-to-Czech dependency-based statistical translation system implemented in the Treex framework. We also study the relationship between parsing accuracy in terms of unlabeled attachment score and machine translation quality in terms of BLEU.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>Accuracy of dependency parsers is one of the key factors limiting the quality of dependencybased machine translation.</text>
              <doc_id>0</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>This paper deals with the influence of various dependency parsing approaches (and also different training data size) on the overall performance of an English-to-Czech dependency-based statistical translation system implemented in the Treex framework.</text>
              <doc_id>1</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>We also study the relationship between parsing accuracy in terms of unlabeled attachment score and machine translation quality in terms of BLEU.</text>
              <doc_id>2</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>1</index>
        <title>1 Introduction</title>
        <text>In the last years, statistical n-gram models dominated the field of Machine Translation (MT). However, their results are still far from perfect. Therefore we believe it makes sense to investigate alternative statistical approaches. This paper is focused on an analysis-transfer-synthesis translation system called TectoMT whose transfer representation has a shape of a deep-syntactic dependency tree. The system has been introduced by &#381;abokrtsk&#253; et al. (2008). The translation direction under consideration is Englishto-Czech.
It has been shown by Popel (2009) that the current accuracy of the dependency parser employed in this translation system is one of the limiting factors from the viewpoint of its output quality. In other words, the parsing phase is responsible for a large portion of translation errors. The biggest source of translation errors in the referred study was (and probably still is) the transfer phase, however the proportion has changed since and the relative importance of the parsing phase has grown, because the tranfer phase errors have already been addressed by improvements based on Hidden Markov Tree Models for lexical and syntactic choice as shown by &#381;abokrtsk&#253; and Popel (2009), and by context sensitive translation models based on maximum entropy as described by Mare&#269;ek et al. (2010). Our study proceeds along two directions. First, we train two state-of-the-art dependency parsers on training sets with varying size. Second, we use five parsers based on different parsing techniques. In both cases we document the relation between parsing accuracy (in terms of Unlabeled Attachment Score, UAS) and translation quality (estimated by the well known BLEU metric).
The motivation behind the first set of experiments is that we can extrapolate the learning curve and try to predict how new advances in dependency parsing can affect MT quality in the future.
The second experiment series is motivated by the hypothesis that parsers based on different approaches are likely to have a different distribution of errors, even if they can have competitive performance in parsing accuracy. In dependency parsing metrics, all types of incorrect edges typically have the same weight, 1 but some incorrect edges can be more harmful than others from the MT viewpoint. For instance, an incorrect attachment of an adverbial node is usually harmless, while incorrect attachment of a subject node might have several negative conse-
1 This issue has been tackled already in the parsing literature;
for example, some authors disregard placement of punctuation nodes within trees in the evaluation (Zeman, 2004).
quences such as:
&#8226; unrecognized finiteness of the governing verb, which can lead to a wrong syntactization on the target side (an infinitive verb phrase instead of a finite clause),
&#8226; wrong choice of the target-side verb form (because of unrecognized subject-predicate agreement),
&#8226; missing punctuation (because of wrongly recognized finite clause boundaries),
&#8226; wrong placement of clitics (because of wrongly recognized finite clause boundaries),
&#8226; wrong form of pronouns (personal and possessive pronouns referring to the clause&#8217;s subject should have reflexive forms in Czech).
Thus it is obvious that the parser choice is important and that it might not be enough to choose a parser, for machine translation, only according to its UAS.
Due to growing popularity of dependency syntax in the last years, there are a number of dependency parsers available. The present paper deals with five parsers evaluated within the translation framework: three genuine dependency parsers, namely the parsers described in (McDonald et al., 2005), (Nivre et al., 2007), and (Zhang and Nivre, 2011), and two constituency parsers (Charniak and Johnson, 2005) and (Klein and Manning, 2003), whose outputs were converted to dependency structures by Penn Converter (Johansson and Nugues, 2007).
As for the related literature, there is no published study measuring the influence of dependency parsers on dependency-based MT to our knowledge. 2 The remainder of this paper is structured as follows. The overall translation pipeline, within which the parsers are tested, is described in Section 2. Section 3 lists the parsers under consideration and their main features. Section 4 summarizes the influence of the selected parsers on the MT quality in terms of BLEU. Section 5 concludes.
2 However, the parser bottleneck of the dependency-based
MT approach was observed also by other researchers (Robert Moore, personal communication).</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>In the last years, statistical n-gram models dominated the field of Machine Translation (MT).</text>
              <doc_id>3</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>However, their results are still far from perfect.</text>
              <doc_id>4</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Therefore we believe it makes sense to investigate alternative statistical approaches.</text>
              <doc_id>5</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>This paper is focused on an analysis-transfer-synthesis translation system called TectoMT whose transfer representation has a shape of a deep-syntactic dependency tree.</text>
              <doc_id>6</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>The system has been introduced by &#381;abokrtsk&#253; et al. (2008).</text>
              <doc_id>7</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>The translation direction under consideration is Englishto-Czech.</text>
              <doc_id>8</doc_id>
              <sec_id>5</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>It has been shown by Popel (2009) that the current accuracy of the dependency parser employed in this translation system is one of the limiting factors from the viewpoint of its output quality.</text>
              <doc_id>9</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>In other words, the parsing phase is responsible for a large portion of translation errors.</text>
              <doc_id>10</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>The biggest source of translation errors in the referred study was (and probably still is) the transfer phase, however the proportion has changed since and the relative importance of the parsing phase has grown, because the tranfer phase errors have already been addressed by improvements based on Hidden Markov Tree Models for lexical and syntactic choice as shown by &#381;abokrtsk&#253; and Popel (2009), and by context sensitive translation models based on maximum entropy as described by Mare&#269;ek et al. (2010).</text>
              <doc_id>11</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Our study proceeds along two directions.</text>
              <doc_id>12</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>First, we train two state-of-the-art dependency parsers on training sets with varying size.</text>
              <doc_id>13</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Second, we use five parsers based on different parsing techniques.</text>
              <doc_id>14</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>In both cases we document the relation between parsing accuracy (in terms of Unlabeled Attachment Score, UAS) and translation quality (estimated by the well known BLEU metric).</text>
              <doc_id>15</doc_id>
              <sec_id>6</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The motivation behind the first set of experiments is that we can extrapolate the learning curve and try to predict how new advances in dependency parsing can affect MT quality in the future.</text>
              <doc_id>16</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The second experiment series is motivated by the hypothesis that parsers based on different approaches are likely to have a different distribution of errors, even if they can have competitive performance in parsing accuracy.</text>
              <doc_id>17</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>In dependency parsing metrics, all types of incorrect edges typically have the same weight, 1 but some incorrect edges can be more harmful than others from the MT viewpoint.</text>
              <doc_id>18</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>For instance, an incorrect attachment of an adverbial node is usually harmless, while incorrect attachment of a subject node might have several negative conse-</text>
              <doc_id>19</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>1 This issue has been tackled already in the parsing literature;</text>
              <doc_id>20</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>for example, some authors disregard placement of punctuation nodes within trees in the evaluation (Zeman, 2004).</text>
              <doc_id>21</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>quences such as:</text>
              <doc_id>22</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8226; unrecognized finiteness of the governing verb, which can lead to a wrong syntactization on the target side (an infinitive verb phrase instead of a finite clause),</text>
              <doc_id>23</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8226; wrong choice of the target-side verb form (because of unrecognized subject-predicate agreement),</text>
              <doc_id>24</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8226; missing punctuation (because of wrongly recognized finite clause boundaries),</text>
              <doc_id>25</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8226; wrong placement of clitics (because of wrongly recognized finite clause boundaries),</text>
              <doc_id>26</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8226; wrong form of pronouns (personal and possessive pronouns referring to the clause&#8217;s subject should have reflexive forms in Czech).</text>
              <doc_id>27</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Thus it is obvious that the parser choice is important and that it might not be enough to choose a parser, for machine translation, only according to its UAS.</text>
              <doc_id>28</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Due to growing popularity of dependency syntax in the last years, there are a number of dependency parsers available.</text>
              <doc_id>29</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>The present paper deals with five parsers evaluated within the translation framework: three genuine dependency parsers, namely the parsers described in (McDonald et al., 2005), (Nivre et al., 2007), and (Zhang and Nivre, 2011), and two constituency parsers (Charniak and Johnson, 2005) and (Klein and Manning, 2003), whose outputs were converted to dependency structures by Penn Converter (Johansson and Nugues, 2007).</text>
              <doc_id>30</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>As for the related literature, there is no published study measuring the influence of dependency parsers on dependency-based MT to our knowledge.</text>
              <doc_id>31</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>2 The remainder of this paper is structured as follows.</text>
              <doc_id>32</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>The overall translation pipeline, within which the parsers are tested, is described in Section 2.</text>
              <doc_id>33</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Section 3 lists the parsers under consideration and their main features.</text>
              <doc_id>34</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Section 4 summarizes the influence of the selected parsers on the MT quality in terms of BLEU.</text>
              <doc_id>35</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Section 5 concludes.</text>
              <doc_id>36</doc_id>
              <sec_id>5</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>2 However, the parser bottleneck of the dependency-based</text>
              <doc_id>37</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>MT approach was observed also by other researchers (Robert Moore, personal communication).</text>
              <doc_id>38</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>2</index>
        <title>2 Dependency-based Translation in Treex</title>
        <text>We have implemented our experiments in the Treex software framework (formerly TectoMT, introduced by &#381;abokrtsk&#253; et al. (2008)), which already offers tool chains for analysis and synthesis of Czech and English sentences.
We use the tectogrammatical (deep-syntactic) layer of language representation as the transfer layer in the presented MT experiments. Tectogrammatics was introduced by Sgall (1967) and further elaborated within the Prague Dependency Treebank project (Haji&#269; et al., 2006). On this layer, each sentence is represented as a tectogrammatical tree, whose main properties (from the MT viewpoint) are the following:
1. nodes represent autosemantic words,
2. edges represent semantic dependencies (a node is an argument or a modifier of its parent),
3. there are no functional words (prepositions, auxiliary words) in the tree, and the autosemantic words appear only in their base forms (lemmas). Morphologically indispensable categories (such as number with nouns or tense with verbs, but not number with verbs as it is only imposed by agreement) are stored in separate node attributes (grammatemes).
The intuitions behind the decision to use tectogrammatics for MT are the following: we believe that (1) tectogrammatics largely abstracts from language-specific means (inflection, agglutination, functional words etc.) of expressing non-lexical meanings and thus tectogrammatical trees are supposed to be highly similar across languages, (2) it enables a natural transfer factorization, 3 (3) and local tree contexts in tectogrammatical trees carry more information (especially for lexical choice) than local linear contexts in the original sentences.
The translation scenario is outlined in the rest of this section.
3 Morphological categories can be translated almost independently from lemmas, which makes parallel training data &#8216;denser&#8217;, especially when translating from/to a language with rich inflection such as Czech.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>We have implemented our experiments in the Treex software framework (formerly TectoMT, introduced by &#381;abokrtsk&#253; et al. (2008)), which already offers tool chains for analysis and synthesis of Czech and English sentences.</text>
              <doc_id>39</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>We use the tectogrammatical (deep-syntactic) layer of language representation as the transfer layer in the presented MT experiments.</text>
              <doc_id>40</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Tectogrammatics was introduced by Sgall (1967) and further elaborated within the Prague Dependency Treebank project (Haji&#269; et al., 2006).</text>
              <doc_id>41</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>On this layer, each sentence is represented as a tectogrammatical tree, whose main properties (from the MT viewpoint) are the following:</text>
              <doc_id>42</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>1. nodes represent autosemantic words,</text>
              <doc_id>43</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>2. edges represent semantic dependencies (a node is an argument or a modifier of its parent),</text>
              <doc_id>44</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>3. there are no functional words (prepositions, auxiliary words) in the tree, and the autosemantic words appear only in their base forms (lemmas).</text>
              <doc_id>45</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Morphologically indispensable categories (such as number with nouns or tense with verbs, but not number with verbs as it is only imposed by agreement) are stored in separate node attributes (grammatemes).</text>
              <doc_id>46</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The intuitions behind the decision to use tectogrammatics for MT are the following: we believe that (1) tectogrammatics largely abstracts from language-specific means (inflection, agglutination, functional words etc.) of expressing non-lexical meanings and thus tectogrammatical trees are supposed to be highly similar across languages, (2) it enables a natural transfer factorization, 3 (3) and local tree contexts in tectogrammatical trees carry more information (especially for lexical choice) than local linear contexts in the original sentences.</text>
              <doc_id>47</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The translation scenario is outlined in the rest of this section.</text>
              <doc_id>48</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>3 Morphological categories can be translated almost independently from lemmas, which makes parallel training data &#8216;denser&#8217;, especially when translating from/to a language with rich inflection such as Czech.</text>
              <doc_id>49</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections>
          <subsection>
            <index>0</index>
            <title>2.1 Analysis</title>
            <text>The input English text is segmented into sentences and tokens. The tokens are lemmatized and tagged with Penn Treebank tags using the Morce tagger (Spoustov&#225; et al., 2007). Then one of the studied dependency parsers is applied and a surface-syntax dependency tree (analytical tree in the PDT terminology) is created for each sentence.
This tree is converted to a tectogrammatical tree. Each autosemantic word with its associated functional words is collapsed into a single tectogrammatical node, labeled with a lemma, formeme, 4 and semantically indispensable morphologically categories; coreference is also resolved.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>The input English text is segmented into sentences and tokens.</text>
                  <doc_id>50</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>The tokens are lemmatized and tagged with Penn Treebank tags using the Morce tagger (Spoustov&#225; et al., 2007).</text>
                  <doc_id>51</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>Then one of the studied dependency parsers is applied and a surface-syntax dependency tree (analytical tree in the PDT terminology) is created for each sentence.</text>
                  <doc_id>52</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>This tree is converted to a tectogrammatical tree.</text>
                  <doc_id>53</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Each autosemantic word with its associated functional words is collapsed into a single tectogrammatical node, labeled with a lemma, formeme, 4 and semantically indispensable morphologically categories; coreference is also resolved.</text>
                  <doc_id>54</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>1</index>
            <title>2.2 Transfer</title>
            <text>The transfer phase follows, whose most difficult part consists especially in labeling the tree with targetside lemmas and formemes. There are also other types of changes, such as node addition and deletion. However, as shown by Popel (2009), changes of tree topology are required relatively infrequently due to the language abstractions on the tectogrammatical layer.
Currently, translation models based on Maximum Entropy classifiers are used both for lemmas and formemes (Mare&#269;ek et al., 2010). Tree labeling is optimized using Hidden Tree Markov Models (&#381;abokrtsk&#253; and Popel, 2009), which makes use of target-language dependency tree probabilistic model.
All models used in the transfer phase are trained using training sections of the Czech-English parallel corpus CzEng 0.9 (Bojar and &#381;abokrtsk&#253;, 2009).</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>The transfer phase follows, whose most difficult part consists especially in labeling the tree with targetside lemmas and formemes.</text>
                  <doc_id>55</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>There are also other types of changes, such as node addition and deletion.</text>
                  <doc_id>56</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>However, as shown by Popel (2009), changes of tree topology are required relatively infrequently due to the language abstractions on the tectogrammatical layer.</text>
                  <doc_id>57</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Currently, translation models based on Maximum Entropy classifiers are used both for lemmas and formemes (Mare&#269;ek et al., 2010).</text>
                  <doc_id>58</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Tree labeling is optimized using Hidden Tree Markov Models (&#381;abokrtsk&#253; and Popel, 2009), which makes use of target-language dependency tree probabilistic model.</text>
                  <doc_id>59</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>All models used in the transfer phase are trained using training sections of the Czech-English parallel corpus CzEng 0.9 (Bojar and &#381;abokrtsk&#253;, 2009).</text>
                  <doc_id>60</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>2</index>
            <title>2.3 Synthesis</title>
            <text>Finally, surface sentence shape is synthesized from the tectogrammatical tree, which is basically the reverse operation of the tectogrammatical analysis. It consists of adding punctuation and functional
4 Formeme captures the morphosyntactic means which are
used for expressing the tectogrammatical node in the surface sentence shape. Examples of formeme values: v:that+fin &#8211; finite verb in a subordinated clause introduced with conjunction that, n:sb &#8211; semantic noun in a subject position, n:for+X &#8211; semantic noun in a prepositional group introduced with preposition for, adj:attr &#8211; semantic adjective in an attributive position.
words, spreading morphological categories according to grammatical agreement, performing inflection (using Czech morphology database (Haji&#269;, 2004)), arranging word order etc. The difference from the analysis phase is that there is not very much space for optimization in the synthesis phase. In other words, final sentence shape is determined almost uniquely by the tectogrammatical tree (enriched with formemes) resulting from the transfer phase. However, if there are not enough constraints for a unique choice of a surface form of a lemma, then a unigram language model is used for the final decision. The model was trained using 500 million words from the Czech National Corpus. 5</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>Finally, surface sentence shape is synthesized from the tectogrammatical tree, which is basically the reverse operation of the tectogrammatical analysis.</text>
                  <doc_id>61</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>It consists of adding punctuation and functional</text>
                  <doc_id>62</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>4 Formeme captures the morphosyntactic means which are</text>
                  <doc_id>63</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>used for expressing the tectogrammatical node in the surface sentence shape.</text>
                  <doc_id>64</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Examples of formeme values: v:that+fin &#8211; finite verb in a subordinated clause introduced with conjunction that, n:sb &#8211; semantic noun in a subject position, n:for+X &#8211; semantic noun in a prepositional group introduced with preposition for, adj:attr &#8211; semantic adjective in an attributive position.</text>
                  <doc_id>65</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>words, spreading morphological categories according to grammatical agreement, performing inflection (using Czech morphology database (Haji&#269;, 2004)), arranging word order etc.</text>
                  <doc_id>66</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>The difference from the analysis phase is that there is not very much space for optimization in the synthesis phase.</text>
                  <doc_id>67</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>In other words, final sentence shape is determined almost uniquely by the tectogrammatical tree (enriched with formemes) resulting from the transfer phase.</text>
                  <doc_id>68</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>However, if there are not enough constraints for a unique choice of a surface form of a lemma, then a unigram language model is used for the final decision.</text>
                  <doc_id>69</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
                <sentence>
                  <text>The model was trained using 500 million words from the Czech National Corpus.</text>
                  <doc_id>70</doc_id>
                  <sec_id>4</sec_id>
                </sentence>
                <sentence>
                  <text>5</text>
                  <doc_id>71</doc_id>
                  <sec_id>5</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
        </subsections>
      </section>
      <section>
        <index>3</index>
        <title>3 Involved Parsers</title>
        <text>We performed experiments with parsers from three families: graph-based parsers, transitionbased parsers, and phrase-structure parsers (with constituency-to-dependency postprocessing).</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>We performed experiments with parsers from three families: graph-based parsers, transitionbased parsers, and phrase-structure parsers (with constituency-to-dependency postprocessing).</text>
              <doc_id>72</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections>
          <subsection>
            <index>0</index>
            <title>3.1 Graph-based Parser</title>
            <text>In graph-based parsing, we learn a model for scoring graph edges, and we search for the highest-scoring tree composed of the graph&#8217;s edges. We used Maximum Spanning Tree parser (Mcdonald and Pereira, 2006) which is capable of incorporating second order features (MST for short).</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>In graph-based parsing, we learn a model for scoring graph edges, and we search for the highest-scoring tree composed of the graph&#8217;s edges.</text>
                  <doc_id>73</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>We used Maximum Spanning Tree parser (Mcdonald and Pereira, 2006) which is capable of incorporating second order features (MST for short).</text>
                  <doc_id>74</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>1</index>
            <title>3.2 Transition-based Parsers</title>
            <text>Transition-based parsers utilize the shift-reduce algorithm. Input words are put into a queue and consumed by shift-reduce actions, while the output parser is gradually built. Unlike graph-based parsers, transition-based parsers have linear time complexity and allow straightforward application of non-local features.
We included two transition-based parsers into our experiments:
&#8226; Malt &#8211; Malt parser introduced by Nivre et al. (2007) 6
5 http://ucnk.ff.cuni.cz 6 We used stackeager algorithm, liblinear learner, and
the enriched feature set for English (the same configuration as in pretrained English models downloadable at http://maltparser.org.
&#8226; ZPar &#8211; Zpar parser 7 which is basically an alternative implementation of the Malt parser, employing a richer set of non-local features as described by Zhang and Nivre (2011).</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>Transition-based parsers utilize the shift-reduce algorithm.</text>
                  <doc_id>75</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Input words are put into a queue and consumed by shift-reduce actions, while the output parser is gradually built.</text>
                  <doc_id>76</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>Unlike graph-based parsers, transition-based parsers have linear time complexity and allow straightforward application of non-local features.</text>
                  <doc_id>77</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>We included two transition-based parsers into our experiments:</text>
                  <doc_id>78</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8226; Malt &#8211; Malt parser introduced by Nivre et al. (2007) 6</text>
                  <doc_id>79</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>5 http://ucnk.ff.cuni.cz 6 We used stackeager algorithm, liblinear learner, and</text>
                  <doc_id>80</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>the enriched feature set for English (the same configuration as in pretrained English models downloadable at http://maltparser.org.</text>
                  <doc_id>81</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8226; ZPar &#8211; Zpar parser 7 which is basically an alternative implementation of the Malt parser, employing a richer set of non-local features as described by Zhang and Nivre (2011).</text>
                  <doc_id>82</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>2</index>
            <title>3.3 CFG-based Tree Parsers</title>
            <text>Another option how to obtain dependency trees is to apply a constituency parser, recognize heads in the resulting phrase structures and apply a recursive algorithm for converting phrase-structure trees into constituency trees (the convertibility of the two types of syntactic structures was studied already by Gaifman (1965)).
We used two constituency parsers:
&#8226; Stanford &#8211; The Stanford parser (Klein and Manning, 2003), 8
&#8226; CJ &#8211; a MaxEnt-based parser combined with discriminative reranking (Charniak and Johnson, 2005). 9
Before applying the parsers on the text, the system removes all spaces within tokens. For instance U. S. becomes U.S. to restrict the parsers from creating two new tokens. Tokenization built into both parsers is bypassed and the default tokenization in Treex is used. After parsing, Penn Converter introduced by Johansson and Nugues (2007) is applied, with the -conll2007 option, to change the constituent structure output, of the two parsers, into CoNLL dependency structure. This allows us to keep the formats consistent with the output of both MST and MaltParser within the Treex framework.
There is an implemented procedure for creating tectogrammatical trees from the English phrase structure trees described by Ku&#269;erov&#225; and &#381;abokrtsk&#253; (2002). Using the procedure is more straightforward, as it does not go through the CoNLL-style trees; English CoNLL-style trees differ slightly from the PDT conventions (e.g. in attaching auxiliary verbs) and thus needs additional
7 http://sourceforge.net/projects/zpar/ (version 0.4) 8 Only the constituent, phrase based, parsed output is used in
these experiments. 9 We are using the default settings from the August 2006 version of the software.
postprocessing for our purposes. However, we decided to stick to Penn Converter, so that the similarity of the translation scenarios is maximized for all parsers.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>Another option how to obtain dependency trees is to apply a constituency parser, recognize heads in the resulting phrase structures and apply a recursive algorithm for converting phrase-structure trees into constituency trees (the convertibility of the two types of syntactic structures was studied already by Gaifman (1965)).</text>
                  <doc_id>83</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>We used two constituency parsers:</text>
                  <doc_id>84</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8226; Stanford &#8211; The Stanford parser (Klein and Manning, 2003), 8</text>
                  <doc_id>85</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8226; CJ &#8211; a MaxEnt-based parser combined with discriminative reranking (Charniak and Johnson, 2005).</text>
                  <doc_id>86</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>9</text>
                  <doc_id>87</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Before applying the parsers on the text, the system removes all spaces within tokens.</text>
                  <doc_id>88</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>For instance U.</text>
                  <doc_id>89</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>S. becomes U.S. to restrict the parsers from creating two new tokens.</text>
                  <doc_id>90</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>Tokenization built into both parsers is bypassed and the default tokenization in Treex is used.</text>
                  <doc_id>91</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
                <sentence>
                  <text>After parsing, Penn Converter introduced by Johansson and Nugues (2007) is applied, with the -conll2007 option, to change the constituent structure output, of the two parsers, into CoNLL dependency structure.</text>
                  <doc_id>92</doc_id>
                  <sec_id>4</sec_id>
                </sentence>
                <sentence>
                  <text>This allows us to keep the formats consistent with the output of both MST and MaltParser within the Treex framework.</text>
                  <doc_id>93</doc_id>
                  <sec_id>5</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>There is an implemented procedure for creating tectogrammatical trees from the English phrase structure trees described by Ku&#269;erov&#225; and &#381;abokrtsk&#253; (2002).</text>
                  <doc_id>94</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Using the procedure is more straightforward, as it does not go through the CoNLL-style trees; English CoNLL-style trees differ slightly from the PDT conventions (e.g. in attaching auxiliary verbs) and thus needs additional</text>
                  <doc_id>95</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>7 http://sourceforge.net/projects/zpar/ (version 0.4) 8 Only the constituent, phrase based, parsed output is used in</text>
                  <doc_id>96</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>these experiments.</text>
                  <doc_id>97</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>9 We are using the default settings from the August 2006 version of the software.</text>
                  <doc_id>98</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>postprocessing for our purposes.</text>
                  <doc_id>99</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>However, we decided to stick to Penn Converter, so that the similarity of the translation scenarios is maximized for all parsers.</text>
                  <doc_id>100</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>3</index>
            <title>3.4 Common Preprocessing: Shallow Sentence Chunking</title>
            <text>According to our experience, many dependency parsers have troubles with analyzing sentences that contain parenthesed or quoted phrases, especially if they are long.
We use the assumption that in most cases the content of parentheses or quotes should correspond to a connected subgraph (subtree) of the syntactic tree. We implemented a very shallow sentence chunker (SentChunk) which recognizes parenthesed word sequences. These sequences can be passed to a parser first, and be parsed independently of the rest of the sentence. This was shown to improve not only parsing accuracy of the parenthesed word sequence (which is forced to remain in one subtree), but also the rest of the sentence. 10 In our experiments, SentChunk is used only in combination with the three genuine dependency parsers.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>According to our experience, many dependency parsers have troubles with analyzing sentences that contain parenthesed or quoted phrases, especially if they are long.</text>
                  <doc_id>101</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>We use the assumption that in most cases the content of parentheses or quotes should correspond to a connected subgraph (subtree) of the syntactic tree.</text>
                  <doc_id>102</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>We implemented a very shallow sentence chunker (SentChunk) which recognizes parenthesed word sequences.</text>
                  <doc_id>103</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>These sequences can be passed to a parser first, and be parsed independently of the rest of the sentence.</text>
                  <doc_id>104</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>This was shown to improve not only parsing accuracy of the parenthesed word sequence (which is forced to remain in one subtree), but also the rest of the sentence.</text>
                  <doc_id>105</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
                <sentence>
                  <text>10 In our experiments, SentChunk is used only in combination with the three genuine dependency parsers.</text>
                  <doc_id>106</doc_id>
                  <sec_id>4</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
        </subsections>
      </section>
      <section>
        <index>4</index>
        <title>4 Experiments and Evaluation</title>
        <text></text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text></text>
              <doc_id>107</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections>
          <subsection>
            <index>0</index>
            <title>4.1 Data for Parsers&#8217; Training and Evaluation</title>
            <text>The dependency trees needed for training the parsers and evaluating their UAS were created from the Penn Treebank data (enriched first with internal noun phrase structure applied via scripts provided by Vadas and Curran (2007)) by Penn Converter (Johansson and Nugues, 2007) with the -conll2007 option (PennConv for short).
All the parsers were evaluated on the same data &#8211; section 23. All the parsers were trained on sections 02&#8211;21, except for the Stanford parser which was trained on sections 01&#8211;21. We were able to retrain the parser models only for MST and Malt. For the other parsers we used pretrained models available on the Internet: CJ&#8217;s default model ec50spfinal, Stanford&#8217;s wsjPCFG.ser.gz model, and
10 Edge length is a common feature in dependency parsers, so
&#8220;deleting&#8221; parenthesed words may give higher scores to correct dependency links that happened to span over the parentheses.
ZPar&#8217;s english.tar.gz. The model of ZPar is trained on data converted to dependencies using Penn2Malt tool, 11 which selects the last member of a coordination as the head. To be able to compare ZPar&#8217;s output with the other parsers, we postprocessed it by a simple ConjAsHead code that converts this style of coordinations to the one used in CoNLL2007, where the conjuction is the head.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>The dependency trees needed for training the parsers and evaluating their UAS were created from the Penn Treebank data (enriched first with internal noun phrase structure applied via scripts provided by Vadas and Curran (2007)) by Penn Converter (Johansson and Nugues, 2007) with the -conll2007 option (PennConv for short).</text>
                  <doc_id>108</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>All the parsers were evaluated on the same data &#8211; section 23.</text>
                  <doc_id>109</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>All the parsers were trained on sections 02&#8211;21, except for the Stanford parser which was trained on sections 01&#8211;21.</text>
                  <doc_id>110</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>We were able to retrain the parser models only for MST and Malt.</text>
                  <doc_id>111</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>For the other parsers we used pretrained models available on the Internet: CJ&#8217;s default model ec50spfinal, Stanford&#8217;s wsjPCFG.ser.gz model, and</text>
                  <doc_id>112</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>10 Edge length is a common feature in dependency parsers, so</text>
                  <doc_id>113</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8220;deleting&#8221; parenthesed words may give higher scores to correct dependency links that happened to span over the parentheses.</text>
                  <doc_id>114</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>ZPar&#8217;s english.tar.gz.</text>
                  <doc_id>115</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>The model of ZPar is trained on data converted to dependencies using Penn2Malt tool, 11 which selects the last member of a coordination as the head.</text>
                  <doc_id>116</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>To be able to compare ZPar&#8217;s output with the other parsers, we postprocessed it by a simple ConjAsHead code that converts this style of coordinations to the one used in CoNLL2007, where the conjuction is the head.</text>
                  <doc_id>117</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>1</index>
            <title>4.2 Reference Translations Used for Evaluation</title>
            <text>Translation experiments were evaluated using reference translations from the new-dev2009 data set, provided by the organizors of shared translation task with the Workshop on Statistical Machine Translation.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>Translation experiments were evaluated using reference translations from the new-dev2009 data set, provided by the organizors of shared translation task with the Workshop on Statistical Machine Translation.</text>
                  <doc_id>118</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>2</index>
            <title>4.3 Influence of Parser Training Data Size</title>
            <text>We trained a sequence of parser models for MST and Malt, using a roughly exponentially growing sequence of Penn Treebank subsets. The subsets are contiguous and start from the beginning of section 02. The results are collected in Tables 1 and 2. 12
#tokens UAS BLEU NIST
The trend of the relation between the training data size and BLEU is visible also in Figure 1. It is obvious that increasing the training data has a positive effect on the translation quality. However, the pace of growth of BLEU is sublogarithmic, and becomes unconvincing above 100,000 training tokens. It indicates that given one of the two parsers integrated
11 http://w3.msi.vxu.se/&#732;nivre/research/
Penn2Malt.html 12 To our knowledge, the best system participating in the
shared task reaches BLEU 17.8 for this translation direction.
#tokens UAS BLEU NIST
BLEU
0.13
0.12
0.11
0.1
0.09
0.08
0.07
0.06
MST Malt
into our translation framework, increasing the parser training data alone would probably not lead to a substantial improvement of the translation performance.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>We trained a sequence of parser models for MST and Malt, using a roughly exponentially growing sequence of Penn Treebank subsets.</text>
                  <doc_id>119</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>The subsets are contiguous and start from the beginning of section 02.</text>
                  <doc_id>120</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>The results are collected in Tables 1 and 2.</text>
                  <doc_id>121</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>12</text>
                  <doc_id>122</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>#tokens UAS BLEU NIST</text>
                  <doc_id>123</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>The trend of the relation between the training data size and BLEU is visible also in Figure 1.</text>
                  <doc_id>124</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>It is obvious that increasing the training data has a positive effect on the translation quality.</text>
                  <doc_id>125</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>However, the pace of growth of BLEU is sublogarithmic, and becomes unconvincing above 100,000 training tokens.</text>
                  <doc_id>126</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>It indicates that given one of the two parsers integrated</text>
                  <doc_id>127</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>11 http://w3.msi.vxu.se/&#732;nivre/research/</text>
                  <doc_id>128</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Penn2Malt.html 12 To our knowledge, the best system participating in the</text>
                  <doc_id>129</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>shared task reaches BLEU 17.8 for this translation direction.</text>
                  <doc_id>130</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>#tokens UAS BLEU NIST</text>
                  <doc_id>131</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>BLEU</text>
                  <doc_id>132</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.13</text>
                  <doc_id>133</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.12</text>
                  <doc_id>134</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.11</text>
                  <doc_id>135</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.1</text>
                  <doc_id>136</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.09</text>
                  <doc_id>137</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.08</text>
                  <doc_id>138</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.07</text>
                  <doc_id>139</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.06</text>
                  <doc_id>140</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>MST Malt</text>
                  <doc_id>141</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>into our translation framework, increasing the parser training data alone would probably not lead to a substantial improvement of the translation performance.</text>
                  <doc_id>142</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>3</index>
            <title>4.4 Influence of Parser Choice</title>
            <text>Table 3 summarizes our experiments with the five parsers integrated into the tectogrammatical translation pipeline. Two configurations (with and without SentChunk) are listed for the genuine dependency parsers. The relationship between UAS and BLEU for (the best configurations of) all five parsers is depicted also in Figure 2.
Additionally, we used paired bootstrap 95% confidence interval testing (Zhang et al., 2004), to check which BLEU differences are significant. For the five compared parser (with SentChunk if applicable), only four comparisons are not significant: MST-CJ, MST-Stanford, Malt-Stanford, and CJ-Stanford.
Parser Training data Preprocessing Postprocessing UAS BLEU NIST TER
BLEU
0.15
0.145
0.14
0.135
0.13
0.125
0.12
0.115
0.11
0.105
0.1 0.74 0.76 0.78 0.8 0.82 0.84 0.86 0.88 0.9 0.92 UAS
MST Malt Zpar Stanford CJ
Even if BLEU grows relatively smoothly with UAS for different parsing models of the same parser, one can see that there is no obvious relation between UAS and BLEU accross all parsers. MST and Zpar have the same UAS but quite different BLEU, whereas MST and CJ have very similar BLEU but distant UAS. It confirms the original hypothesis that it is not only the overall UAS, but also the parserspecific distribution of errors what matters.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>Table 3 summarizes our experiments with the five parsers integrated into the tectogrammatical translation pipeline.</text>
                  <doc_id>143</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Two configurations (with and without SentChunk) are listed for the genuine dependency parsers.</text>
                  <doc_id>144</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>The relationship between UAS and BLEU for (the best configurations of) all five parsers is depicted also in Figure 2.</text>
                  <doc_id>145</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Additionally, we used paired bootstrap 95% confidence interval testing (Zhang et al., 2004), to check which BLEU differences are significant.</text>
                  <doc_id>146</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>For the five compared parser (with SentChunk if applicable), only four comparisons are not significant: MST-CJ, MST-Stanford, Malt-Stanford, and CJ-Stanford.</text>
                  <doc_id>147</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Parser Training data Preprocessing Postprocessing UAS BLEU NIST TER</text>
                  <doc_id>148</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>BLEU</text>
                  <doc_id>149</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.15</text>
                  <doc_id>150</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.145</text>
                  <doc_id>151</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.14</text>
                  <doc_id>152</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.135</text>
                  <doc_id>153</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.13</text>
                  <doc_id>154</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.125</text>
                  <doc_id>155</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.12</text>
                  <doc_id>156</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.115</text>
                  <doc_id>157</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.11</text>
                  <doc_id>158</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.105</text>
                  <doc_id>159</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>0.1 0.74 0.76 0.78 0.8 0.82 0.84 0.86 0.88 0.9 0.92 UAS</text>
                  <doc_id>160</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>MST Malt Zpar Stanford CJ</text>
                  <doc_id>161</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Even if BLEU grows relatively smoothly with UAS for different parsing models of the same parser, one can see that there is no obvious relation between UAS and BLEU accross all parsers.</text>
                  <doc_id>162</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>MST and Zpar have the same UAS but quite different BLEU, whereas MST and CJ have very similar BLEU but distant UAS.</text>
                  <doc_id>163</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>It confirms the original hypothesis that it is not only the overall UAS, but also the parserspecific distribution of errors what matters.</text>
                  <doc_id>164</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>4</index>
            <title>4.5 Influence of Shallow Sentence Chunking</title>
            <text>Table 3 confirms that parsing the contents parentheses separately from the rest of the sentence (SentChunk) has a positive effect with all three dependency parsers. Surprisingly, even if the effect on UAS is negligible, the improvement is almost half of BLEU point which is significant for all the three parsers.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>Table 3 confirms that parsing the contents parentheses separately from the rest of the sentence (SentChunk) has a positive effect with all three dependency parsers.</text>
                  <doc_id>165</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Surprisingly, even if the effect on UAS is negligible, the improvement is almost half of BLEU point which is significant for all the three parsers.</text>
                  <doc_id>166</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>5</index>
            <title>4.6 Discussion on Result Comparability</title>
            <text>We tried to isolate the effects of the properties of selected parsers, however, the separation from other influencing factors is not perfect due to several technical issues:
&#8226; So far, we were not able to retrain the models for all parsers ourselves and therefore their pretrained models (one of them based on slightly different Penn Treebank division) must have been used.
&#8226; Some parsers make their own choice of POS tags within the parsed sentences, while other parsers require the sentences to be tagged already on their input.
&#8226; The trees in the CzEng 0.9 parallel treebank were created using MST. CzEng 0.9 was used for training translation models used in the transfer phase of the translation scenario; thus these translation models might compensate for some MST&#8217;s errors, which might handicap other parsers. So far we were not able to reparse 8 million sentence pairs in CzEng 0.9 by all studied parsers.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>We tried to isolate the effects of the properties of selected parsers, however, the separation from other influencing factors is not perfect due to several technical issues:</text>
                  <doc_id>167</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8226; So far, we were not able to retrain the models for all parsers ourselves and therefore their pretrained models (one of them based on slightly different Penn Treebank division) must have been used.</text>
                  <doc_id>168</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8226; Some parsers make their own choice of POS tags within the parsed sentences, while other parsers require the sentences to be tagged already on their input.</text>
                  <doc_id>169</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8226; The trees in the CzEng 0.9 parallel treebank were created using MST.</text>
                  <doc_id>170</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>CzEng 0.9 was used for training translation models used in the transfer phase of the translation scenario; thus these translation models might compensate for some MST&#8217;s errors, which might handicap other parsers.</text>
                  <doc_id>171</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>So far we were not able to reparse 8 million sentence pairs in CzEng 0.9 by all studied parsers.</text>
                  <doc_id>172</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
        </subsections>
      </section>
      <section>
        <index>5</index>
        <title>5 Conclusions</title>
        <text>This paper is a study of how the choice of a dependency parsing technique influences the quality of English-Czech dependency-based translation. Our main observations are the following. First, BLEU grows with the increasing amount of training dependency trees, but only in a sublogarithmic pace. Second, what seems to be quite effective for translation 438 is to facilitate the parsers&#8217; task by dividing the sentences into smaller chunks using parenthesis boundaries. Third, if the parsers are based on different approaches, their UAS does not correlate well with their effect on the translation quality.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>This paper is a study of how the choice of a dependency parsing technique influences the quality of English-Czech dependency-based translation.</text>
              <doc_id>173</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Our main observations are the following.</text>
              <doc_id>174</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>First, BLEU grows with the increasing amount of training dependency trees, but only in a sublogarithmic pace.</text>
              <doc_id>175</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Second, what seems to be quite effective for translation 438 is to facilitate the parsers&#8217; task by dividing the sentences into smaller chunks using parenthesis boundaries.</text>
              <doc_id>176</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Third, if the parsers are based on different approaches, their UAS does not correlate well with their effect on the translation quality.</text>
              <doc_id>177</doc_id>
              <sec_id>4</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>6</index>
        <title>Acknowledgments</title>
        <text></text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text></text>
              <doc_id>178</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
    </sections>
    <tables>
      <table>
        <id>1</id>
        <source>TableSeer</source>
        <caption>Table 1: The effect of training data size on parsing accuracy and on translation performance with MST.</caption>
        <reference_text>None</reference_text>
        <page_num>5</page_num>
        <head>
          <rows>
            <row>
              <cell>#tokens</cell>
              <cell>UAS</cell>
              <cell>BLEU</cell>
              <cell>NIST</cell>
            </row>
          </rows>
        </head>
        <body>
          <rows>
            <row>
              <cell>100</cell>
              <cell>0.362</cell>
              <cell>0.0579</cell>
              <cell>3.6375</cell>
            </row>
            <row>
              <cell>300</cell>
              <cell>0.509</cell>
              <cell>0.0859</cell>
              <cell>4.3853</cell>
            </row>
            <row>
              <cell>1000</cell>
              <cell>0.591</cell>
              <cell>0.0995</cell>
              <cell>4.6548</cell>
            </row>
            <row>
              <cell>3000</cell>
              <cell>0.623</cell>
              <cell>0.1054</cell>
              <cell>4.7972</cell>
            </row>
            <row>
              <cell>10000</cell>
              <cell>0.680</cell>
              <cell>0.1130</cell>
              <cell>4.9695</cell>
            </row>
            <row>
              <cell>30000</cell>
              <cell>0.719</cell>
              <cell>0.1215</cell>
              <cell>5.0705</cell>
            </row>
            <row>
              <cell>100000</cell>
              <cell>0.749</cell>
              <cell>0.1232</cell>
              <cell>5.1193</cell>
            </row>
            <row>
              <cell>300000</cell>
              <cell>0.776</cell>
              <cell>0.1257</cell>
              <cell>5.1571</cell>
            </row>
            <row>
              <cell>990180</cell>
              <cell>0.793</cell>
              <cell>0.1280</cell>
              <cell>5.1915</cell>
            </row>
          </rows>
        </body>
      </table>
      <table>
        <id>2</id>
        <source>TableSeer</source>
        <caption>Table 2: The effect of training data size on parsing accuracy and on translation performance with Malt.</caption>
        <reference_text>None</reference_text>
        <page_num>5</page_num>
        <head>
          <rows>
            <row>
              <cell>100</cell>
              <cell>0.454</cell>
              <cell>0.0763</cell>
              <cell>4.0555</cell>
            </row>
          </rows>
        </head>
        <body>
          <rows>
            <row>
              <cell>300</cell>
              <cell>0.518</cell>
              <cell>0.0932</cell>
              <cell>4.4698</cell>
            </row>
            <row>
              <cell>1000</cell>
              <cell>0.591</cell>
              <cell>0.1042</cell>
              <cell>4.6769</cell>
            </row>
            <row>
              <cell>3000</cell>
              <cell>0.616</cell>
              <cell>0.1068</cell>
              <cell>4.7472</cell>
            </row>
            <row>
              <cell>10000</cell>
              <cell>0.665</cell>
              <cell>0.1140</cell>
              <cell>4.9100</cell>
            </row>
            <row>
              <cell>30000</cell>
              <cell>0.695</cell>
              <cell>0.1176</cell>
              <cell>4.9744</cell>
            </row>
            <row>
              <cell>100000</cell>
              <cell>0.723</cell>
              <cell>0.1226</cell>
              <cell>5.0504</cell>
            </row>
            <row>
              <cell>300000</cell>
              <cell>0.740</cell>
              <cell>0.1238</cell>
              <cell>5.1005</cell>
            </row>
            <row>
              <cell>990180</cell>
              <cell>0.759</cell>
              <cell>0.1253</cell>
              <cell>5.1296</cell>
            </row>
          </rows>
        </body>
      </table>
      <table>
        <id>3</id>
        <source>TableSeer</source>
        <caption>Table 3: Dependency parsers tested in the translation pipeline.</caption>
        <reference_text>In PAGE 5: ... 4.4 Influence of Parser Choice  Table3  summarizes our experiments with the five parsers integrated into the tectogrammatical transla- tion pipeline. Two configurations (with and without SentChunk) are listed for the genuine dependency parsers....  In PAGE 6: ... 4.5 Influence of Shallow Sentence Chunking  Table3  confirms that parsing the contents paren- theses separately from the rest of the sentence (SentChunk) has a positive effect with all three dependency parsers. Surprisingly, even if the effect on UAS is negligible, the improvement is almost half of BLEU point which is significant for all the three parsers....</reference_text>
        <page_num>6</page_num>
        <head>
          <rows>
            <row>
              <cell>Parser</cell>
              <cell>Training data</cell>
              <cell>Preprocessing</cell>
              <cell>Postprocessing</cell>
              <cell>UAS</cell>
              <cell>BLEU</cell>
              <cell>NIST</cell>
              <cell>TER</cell>
            </row>
          </rows>
        </head>
        <body>
          <rows>
            <row>
              <cell>MST</cell>
              <cell>PennTB + PennConv</cell>
              <cell>SentChunk</cell>
              <cell>?</cell>
              <cell>0.793</cell>
              <cell>0.1280</cell>
              <cell>5.192</cell>
              <cell>0.735</cell>
            </row>
            <row>
              <cell>MST</cell>
              <cell>PennTB + PennConv</cell>
              <cell>?</cell>
              <cell>?</cell>
              <cell>0.794</cell>
              <cell>0.1236</cell>
              <cell>5.149</cell>
              <cell>0.739</cell>
            </row>
            <row>
              <cell>Malt</cell>
              <cell>PennTB + PennConv</cell>
              <cell>SentChunk</cell>
              <cell>?</cell>
              <cell>0.760</cell>
              <cell>0.1253</cell>
              <cell>5.130</cell>
              <cell>0.740</cell>
            </row>
            <row>
              <cell>Malt</cell>
              <cell>PennTB + PennConv</cell>
              <cell>?</cell>
              <cell>?</cell>
              <cell>0.761</cell>
              <cell>0.1214</cell>
              <cell>5.088</cell>
              <cell>0.744</cell>
            </row>
            <row>
              <cell>Zpar</cell>
              <cell>PennTB + Penn2Malt</cell>
              <cell>SentChunk</cell>
              <cell>ConjAsHead</cell>
              <cell>0.793</cell>
              <cell>0.1176</cell>
              <cell>5.039</cell>
              <cell>0.749</cell>
            </row>
            <row>
              <cell>Zpar</cell>
              <cell>PennTB + Penn2Malt</cell>
              <cell>?</cell>
              <cell>ConjAsHead</cell>
              <cell>0.792</cell>
              <cell>0.1127</cell>
              <cell>4.984</cell>
              <cell>0.754</cell>
            </row>
            <row>
              <cell>CJ</cell>
              <cell>PennTB</cell>
              <cell>?</cell>
              <cell>PennConv</cell>
              <cell>0.904</cell>
              <cell>0.1284</cell>
              <cell>5.189</cell>
              <cell>0.737</cell>
            </row>
            <row>
              <cell>Stanford</cell>
              <cell>PennTB</cell>
              <cell>?</cell>
              <cell>PennConv</cell>
              <cell>0.825</cell>
              <cell>0.1277</cell>
              <cell>5.137</cell>
              <cell>0.740</cell>
            </row>
          </rows>
        </body>
      </table>
    </tables>
    <references>
      <reference>
        <id>0</id>
        <authors>
          <author>Ond&#345;ej Bojar</author>
          <author>Zden&#283;k &#381;abokrtsk&#253;</author>
        </authors>
        <title>CzEng 0.9, Building a Large Czech-English Automatic Parallel Treebank.</title>
        <publication>The Prague Bulletin of Mathematical Linguistics,</publication>
        <pages>92--63</pages>
        <date>2009</date>
      </reference>
      <reference>
        <id>1</id>
        <authors>
          <author>Eugene Charniak</author>
          <author>Mark Johnson</author>
        </authors>
        <title>Coarse-tofine n-best parsing and maxent discriminative reranking.</title>
        <publication>In Proceedings of the 43rd Annual Meeting of Association for Computational Linguistics, ACL &#8217;05,</publication>
        <pages>173--180</pages>
        <date>2005</date>
      </reference>
      <reference>
        <id>2</id>
        <authors>
          <author>Haim Gaifman</author>
        </authors>
        <title>Dependency systems and phrasestructure systems.</title>
        <publication>None</publication>
        <pages>304--337</pages>
        <date>1965</date>
      </reference>
      <reference>
        <id>3</id>
        <authors>
          <author>Jan Haji&#269;</author>
        </authors>
        <title>None</title>
        <publication>Prague Dependency Treebank 2.0. CD-ROM, Linguistic Data Consortium, LDC Catalog No.: LDC2006T01,</publication>
        <pages>None</pages>
        <date>2006</date>
      </reference>
      <reference>
        <id>4</id>
        <authors>
          <author>Jan Haji&#269;</author>
        </authors>
        <title>None</title>
        <publication>Disambiguation of Rich Inflection &#8211; Computational Morphology of Czech.</publication>
        <pages>None</pages>
        <date>2004</date>
      </reference>
      <reference>
        <id>5</id>
        <authors>
          <author>Richard Johansson</author>
          <author>Pierre Nugues</author>
        </authors>
        <title>Extended constituent-to-dependency conversion for English.</title>
        <publication>In Proceedings of NODALIDA</publication>
        <pages>105--112</pages>
        <date>2007</date>
      </reference>
      <reference>
        <id>6</id>
        <authors>
          <author>Dan Klein</author>
          <author>Christopher D Manning</author>
        </authors>
        <title>Accurate unlexicalized parsing.</title>
        <publication>In Proceedings of the 41st Annual Meeting of Association for Computational Linguistics,</publication>
        <pages>423--430</pages>
        <date>2003</date>
      </reference>
      <reference>
        <id>7</id>
        <authors>
          <author>Ivona Ku&#269;erov&#225;</author>
          <author>Zden&#283;k &#381;abokrtsk&#253;</author>
        </authors>
        <title>Transforming Penn Treebank Phrase Trees into (Praguian) Tectogrammatical Dependency Trees. The Prague Bulletin of Mathematical Linguistics,</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>2002</date>
      </reference>
      <reference>
        <id>8</id>
        <authors>
          <author>David Mare&#269;ek</author>
          <author>Martin Popel</author>
          <author>Zden&#283;k &#381;abokrtsk&#253;</author>
        </authors>
        <title>Maximum entropy translation model in dependency-based MT framework.</title>
        <publication>In Proceedings of the Joint Fifth Workshop on Statistical Machine Translation and MetricsMATR,</publication>
        <pages>201--201</pages>
        <date>2010</date>
      </reference>
      <reference>
        <id>9</id>
        <authors>
          <author>Ryan Mcdonald</author>
          <author>Fernando Pereira</author>
        </authors>
        <title>Online learning of approximate dependency parsing algorithms.</title>
        <publication>In Proceedings of EACL,</publication>
        <pages>81--88</pages>
        <date>2006</date>
      </reference>
      <reference>
        <id>10</id>
        <authors>
          <author>Ryan McDonald</author>
          <author>Fernando Pereira</author>
          <author>Kiril Ribarov</author>
          <author>Jan Haji&#269;</author>
        </authors>
        <title>Non-projective dependency parsing using spanning tree algorithms.</title>
        <publication>In Proceedings of HLT / EMNLP,</publication>
        <pages>523--530</pages>
        <date>2005</date>
      </reference>
      <reference>
        <id>11</id>
        <authors>
          <author>Joakim Nivre</author>
          <author>Johan Hall</author>
          <author>Jens Nilsson</author>
        </authors>
        <title>Atanas Chanev, Gulsen Eryigit, Sandra K&#252;bler, Svetoslav Marinov, and Erwin Marsi.</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>2007</date>
      </reference>
      <reference>
        <id>12</id>
        <authors>
          <author>Martin Popel</author>
        </authors>
        <title>Ways to Improve the Quality of English-Czech Machine Translation. Master&#8217;s thesis,</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>2009</date>
      </reference>
      <reference>
        <id>13</id>
        <authors>
          <author>Petr Sgall</author>
        </authors>
        <title>Generativn&#237; popis jazyka a &#269;esk&#225; deklinace.</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>1967</date>
      </reference>
      <reference>
        <id>14</id>
        <authors>
          <author>Drahom&#237;ra Spoustov&#225;</author>
          <author>Jan Haji&#269;</author>
          <author>Jan Votrubec</author>
          <author>Pavel Krbec</author>
          <author>Pavel Kv&#283;to&#328;</author>
        </authors>
        <title>The Best of Two Worlds: Cooperation of Statistical and Rule-Based Taggers for Czech.</title>
        <publication>In Proceedings of the Workshop on Balto-Slavonic Natural Language Processing, ACL</publication>
        <pages>67--74</pages>
        <date>2007</date>
      </reference>
      <reference>
        <id>15</id>
        <authors>
          <author>David Vadas</author>
          <author>James Curran</author>
        </authors>
        <title>Adding Noun Phrase Structure to the Penn Treebank.</title>
        <publication>In Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics,</publication>
        <pages>240--247</pages>
        <date>2007</date>
      </reference>
      <reference>
        <id>16</id>
        <authors>
          <author>Zden&#283;k &#381;abokrtsk&#253;</author>
          <author>Martin Popel</author>
        </authors>
        <title>Hidden Markov Tree Model in Dependency-based Machine Translation.</title>
        <publication>In Proceedings of the ACL-IJCNLP 2009 Conference Short Papers,</publication>
        <pages>145--148</pages>
        <date>2009</date>
      </reference>
      <reference>
        <id>17</id>
        <authors>
          <author>Zden&#283;k &#381;abokrtsk&#253;</author>
          <author>Jan Pt&#225;&#269;ek</author>
          <author>Petr Pajas</author>
        </authors>
        <title>TectoMT: Highly Modular MT System with Tectogrammatics Used as Transfer Layer.</title>
        <publication>In Proceedings of the 3rd Workshop on Statistical Machine Translation, ACL,</publication>
        <pages>167--170</pages>
        <date>2008</date>
      </reference>
      <reference>
        <id>18</id>
        <authors>
          <author>Daniel Zeman</author>
        </authors>
        <title>Parsing with a Statistical Dependency Model.</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>2004</date>
      </reference>
      <reference>
        <id>19</id>
        <authors>
          <author>Yue Zhang</author>
          <author>Joakim Nivre</author>
        </authors>
        <title>Transition-based dependency parsing with rich non-local features.</title>
        <publication>In To appear in the Proceedings of the 49th Annual Meeting of the Association of Computational Linguistics.</publication>
        <pages>None</pages>
        <date>2011</date>
      </reference>
    </references>
    <citations>
      <citation>
        <id>0</id>
        <reference_id>0</reference_id>
        <string>Bojar and &#381;abokrtsk&#253;, 2009</string>
        <sentence_id>722738</sentence_id>
        <char_offset>122</char_offset>
      </citation>
      <citation>
        <id>1</id>
        <reference_id>1</reference_id>
        <string>Charniak and Johnson, 2005</string>
        <sentence_id>722719</sentence_id>
        <char_offset>258</char_offset>
      </citation>
      <citation>
        <id>2</id>
        <reference_id>1</reference_id>
        <string>Charniak and Johnson, 2005</string>
        <sentence_id>722774</sentence_id>
        <char_offset>69</char_offset>
      </citation>
      <citation>
        <id>3</id>
        <reference_id>2</reference_id>
        <string>Gaifman (1965)</string>
        <sentence_id>722771</sentence_id>
        <char_offset>310</char_offset>
      </citation>
      <citation>
        <id>4</id>
        <reference_id>4</reference_id>
        <string>Haji&#269;, 2004</string>
        <sentence_id>722744</sentence_id>
        <char_offset>134</char_offset>
      </citation>
      <citation>
        <id>5</id>
        <reference_id>5</reference_id>
        <string>Johansson and Nugues, 2007</string>
        <sentence_id>722719</sentence_id>
        <char_offset>390</char_offset>
      </citation>
      <citation>
        <id>6</id>
        <reference_id>5</reference_id>
        <string>Johansson and Nugues, 2007</string>
        <sentence_id>722796</sentence_id>
        <char_offset>247</char_offset>
      </citation>
      <citation>
        <id>7</id>
        <reference_id>5</reference_id>
        <string>Johansson and Nugues (2007)</string>
        <sentence_id>722780</sentence_id>
        <char_offset>44</char_offset>
      </citation>
      <citation>
        <id>8</id>
        <reference_id>6</reference_id>
        <string>Klein and Manning, 2003</string>
        <sentence_id>722719</sentence_id>
        <char_offset>291</char_offset>
      </citation>
      <citation>
        <id>9</id>
        <reference_id>6</reference_id>
        <string>Klein and Manning, 2003</string>
        <sentence_id>722773</sentence_id>
        <char_offset>34</char_offset>
      </citation>
      <citation>
        <id>10</id>
        <reference_id>7</reference_id>
        <string>Ku&#269;erov&#225; and &#381;abokrtsk&#253; (2002)</string>
        <sentence_id>722782</sentence_id>
        <char_offset>123</char_offset>
      </citation>
      <citation>
        <id>11</id>
        <reference_id>8</reference_id>
        <string>Mare&#269;ek et al. (2010)</string>
        <sentence_id>722700</sentence_id>
        <char_offset>483</char_offset>
      </citation>
      <citation>
        <id>12</id>
        <reference_id>8</reference_id>
        <string>Mare&#269;ek et al., 2010</string>
        <sentence_id>722736</sentence_id>
        <char_offset>106</char_offset>
      </citation>
      <citation>
        <id>13</id>
        <reference_id>9</reference_id>
        <string>Mcdonald and Pereira, 2006</string>
        <sentence_id>722762</sentence_id>
        <char_offset>38</char_offset>
      </citation>
      <citation>
        <id>14</id>
        <reference_id>10</reference_id>
        <string>McDonald et al., 2005</string>
        <sentence_id>722719</sentence_id>
        <char_offset>153</char_offset>
      </citation>
      <citation>
        <id>15</id>
        <reference_id>11</reference_id>
        <string>Nivre et al. (2007)</string>
        <sentence_id>722767</sentence_id>
        <char_offset>35</char_offset>
      </citation>
      <citation>
        <id>16</id>
        <reference_id>11</reference_id>
        <string>Nivre et al., 2007</string>
        <sentence_id>722719</sentence_id>
        <char_offset>178</char_offset>
      </citation>
      <citation>
        <id>17</id>
        <reference_id>12</reference_id>
        <string>Popel (2009)</string>
        <sentence_id>722698</sentence_id>
        <char_offset>21</char_offset>
      </citation>
      <citation>
        <id>18</id>
        <reference_id>12</reference_id>
        <string>Popel (2009)</string>
        <sentence_id>722700</sentence_id>
        <char_offset>384</char_offset>
      </citation>
      <citation>
        <id>19</id>
        <reference_id>12</reference_id>
        <string>Popel (2009)</string>
        <sentence_id>722735</sentence_id>
        <char_offset>21</char_offset>
      </citation>
      <citation>
        <id>20</id>
        <reference_id>13</reference_id>
        <string>Sgall (1967)</string>
        <sentence_id>722752</sentence_id>
        <char_offset>34</char_offset>
      </citation>
      <citation>
        <id>21</id>
        <reference_id>14</reference_id>
        <string>Spoustov&#225; et al., 2007</string>
        <sentence_id>722729</sentence_id>
        <char_offset>85</char_offset>
      </citation>
      <citation>
        <id>22</id>
        <reference_id>15</reference_id>
        <string>Vadas and Curran (2007)</string>
        <sentence_id>722796</sentence_id>
        <char_offset>203</char_offset>
      </citation>
      <citation>
        <id>23</id>
        <reference_id>16</reference_id>
        <string>&#381;abokrtsk&#253; and Popel, 2009</string>
        <sentence_id>722737</sentence_id>
        <char_offset>60</char_offset>
      </citation>
      <citation>
        <id>24</id>
        <reference_id>16</reference_id>
        <string>&#381;abokrtsk&#253; and Popel (2009)</string>
        <sentence_id>722700</sentence_id>
        <char_offset>369</char_offset>
      </citation>
      <citation>
        <id>25</id>
        <reference_id>17</reference_id>
        <string>&#381;abokrtsk&#253; et al. (2008)</string>
        <sentence_id>722696</sentence_id>
        <char_offset>34</char_offset>
      </citation>
      <citation>
        <id>26</id>
        <reference_id>17</reference_id>
        <string>&#381;abokrtsk&#253; et al. (2008)</string>
        <sentence_id>722750</sentence_id>
        <char_offset>101</char_offset>
      </citation>
      <citation>
        <id>27</id>
        <reference_id>18</reference_id>
        <string>Zeman, 2004</string>
        <sentence_id>722710</sentence_id>
        <char_offset>99</char_offset>
      </citation>
      <citation>
        <id>28</id>
        <reference_id>19</reference_id>
        <string>Zhang and Nivre, 2011</string>
        <sentence_id>722719</sentence_id>
        <char_offset>204</char_offset>
      </citation>
      <citation>
        <id>29</id>
        <reference_id>19</reference_id>
        <string>Zhang and Nivre (2011)</string>
        <sentence_id>722770</sentence_id>
        <char_offset>153</char_offset>
      </citation>
    </citations>
  </content>
</document>
