<PAPER>
  <FILENO/>
  <TITLE>Forest-based Tree Sequence to String Translation Model</TITLE>
  <AUTHORS/>
  <ABSTRACT>
    <A-S ID="S-26044">This paper proposes a forest-based tree sequence to string translation model for syntaxbased statistical machine translation, which automatically learns tree sequence to string translation rules from word-aligned sourceside-parsed bilingual texts.</A-S>
    <A-S ID="S-26045">The proposed model leverages on the strengths of both tree sequence-based and forest-based translation models.</A-S>
    <A-S ID="S-26046">Therefore, it can not only utilize forest structure that compactly encodes exponential number of parse trees but also capture nonsyntactic translation equivalences with linguistically structured information through tree sequence.</A-S>
    <A-S ID="S-26047">This makes our model potentially more robust to parse errors and structure divergence.</A-S>
    <A-S ID="S-26048">Experimental results on the NIST MT-2003 Chinese-English translation task show that our method statistically significantly outperforms the four baseline systems.</A-S>
  </ABSTRACT>
  <BODY>
    <DIV DEPTH="0">
      <HEADER>1 Introduction</HEADER>
      <P>
        <S ID="S-26049">Recently syntax-based statistical machine translation (SMT) methods have achieved very promising results and attracted more and more interests in the SMT research community.</S>
        <S ID="S-26050">Fundamentally, syntax-based SMT views translation as a structural transformation process.</S>
        <S ID="S-26051">Therefore, structure divergence and parse errors are two of the major issues that may largely compromise the performance of syntax-based SMT (Zhang et al., 2008a; <REF ID="R-11" RPTR="24">Mi et al., 2008</REF>).</S>
      </P>
      <P>
        <S ID="S-26052">Many solutions have been proposed to address the above two issues.</S>
        <S ID="S-26053">Among these advances, forest-based modeling (<REF ID="R-11" RPTR="25">Mi et al., 2008</REF>; <REF ID="R-12" RPTR="31">Mi and Huang, 2008</REF><REF ID="R-03" RPTR="7">Huang, 2008</REF>) and tree sequence-based modeling (<REF ID="R-10" RPTR="19">Liu et al., 2007</REF>; Zhang et al., 2008a) are two interesting modeling methods with promising results reported.</S>
        <S ID="S-26054">Forest-based modeling aims to improve translation accuracy through digging the potential better parses from n-bests (i.e. forest) while tree sequence-based modeling aims to model non-syntactic translations with structured syntactic knowledge.</S>
        <S ID="S-26055">In nature, the two methods would be complementary to each other since they manage to solve the negative impacts of monolingual parse errors and cross-lingual structure divergence on translation results from different viewpoints.</S>
        <S ID="S-26056">Therefore, one natural way is to combine the strengths of the two modeling methods for better performance of syntax-based SMT.</S>
        <S ID="S-26057">However, there are many challenges in combining the two methods into a single model from both theoretical and implementation engineering viewpoints.</S>
        <S ID="S-26058">In theory, one may worry about whether the advantage of tree sequence has already been covered by forest because forest encodes implicitly a huge number of parse trees and these parse trees may generate many different phrases and structure segmentations given a source sentence.</S>
        <S ID="S-26059">In system implementation, the exponential combinations of tree sequences with forest structures make the rule extraction and decoding tasks much more complicated than that of the two individual methods.</S>
      </P>
      <P>
        <S ID="S-26060">In this paper, we propose a forest-based tree sequence to string model, which is designed to integrate the strengths of the forest-based and the tree sequence-based modeling methods.</S>
        <S ID="S-26061">We present our solutions that are able to extract translation rules and decode translation results for our model very efficiently.</S>
        <S ID="S-26062">A general, configurable platform was designed for our model.</S>
        <S ID="S-26063">With this platform, we can easily implement our method and many previous syntax-based methods by simple parameter setting.</S>
        <S ID="S-26064">We evaluate our method on the NIST MT-2003 Chinese-English translation tasks.</S>
        <S ID="S-26065">Experimental results show that our method significantly outperforms the two individual methods and other baseline methods.</S>
        <S ID="S-26066">Our study shows that the proposed method is able to effectively combine the strengths of the forest-based and tree sequence-based methods, and thus having great potential to address the issues of parse errors and non-syntactic transla-</S>
      </P>
      <P>
        <S ID="S-26067">tions resulting from structure divergence.</S>
        <S ID="S-26068">It also indicates that tree sequence and forest play different roles and make contributions to our model in different ways.</S>
      </P>
      <P>
        <S ID="S-26069">The remainder of the paper is organized as follows.</S>
        <S ID="S-26070">Section 2 describes related work while section 3 defines our translation model.</S>
        <S ID="S-26071">In section 4 and section 5, the key rule extraction and decoding algorithms are elaborated.</S>
        <S ID="S-26072">Experimental results are reported in section 6 and the paper is concluded in section 7.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>2 Related work</HEADER>
      <P>
        <S ID="S-26073">As discussed in section 1, two of the major challenges to syntax-based SMT are structure divergence and parse errors.</S>
        <S ID="S-26074">Many techniques have been proposed to address the structure divergence issue while only fewer studies are reported in addressing the parse errors in the SMT research community.</S>
      </P>
      <P>
        <S ID="S-26075">To address structure divergence issue, many researchers (<REF ID="R-01" RPTR="1">Eisner, 2003</REF>; Zhang et al., 2007) propose using the Synchronous Tree Substitution Grammar (STSG) grammar in syntax-based SMT since the STSG uses larger tree fragment as translation unit.</S>
        <S ID="S-26076">Although promising results have been reported, STSG only uses one single subtree as translation unit which is still committed to the syntax strictly.</S>
        <S ID="S-26077">Motivated by the fact that non-syntactic phrases make non-trivial contribution to phrase-based SMT, the tree sequencebased translation model is proposed (<REF ID="R-10" RPTR="20">Liu et al., 2007</REF>; Zhang et al., 2008a) that uses tree sequence as the basic translation unit, rather than using single sub-tree as in the STSG.</S>
        <S ID="S-26078">Here, a tree sequence refers to a sequence of consecutive sub-trees that are embedded in a full parse tree.</S>
        <S ID="S-26079">For any given phrase in a sentence, there is at least one tree sequence covering it.</S>
        <S ID="S-26080">Thus the tree sequence-based model has great potential to address the structure divergence issue by using tree sequence-based non-syntactic translation rules.</S>
        <S ID="S-26081"><REF ID="R-10" RPTR="17">Liu et al. (2007)</REF> propose the tree sequence concept and design a tree sequence to string translation model.</S>
        <S ID="S-26082">Zhang et al. (2008a) propose a tree sequence-based tree to tree translation model and Zhang et al. (2008b) demonstrate that the tree sequence-based modelling method can well address the structure divergence issue for syntaxbased SMT.</S>
      </P>
      <P>
        <S ID="S-26083">To overcome the parse errors for SMT, <REF ID="R-11" RPTR="21">Mi et al. (2008)</REF> propose a forest-based translation method that uses forest instead of one best tree as translation input, where a forest is a compact representation of exponentially number of n-best parse trees.</S>
        <S ID="S-26084"><REF ID="R-12" RPTR="28">Mi and Huang (2008)</REF><REF ID="R-03" RPTR="4">Huang (2008)</REF> propose a forest-based rule extraction algorithm, which learn tree to string rules from source forest and target string.</S>
        <S ID="S-26085">By using forest in rule extraction and decoding, their methods are able to well address the parse error issue.</S>
      </P>
      <P>
        <S ID="S-26086">From the above discussion, we can see that traditional tree sequence-based method uses single tree as translation input while the forestbased model uses single sub-tree as the basic translation unit that can only learn tree-to-string (<REF ID="R-02" RPTR="2">Galley et al. 2004</REF>; <REF ID="R-09" RPTR="16">Liu et al., 2006</REF>) rules.</S>
        <S ID="S-26087">Therefore, the two methods display different strengths, and which would be complementary to each other.</S>
        <S ID="S-26088">To integrate their strengths, in this paper, we propose a forest-based tree sequence to string translation model.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>3 Forest-based tree sequence to string model</HEADER>
      <P>
        <S ID="S-26154">In this section, we first explain what a packed forest is and then define the concept of the tree sequence in the context of forest followed by the discussion on our proposed model.</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>3.1 Packed Forest</HEADER>
        <P>
          <S ID="S-26089">A packed forest (forest in short) is a special kind of hyper-graph (<REF ID="R-06" RPTR="14">Klein and Manning, 2001</REF>; Huang and Chiang, 2005), which is used to represent all derivations (i.e. parse trees) for a given sentence under a context free grammar (CFG).</S>
          <S ID="S-26090">A forest F is defined as a triple &#65533; &#65533;,&#65533;,&#65533; &#65533;, where &#65533; is non-terminal node set, &#65533; is hyper-edge set and &#65533; is leaf node set (i.e. all sentence words).</S>
          <S ID="S-26091">A forest F satisfies the following two conditions:</S>
        </P>
        <P>
          <S ID="S-26092">1) Each node &#65533; in &#65533; should cover a phrase, which is a continuous word sub-sequence in &#65533;.</S>
        </P>
        <P>
          <S ID="S-26093">2) Each hyper-edge &#65533; in &#65533; is defined as &#65533; &#65533; &#65533;&#65533; &#65533; &#8230;&#65533; &#65533; &#8230;&#65533; &#65533; ,&#65533;&#65533; &#65533; &#65533;&#65533;&#65533;&#65533;&#65533;&#65533;,&#65533; &#65533; &#65533;&#65533;&#65533; , where &#65533; &#65533; &#8230; &#65533; &#65533; &#8230;&#65533; &#65533; covers a sequence of continuous and non-overlap phrases, &#65533; &#65533; is the father node of the children sequence &#65533; &#65533; &#8230;&#65533; &#65533; &#8230;&#65533; &#65533; .</S>
          <S ID="S-26094">The phrase covered by &#65533; &#65533; is just the sum of all the phrases covered by each child node &#65533; &#65533; .</S>
        </P>
        <P>
          <S ID="S-26095">We here introduce another concept that is used in our subsequent discussions.</S>
          <S ID="S-26096">A complete forest CF is a general forest with one additional condition that there is only one root node N in CF, i.e., all nodes except the root N in a CF must have at least one father node.</S>
        </P>
        <P>
          <S ID="S-26097">Fig.</S>
          <S ID="S-26098">1 is a complete forest while Fig.</S>
          <S ID="S-26099">7 is a non-complete forest due to the virtual node &#8220;VV+VV&#8221; introduced in Fig.</S>
          <S ID="S-26100">7.</S>
          <S ID="S-26101">Fig.</S>
          <S ID="S-26102">2 is a hyperedge (IP =&gt; NP VP) of Fig.</S>
          <S ID="S-26103">1, where NP covers</S>
        </P>
        <P>
          <S ID="S-26104">the phrase &#8220;Xinhuashe&#8221;, VP covers the phrase &#8220;shengming youguan guiding&#8221; and IP covers the entire sentence.</S>
          <S ID="S-26105">In Fig.1, only root IP has no father node, so it is a complete forest.</S>
          <S ID="S-26106">The two parse trees T1 and T2 encoded in Fig.</S>
          <S ID="S-26107">1 are shown separately in Fig.</S>
          <S ID="S-26108">3 and Fig.</S>
          <S ID="S-26109">4 1 .</S>
        </P>
        <P>
          <S ID="S-26110">Different parse tree represents different derivations and explanations for a given sentence.</S>
          <S ID="S-26111">For example, for the same input sentence in Fig.</S>
          <S ID="S-26112">1, T1 interprets it as &#8220;XNA (Xinhua News Agency) declares some regulations.&#8221; while T2 interprets it as &#8220;XNA declaration is related to some regulations.&#8221;.</S>
        </P>
        <P>
          <S ID="S-26113">Figure 1.</S>
          <S ID="S-26114">A packed forest for sentence &#8220; &#26032; &#21326; &#31038; /Xinhuashe &#22768; &#26126; /shengming &#26377; &#20851; /youguan &#35268; &#23450; /guiding&#8221;</S>
        </P>
        <P>
          <S ID="S-26115">them lies in that the sub-trees of a tree sequence in forest may belongs to different single parse trees while, in a single parse tree-based model, all the sub-trees in a tree sequence are committed to the same parse tree.</S>
        </P>
        <P>
          <S ID="S-26116">The forest-based tree sequence enables our model to have the potential of exploring additional parse trees that may be wrongly pruned out by the parser and thus are not encoded in the forest.</S>
          <S ID="S-26117">This is because that a tree sequence in a forest allows its sub-trees coming from different parse trees, where these sub-trees may not be merged finally to form a complete parse tree in the forest.</S>
          <S ID="S-26118">Take the forest in Fig.</S>
          <S ID="S-26119">1 as an example, where ((VV shengming) (JJ youguan)) is a tree sequence that all sub-trees appear in T1 while ((VV shengming) (VV youguan)) is a tree sequence whose sub-trees do not belong to any single tree in the forest.</S>
          <S ID="S-26120">But, indeed the two subtrees (VV shengming) and (VV youguan) can be merged together and further lead to a complete single parse tree which may offer a correct interpretation to the input sentence (as shown in Fig.</S>
          <S ID="S-26121">5).</S>
          <S ID="S-26122">In addition, please note that, on the other hand, more parse trees may introduce more noisy structures.</S>
          <S ID="S-26123">In this paper, we leave this problem to our model and let the model decide which substructures are noisy features.</S>
        </P>
        <P>
          <S ID="S-26124">Figure 2.</S>
          <S ID="S-26125">A hyper-edge used in Fig.</S>
          <S ID="S-26126">1</S>
        </P>
        <P>
          <S ID="S-26127">Figure 5.</S>
          <S ID="S-26128">A parse tree that was wrongly pruned out</S>
        </P>
        <P>
          <S ID="S-26129">Figure 3.</S>
          <S ID="S-26130">Tree 1 (T1)</S>
        </P>
        <P>
          <S ID="S-26131">Figure 4.</S>
          <S ID="S-26132">Tree 2 (T2)</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.2 Tree sequence in packed forest</HEADER>
        <P>
          <S ID="S-26133">Similar to the definition of tree sequence used in a single parse tree defined in <REF ID="R-10" RPTR="18">Liu et al. (2007)</REF> and Zhang et al. (2008a), a tree sequence in a forest also refers to an ordered sub-tree sequence that covers a continuous phrase without overlapping.</S>
          <S ID="S-26134">However, the major difference between</S>
        </P>
        <P>
          <S ID="S-26135">1 Please note that a single tree (as T1 and T2 shown in Fig.</S>
        </P>
        <P>
          <S ID="S-26136">3 and Fig.</S>
          <S ID="S-26137">4) is represented by edges instead of hyper-edges.</S>
          <S ID="S-26138">A hyper-edge is a group of edges satisfying the 2 nd condition as shown in the forest definition.</S>
        </P>
        <P>
          <S ID="S-26139">Figure 6.</S>
          <S ID="S-26140">A tree sequence to string rule</S>
        </P>
        <P>
          <S ID="S-26141">A tree-sequence to string translation rule in a forest is a triple &lt;L, R, A&gt;, where L is the tree sequence in source language, R is the string containing words and variables in target language, and A is the alignment between the leaf nodes of L and R.</S>
          <S ID="S-26142">This definition is similar to that of (Liu et al. 2007, Zhang et al. 2008a) except our treesequence is defined in forest.</S>
          <S ID="S-26143">The shaded area of Fig.</S>
          <S ID="S-26144">6 exemplifies a tree sequence to string translation rule in the forest.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.3 Forest-based tree-sequence to string translation model</HEADER>
        <P>
          <S ID="S-26145">Given a source forest F and target translation T S as well as word alignment A, our translation model is formulated as:</S>
        </P>
        <P>
          <S ID="S-26146">Pr&#65533;&#65533;, &#65533; &#65533; ,&#65533;&#65533; &#65533; &#8721;&#65533; &#65533; &#65533; &#65533;,&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;,&#65533; &#65533; ,&#65533;&#65533; &#8719;&#65533; &#65533; &#65533;&#65533; &#65533; &#65533;&#65533;&#65533; &#65533; &#65533;</S>
        </P>
        <P>
          <S ID="S-26147">By the above Eq., translation becomes a tree sequence structure to string mapping issue.</S>
          <S ID="S-26148">Given the F, T S and A, there are multiple derivations that could map F to T S under the constraint A.</S>
          <S ID="S-26149">The mapping probability Pr&#65533;&#65533;, &#65533; &#65533; ,&#65533;&#65533; in our study is obtained by summing over the probabilities of all derivations &#920;.</S>
          <S ID="S-26150">The probability of each derivation &#65533; &#65533; is given as the product of the probabilities of all the rules pr ( i ) used in the derivation (here we assume that each rule is applied independently in a derivation).</S>
        </P>
        <P>
          <S ID="S-26151">Our model is implemented under log-linear framework (<REF ID="R-13" RPTR="35">Och and Ney, 2002</REF>).</S>
          <S ID="S-26152">We use seven basic features that are analogous to the commonly used features in phrase-based systems (Koehn, 2003): 1) bidirectional rule mapping probabilities, 2) bidirectional lexical rule translation probabilities, 3) target language model, 4) number of rules used and 5) number of target words.</S>
          <S ID="S-26153">In addition, we define two new features: 1) number of leaf nodes in auxiliary rules (the auxiliary rule will be explained later in this paper) and 2) product of the probabilities of all hyper-edges of the tree sequences in forest.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>4 Training</HEADER>
      <P>
        <S ID="S-26155">This section discusses how to extract our translation rules given a triple &#65533; &#65533;,&#65533; &#65533; ,&#65533; &#65533;.</S>
        <S ID="S-26156">As we know, the traditional tree-to-string rules can be easily extracted from &#65533; &#65533;,&#65533; &#65533; ,&#65533; &#65533; using the algorithm of <REF ID="R-12" RPTR="29">Mi and Huang (2008)</REF><REF ID="R-03" RPTR="5">Huang (2008)</REF> 2 .</S>
        <S ID="S-26157">We would like</S>
      </P>
      <P>
        <S ID="S-26158">2 <REF ID="R-12" RPTR="30">Mi and Huang (2008)</REF><REF ID="R-03" RPTR="6">Huang (2008)</REF> extend the tree-based rule extraction</S>
      </P>
      <P>
        <S ID="S-26159">algorithm (<REF ID="R-02" RPTR="3">Galley et al., 2004</REF>) to forest-based by introducing non-deterministic mechanism.</S>
        <S ID="S-26160">Their algorithm consists of two steps, minimal rule extraction and composed rule generation.</S>
      </P>
      <P>
        <S ID="S-26161">to leverage on their algorithm in our study.</S>
        <S ID="S-26162">Unfortunately, their algorithm is not directly applicable to our problem because tree rules have only one root while tree sequence rules have multiple roots.</S>
        <S ID="S-26163">This makes the tree sequence rule extraction very complex due to its interaction with forest structure.</S>
        <S ID="S-26164">To address this issue, we introduce the concepts of virtual node and virtual hyperedge to convert a complete parse forest &#65533; to a non-complete forest &#65533; which is designed to encode all the tree sequences that we want.</S>
        <S ID="S-26165">Therefore, by doing so, the tree sequence rules can be extracted from a forest in the following two steps:</S>
      </P>
      <P>
        <S ID="S-26166">1) Convert the complete parse forest &#65533; into a non-complete forest &#65533; in order to cover those tree sequences that cannot be covered by a single tree node.</S>
      </P>
      <P>
        <S ID="S-26167">2) Employ the forest-based tree rule extraction algorithm (<REF ID="R-12" RPTR="32">Mi and Huang, 2008</REF><REF ID="R-03" RPTR="8">Huang, 2008</REF>) to extract our rules from the non-complete forest.</S>
      </P>
      <P>
        <S ID="S-26168">To facilitate our discussion, here we introduce two notations:</S>
      </P>
      <P>
        <S ID="S-26169">&#8226; Alignable: A consecutive source phrase is an alignable phrase if and only if it can be aligned with at least one consecutive target phrase under the word-alignment constraint.</S>
        <S ID="S-26170">The covered source span is called alignable span.</S>
      </P>
      <P>
        <S ID="S-26171">&#8226; Node sequence: a sequence of nodes (either leaf or internal nodes) in a forest covering a consecutive span.</S>
      </P>
      <P>
        <S ID="S-26172">Algorithm 1 illustrates the first step of our rule extraction algorithm, which is a CKY-style Dynamic Programming (DP) algorithm to add virtual nodes into forest.</S>
        <S ID="S-26173">It includes the following steps:</S>
      </P>
      <P>
        <S ID="S-26174">1) We traverse the forest to visit each span in bottom-up fashion (line 1-2), 1.1) for each span [u,v] that is covered by</S>
      </P>
      <P>
        <S ID="S-26175">single tree nodes 3 , we put these tree nodes into the set NSS(u,v) and go back to step 1 (line 4-6).</S>
      </P>
      <P>
        <S ID="S-26176">1.2) otherwise we concatenate the tree sequences of sub-spans to generate the set of tree sequences covering the current larger span (line 8-13).</S>
        <S ID="S-26177">Then, we prune the set of node sequences (line 14).</S>
        <S ID="S-26178">If this span is alignable, we create virtual father nodes and corresponding virtual hyper-edges to link the node sequences with the virtual father nodes (line 15-20).</S>
      </P>
      <P>
        <S ID="S-26179">3 Note that in a forest, there would be multiple single tree</S>
      </P>
      <P>
        <S ID="S-26180">nodes covering the same span as shown Fig.1.</S>
      </P>
      <P>
        <S ID="S-26181">2) Finally we obtain a forest with each alignable span covered by either original tree nodes or the newly-created tree sequence virtual nodes.</S>
      </P>
      <P>
        <S ID="S-26182">Theoretically, there is exponential number of node sequences in a forest.</S>
        <S ID="S-26183">Take Fig.</S>
        <S ID="S-26184">7 as an example.</S>
        <S ID="S-26185">The NSS of span [1,2] only contains &#8220;NP&#8221; since it is alignable and covered by the single tree node NP.</S>
        <S ID="S-26186">However, span [2,3] cannot be covered by any single tree node, so we have to create the NSS of span[2,3] by concatenating the NSSs of span [2,2] and span [3,3].</S>
        <S ID="S-26187">Since NSS of span [2,2] contains 4 element {&#8220;NN&#8221;, &#8220;NP&#8221;, &#8220;VV&#8221;, &#8220;VP&#8221;} and NSS of span [3, 3] also contains 4 element {&#8220;VV&#8221;, &#8220;VP&#8221;, &#8220;JJ&#8221;, &#8220;ADJP&#8221;}, NSS of span [2,3] contains 16=4*4 elements.</S>
        <S ID="S-26188">To make the NSS manageable, we prune it with the following thresholds:</S>
      </P>
      <P>
        <S ID="S-26189">&#8226; each node sequence should contain less than n nodes</S>
      </P>
      <P>
        <S ID="S-26190">&#8226; each node sequence set should contain less than m node sequences</S>
      </P>
      <P>
        <S ID="S-26191">&#8226; sort node sequences according to their lengths and only keep the k shortest ones</S>
      </P>
      <P>
        <S ID="S-26192">Each virtual node is simply labeled by the concatenation of all its children&#8217;s labels as shown in Fig.</S>
        <S ID="S-26193">7.</S>
      </P>
      <P>
        <S ID="S-26194">Algorithm 1. add virtual nodes into forest Input: packed forest F, alignment A Notation:</S>
      </P>
      <P>
        <S ID="S-26195">L: length of source sentence NSS(u,v): the set of node sequences covering span [u,v] VN(ns): virtual father node for node sequence ns.</S>
        <S ID="S-26196">Output: modified forest F with virtual nodes</S>
      </P>
      <P>
        <S ID="S-26197">Algorithm 1 outputs a non-complete forest CF with each alignable span covered by either tree nodes or virtual nodes.</S>
        <S ID="S-26198">Then we can easily extract our rules from the CF using the tree rule extraction algorithm (<REF ID="R-12" RPTR="33">Mi and Huang, 2008</REF><REF ID="R-03" RPTR="9">Huang, 2008</REF>).</S>
      </P>
      <P>
        <S ID="S-26199">Finally, to calculate rule feature probabilities for our model, we need to calculate the fractional counts (it is a kind of probability defined in <REF ID="R-12" RPTR="34">Mi and Huang, 2008</REF><REF ID="R-03" RPTR="10">Huang, 2008</REF>) of each translation rule in a parse forest.</S>
        <S ID="S-26200">In the tree case, we can use the inside-outside-based methods (Mi and Huang 2008) to do it.</S>
        <S ID="S-26201">In the tree sequence case, since the previous method cannot be used directly, we provide another solution by making an independent assumption that each tree in a tree sequence is independent to each other.</S>
        <S ID="S-26202">With this assumption, the fractional counts of both tree and tree sequence can be calculated as follows:</S>
      </P>
      <P>
        <S ID="S-26203">&#65533;&#65533;&#65533;&#65533; &#65533; &#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533; &#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;</S>
      </P>
      <P>
        <S ID="S-26204">&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533; &#65533; &#65533; &#65533;&#65533;&#65533;&#65533; &#65533; &#65533; &#65533;&#65533;&#65533;&#65533; &#65533; &#65533; &#65533;&#65533;&#65533;&#65533;</S>
      </P>
      <P>
        <S ID="S-26205">&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533; &#65533;&#65533;&#65533;&#65533;&#65533;&#65533; &#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;</S>
      </P>
      <P>
        <S ID="S-26206">where &#65533;&#65533;&#65533;&#65533; is the fractional counts to be calculated for rule r, a frag is either lhs(r) (excluding virtual nodes and virtual hyper-edges) or any tree node in a forest, TOP is the root of the forest, &#65533;&#65533;.</S>
        <S ID="S-26207">&#65533; and &#65533;&#65533;.</S>
        <S ID="S-26208">) are the outside and inside probabilities of nodes, &#65533;&#65533;&#65533;&#65533;&#65533;.</S>
        <S ID="S-26209">&#65533; returns the root nodes of a tree sequence fragment, &#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;.</S>
        <S ID="S-26210">&#65533; returns the leaf nodes of a tree sequence fragment, &#65533;&#65533;&#65533;&#65533; is the hyper-edge probability.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>5 Decoding</HEADER>
      <P>
        <S ID="S-26211">Figure 7.</S>
        <S ID="S-26212">A virtual node in forest</S>
      </P>
      <P>
        <S ID="S-26213">We benefit from the same strategy as used in our rule extraction algorithm in designing our decoding algorithm, recasting the forest-based tree sequence-to-string decoding problem as a forestbased tree-to-string decoding problem.</S>
        <S ID="S-26214">Our decoding algorithm consists of four steps:</S>
      </P>
      <P>
        <S ID="S-26215">1) Convert the complete parse forest to a noncomplete one by introducing virtual nodes.</S>
      </P>
      <P>
        <S ID="S-26216">2) Convert the non-complete parse forest into a translation forest 4 &#65533;&#65533; by using the translation rules and the pattern-matching algorithm presented in <REF ID="R-11" RPTR="22">Mi et al. (2008)</REF>.</S>
      </P>
      <P>
        <S ID="S-26217">3) Prune out redundant nodes and add auxiliary hyper-edge into the translation forest for those nodes that have either no child or no father.</S>
        <S ID="S-26218">By this step, the translation forest &#65533;&#65533; becomes a complete forest.</S>
      </P>
      <P>
        <S ID="S-26219">4) Decode the translation forest using our translation model and a dynamic search algorithm.</S>
      </P>
      <P>
        <S ID="S-26220">The process of step 1 is similar to Algorithm 1 except no alignment constraint used here.</S>
        <S ID="S-26221">This may generate a large number of additional virtual nodes; however, all redundant nodes will be filtered out in step 3.</S>
        <S ID="S-26222">In step 2, we employ the treeto-string pattern match algorithm (<REF ID="R-11" RPTR="26">Mi et al., 2008</REF>) to convert a parse forest to a translation forest.</S>
        <S ID="S-26223">In step 3, all those nodes not covered by any translation rules are removed.</S>
        <S ID="S-26224">In addition, please note that the translation forest is already not a complete forest due to the virtual nodes and the pruning of rule-unmatchable nodes.</S>
        <S ID="S-26225">We, therefore, propose Algorithm 2 to add auxiliary hyper-edges to make the translation forest complete.</S>
      </P>
      <P>
        <S ID="S-26226">In Algorithm 2, we travel the forest in bottomup fashion (line 4-5).</S>
        <S ID="S-26227">For each span, we do:</S>
      </P>
      <P>
        <S ID="S-26228">1) generate all the NSS for this span (line 7-12) 2) filter the NSS to a manageable size (line 13) 3) add auxiliary hyper-edges for the current span (line 15-19) if it can be covered by at least one single tree node, otherwise go to step 1 .</S>
        <S ID="S-26229">This is the key step in our Algorithm 2.</S>
        <S ID="S-26230">For each tree node and each node sequences covering the same span (stored in the current NSS), if the tree node has no children or at least one node in the node sequence has no father, we add an auxiliary hyper-edge to connect the tree node as father node with the node sequence as children.</S>
        <S ID="S-26231">Since Algorithm 2 is DP-based and traverses the forest in a bottom-up way, all the nodes in a node sequence should already have children node after the lower level process in a small span.</S>
        <S ID="S-26232">Finally, we re-build the NSS of current span for upper level NSS combination use (line 20-22).</S>
      </P>
      <P>
        <S ID="S-26233">In Fig.</S>
        <S ID="S-26234">8, the hyper-edge &#8220;IP=&gt;NP VV+VV NP&#8221; is an auxiliary hyper-edge introduced by Algorithm 2.</S>
        <S ID="S-26235">By Algorithm 2, we convert the translation forest into a complete translation forest.</S>
        <S ID="S-26236">We then use a bottom-up node-based search</S>
      </P>
      <P>
        <S ID="S-26237">4 The concept of translation forest is proposed in Mi et</S>
      </P>
      <P>
        <S ID="S-26238">al. (2008).</S>
        <S ID="S-26239">It is a forest that consists of only the hyperedges induced from translation rules.</S>
      </P>
      <P>
        <S ID="S-26240">algorithm to do decoding on the complete translation forest.</S>
        <S ID="S-26241">We also use Cube Pruning algorithm (<REF ID="R-04" RPTR="13">Huang and Chiang 2007</REF>) to speed up the translation process.</S>
      </P>
      <P>
        <S ID="S-26242">Figure 8.</S>
        <S ID="S-26243">Auxiliary hyper-edge in a translation forest</S>
      </P>
      <P>
        <S ID="S-26244">Algorithm 2. add auxiliary hyper-edges into mt forest F Input: mt forest F Output: complete forest F with auxiliary hyper-edges</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>6 Experiment</HEADER>
      <P>
        <S ID="S-26315"></S>
      </P>
      <DIV DEPTH="1">
        <HEADER>6.1 Experimental Settings</HEADER>
        <P>
          <S ID="S-26245">We evaluate our method on Chinese-English translation task.</S>
          <S ID="S-26246">We use the FBIS corpus as training set, the NIST MT-2002 test set as development (dev) set and the NIST MT-2003 test set as test set.</S>
          <S ID="S-26247">We train Charniak&#8217;s parser (<REF ID="R-00" RPTR="0">Charniak 2000</REF>) on CTB5 to do Chinese parsing, and modify it to output packed forest.</S>
          <S ID="S-26248">We tune the parser on section 301-325 and test it on section 271- 300.</S>
          <S ID="S-26249">The F-measure on all sentences is 80.85%.</S>
          <S ID="S-26250">A 3-gram language model is trained on the Xin-</S>
        </P>
        <P>
          <S ID="S-26251">hua portion of the English Gigaword3 corpus and the target side of the FBIS corpus using the SRILM Toolkits (<REF ID="R-17" RPTR="39">Stolcke, 2002</REF>) with modified Kneser-Ney smoothing (Kenser and Ney, 1995).</S>
          <S ID="S-26252">GIZA++ (<REF ID="R-15" RPTR="37">Och and Ney, 2003</REF>) and the heuristics &#8220;grow-diag-final-and&#8221; are used to generate m-ton word alignments.</S>
          <S ID="S-26253">For the MER training (<REF ID="R-14" RPTR="36">Och, 2003</REF>), Koehn&#8217;s MER trainer (Koehn, 2007) is modified for our system.</S>
          <S ID="S-26254">For significance test, we use Zhang et al.&#8217;s implementation (Zhang et al, 2004).</S>
          <S ID="S-26255">Our evaluation metrics is casesensitive BLEU-4 (<REF ID="R-16" RPTR="38">Papineni et al., 2002</REF>).</S>
        </P>
        <P>
          <S ID="S-26256">For parse forest pruning (<REF ID="R-11" RPTR="27">Mi et al., 2008</REF>), we utilize the Margin-based pruning algorithm presented in (<REF ID="R-03" RPTR="11">Huang, 2008</REF>).</S>
          <S ID="S-26257">Different from <REF ID="R-11" RPTR="23">Mi et al. (2008)</REF> that use a static pruning threshold, our threshold is sentence-depended.</S>
          <S ID="S-26258">For each sentence, we compute the Margin between the n-th best and the top 1 parse tree, then use the Margin-based pruning algorithm presented in (<REF ID="R-03" RPTR="12">Huang, 2008</REF>) to do pruning.</S>
          <S ID="S-26259">By doing so, we can guarantee to use at least all the top n best parse trees in the forest.</S>
          <S ID="S-26260">However, please note that even after pruning there is still exponential number of additional trees embedded in the forest because of the sharing structure of forest.</S>
          <S ID="S-26261">Other parameters are set as follows: maximum number of roots in a tree sequence is 3, maximum height of a translation rule is 3, maximum number of leaf nodes is 7, maximum number of node sequences on each span is 10, and maximum number of rules extracted from one node is 10000.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>6.2 Experimental Results</HEADER>
        <P>
          <S ID="S-26262">We implement our proposed methods as a general, configurable platform for syntax-based SMT study.</S>
          <S ID="S-26263">Based on this platform, we are able to easily implement most of the state-of-the-art syntax-based x-to-string SMT methods via simple parameter setting.</S>
          <S ID="S-26264">For training, we set forest pruning threshold to 1 best for tree-based methods and 100 best for forest-based methods.</S>
          <S ID="S-26265">For decoding, we set:</S>
        </P>
        <P>
          <S ID="S-26266">1) TT2S: tree-based tree-to-string model by setting the forest pruning threshold to 1 best and the number of sub-trees in a tree sequence to 1.</S>
        </P>
        <P>
          <S ID="S-26267">2) TTS2S: tree-based tree-sequence to string system by setting the forest pruning threshold to 1 best and the maximum number of sub-trees in a tree sequence to 3.</S>
        </P>
        <P>
          <S ID="S-26268">3) FT2S: forest-based tree-to-string system by setting the forest pruning threshold to 500 best, the number of sub-trees in a tree sequence to 1.</S>
        </P>
        <P>
          <S ID="S-26269">4) FTS2S: forest-based tree-sequence to string system by setting the forest pruning threshold to 500 best and the maximum number of sub-trees in a tree sequence to 3.</S>
        </P>
        <P>
          <S ID="S-26270">Table 1.</S>
          <S ID="S-26271">Performance Comparison</S>
        </P>
        <P>
          <S ID="S-26272">We use the first three syntax-based systems (TT2S, TTS2S, FT2S) and Moses (<REF ID="R-08" RPTR="15">Koehn et al., 2007</REF>), the state-of-the-art phrase-based system, as our baseline systems.</S>
          <S ID="S-26273">Table 1 compares the performance of the five methods, all of which are fine-tuned.</S>
          <S ID="S-26274">It shows that:</S>
        </P>
        <P>
          <S ID="S-26275">1) FTS2S significantly outperforms (p&lt;0.05) FT2S.</S>
          <S ID="S-26276">This shows that tree sequence is very useful to forest-based model.</S>
          <S ID="S-26277">Although a forest can cover much more phrases than a single tree does, there are still many non-syntactic phrases that cannot be captured by a forest due to structure divergence issue.</S>
          <S ID="S-26278">On the other hand, tree sequence is a good solution to non-syntactic translation equivalence modeling.</S>
          <S ID="S-26279">This is mainly because tree sequence rules are only sensitive to word alignment while tree rules, even extracted from a forest (like in FT2S), are also limited by syntax according to grammar parsing rules.</S>
        </P>
        <P>
          <S ID="S-26280">2) FTS2S shows significant performance improvement (p&lt;0.05) over TTS2S due to the contribution of forest.</S>
          <S ID="S-26281">This is mainly due to the fact that forest can offer very large number of parse trees for rule extraction and decoder.</S>
        </P>
        <P>
          <S ID="S-26282">3) Our model statistically significantly outperforms all the baselines system.</S>
          <S ID="S-26283">This clearly demonstrates the effectiveness of our proposed model for syntax-based SMT.</S>
          <S ID="S-26284">It also shows that the forest-based method and tree sequence-based method are complementary to each other and our proposed method is able to effectively integrate their strengths.</S>
        </P>
        <P>
          <S ID="S-26285">4) All the four syntax-based systems show better performance than Moses and three of them significantly outperforms (p&lt;0.05) Moses.</S>
          <S ID="S-26286">This suggests that syntax is very useful to SMT and translation can be viewed as a structure mapping issue as done in the four syntax-based systems.</S>
        </P>
        <P>
          <S ID="S-26287">Table 2 and Table 3 report the distribution of different kinds of translation rules in our model (training forest pruning threshold is set to 100 best) and in our decoding (decoding forest pruning threshold is set to 500 best) for one best translation generation.</S>
          <S ID="S-26288">From the two tables, we can find that:</S>
        </P>
        <P>
          <S ID="S-26289">Table 2.</S>
          <S ID="S-26290"># of rules extracted from training corpus.</S>
          <S ID="S-26291">L means fully lexicalized, P means partially lexicalized, U means unlexicalized.</S>
        </P>
        <P>
          <S ID="S-26292">Table 3.</S>
          <S ID="S-26293"># of rules used to generate one-best translation result in testing</S>
        </P>
        <P>
          <S ID="S-26294">1) In Table 2, the number of tree sequence rules is much larger than that of tree rules although our rule extraction algorithm only extracts those tree sequence rules over the spans that tree rules cannot cover.</S>
          <S ID="S-26295">This suggests that the non-syntactic structure mapping is still a big challenge to syntax-based SMT.</S>
        </P>
        <P>
          <S ID="S-26296">2) Table 3 shows that the tree sequence rules is around 9% of the tree rules when generating the one-best translation.</S>
          <S ID="S-26297">This suggests that around 9% of translation equivalences in the test set can be better modeled by tree sequence to string rules than by tree to string rules.</S>
          <S ID="S-26298">The 9% tree sequence rules contribute 1.17 BLEU score improvement (28.83-27.66 in Table 1) to FTS2S over FT2S.</S>
        </P>
        <P>
          <S ID="S-26299">3) In Table 3, the fully-lexicalized rules are the major part (around 60%), followed by the partially-lexicalized (around 35%) and unlexicalized (around 15%).</S>
          <S ID="S-26300">However, in Table 2, partially-lexicalized rules extracted from training corpus are the major part (more than 70%).</S>
          <S ID="S-26301">This suggests that most partially-lexicalized rules are less effective in our model.</S>
          <S ID="S-26302">This clearly directs our future work in model optimization.</S>
        </P>
        <P>
          <S ID="S-26303">Table 4.</S>
          <S ID="S-26304">Impact of the forest pruning</S>
        </P>
        <P>
          <S ID="S-26305">Forest pruning is a key step for forest-based method.</S>
          <S ID="S-26306">Table 4 reports the performance of the two forest-based models using different values of the forest pruning threshold for decoding.</S>
          <S ID="S-26307">It shows that:</S>
        </P>
        <P>
          <S ID="S-26308">1) FTS2S significantly outperforms (p&lt;0.05) FT2S consistently in all test cases.</S>
          <S ID="S-26309">This again demonstrates the effectiveness of our proposed model.</S>
          <S ID="S-26310">Even if in the 5000 Best case, tree sequence is still able to contribute 1.1 BLEU score improvement (28.89-27.79).</S>
          <S ID="S-26311">It indicates the advantage of tree sequence cannot be covered by forest even if we utilize a very large forest.</S>
        </P>
        <P>
          <S ID="S-26312">2) The BLEU scores are very similar to each other when we increase the forest pruning threshold.</S>
          <S ID="S-26313">Moreover, in one case the performance even drops.</S>
          <S ID="S-26314">This suggests that although more parse trees in a forest can offer more structure information, they may also introduce more noise that may confuse the decoder.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>7 Conclusion</HEADER>
      <P>
        <S ID="S-26316">In this paper, we propose a forest-based treesequence to string translation model to combine the strengths of forest-based methods and treesequence based methods.</S>
        <S ID="S-26317">This enables our model to have the great potential to address the issues of structure divergence and parse errors for syntax-based SMT.</S>
        <S ID="S-26318">We convert our forest-based tree sequence rule extraction and decoding issues to tree-based by introducing virtual nodes, virtual hyper-edges and auxiliary rules (hyper-edges).</S>
        <S ID="S-26319">In our system implementation, we design a general and configurable platform for our method, based on which we can easily realize many previous syntax-based methods.</S>
        <S ID="S-26320">Finally, we examine our methods on the FBIS corpus and the NIST MT- 2003 Chinese-English translation task.</S>
        <S ID="S-26321">Experimental results show that our model greatly outperforms the four baseline systems.</S>
        <S ID="S-26322">Our study demonstrates that forest-based method and tree sequence-based method are complementary to each other and our proposed method is able to effectively combine the strengths of the two individual methods for syntax-based SMT.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>Acknowledgement</HEADER>
      <P>
        <S ID="S-26323">We would like to thank Huang Yun for preparing the pictures in this paper; Run Yan for providing the java version modified MERT program and discussion on the details of MOSES; Mi Haitao for his help and discussion on re-implementing the FT2S model; Sun Jun and Xiong Deyi for their valuable suggestions.</S>
      </P>
    </DIV>
  </BODY>
  <ACKNOWLEDGMENTS/>
  <REFERENCES>
    <REFERENCE ID="0">
      <RAUTHOR>Eugene Charniak</RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE>2000</DATE>
    </REFERENCE>
    <REFERENCE ID="1">
      <RAUTHOR>Jason Eisner</RAUTHOR>
      <REFTITLE>Learning non-isomorphic tree mappings for MT.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="2">
      <RAUTHOR>Michel Galley</RAUTHOR>
      <REFTITLE>What&#8217;s in a translation rule?</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="3">
      <RAUTHOR>Liang Huang</RAUTHOR>
      <REFTITLE>Forest Reranking: Discriminative Parsing with Non-Local Features.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="4">
      <RAUTHOR>Liang Huang</RAUTHOR>
      <REFTITLE>Forest rescoring: Faster decoding with integrated language models.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="5">
      <RAUTHOR></RAUTHOR>
      <REFTITLE>Statistical Syntax-Directed Translation with Extended Domain of Locality. AMTA-06. (poster) Reinhard Kenser and Hermann Ney.</REFTITLE>
      <DATE>1995</DATE>
    </REFERENCE>
    <REFERENCE ID="6">
      <RAUTHOR>Dan Klein</RAUTHOR>
      <REFTITLE>Parsing and Hypergraphs.</REFTITLE>
      <DATE>2001</DATE>
    </REFERENCE>
    <REFERENCE ID="7">
      <RAUTHOR>Philipp Koehn</RAUTHOR>
      <REFTITLE>Statistical phrase-based translation.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="8">
      <RAUTHOR>Philipp Koehn</RAUTHOR>
      <REFTITLE>Moses: Open Source Toolkit for Statistical Machine Translation.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="9">
      <RAUTHOR>Yang Liu</RAUTHOR>
      <REFTITLE>Tree-toString Alignment Template for Statistical Machine Translation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="10">
      <RAUTHOR>Yang Liu</RAUTHOR>
      <REFTITLE>Forest-to-String Statistical Translation Rules.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="11">
      <RAUTHOR>Haitao Mi</RAUTHOR>
      <REFTITLE>Forestbased translation.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="12">
      <RAUTHOR>Haitao Mi</RAUTHOR>
      <REFTITLE>Forest-based Translation Rule Extraction.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="13">
      <RAUTHOR>Franz J Och</RAUTHOR>
      <REFTITLE>Discriminative training and maximum entropy models for statistical machine translation.</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="14">
      <RAUTHOR>Franz J Och</RAUTHOR>
      <REFTITLE>Minimum error rate training in statistical machine translation.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="15">
      <RAUTHOR>Franz Josef Och</RAUTHOR>
      <REFTITLE>A Systematic Comparison of Various Statistical Alignment Models. Computational Linguistics.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="16">
      <RAUTHOR>Kishore Papineni</RAUTHOR>
      <REFTITLE>BLEU: a method for automatic evaluation of machine translation.</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="17">
      <RAUTHOR>Andreas Stolcke</RAUTHOR>
      <REFTITLE>SRILM - an extensible language modeling toolkit.</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="18">
      <RAUTHOR>Min Zhang</RAUTHOR>
      <REFTITLE>Ai Ti Aw, Jun Sun, Sheng Li and Chew Lim Tan.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="19">
      <RAUTHOR>Min Zhang</RAUTHOR>
      <REFTITLE>Hongfei Jiang, Aiti Aw,</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="20">
      <RAUTHOR>Min Zhang</RAUTHOR>
      <REFTITLE>Aiti Aw, Sheng Li.</REFTITLE>
      <DATE></DATE>
    </REFERENCE>
  </REFERENCES>
</PAPER>
