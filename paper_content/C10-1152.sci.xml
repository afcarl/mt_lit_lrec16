<PAPER>
  <FILENO/>
  <TITLE></TITLE>
  <AUTHORS/>
  <ABSTRACT/>
  <BODY>
    <DIV DEPTH="0">
      <HEADER>1 Introduction</HEADER>
      <P>
        <S ID="S-2206">Sentence simplification transforms long and difficult sentences into shorter and more readable ones.</S>
        <S ID="S-2207">This helps humans read texts more easily and faster.</S>
        <S ID="S-2208">Reading assistance is thus an important application of sentence simplification, especially for people with reading disabilities (Carroll et al., 1999; Inui et al., 2003), low-literacy readers (Watanabe et al., 2009), or non-native speakers (Siddharthan, 2002).</S>
      </P>
      <P>
        <S ID="S-2209">Not only human readers but also NLP applications can benefit from sentence simplification.</S>
        <S ID="S-2210">The original motivation for sentence simplification is using it as a preprocessor to facilitate parsing or translation tasks (Chandrasekar et al., 1996).</S>
        <S ID="S-2211">Complex sentences are considered as stumbling blocks for such systems.</S>
        <S ID="S-2212">More recently, sentence simplification has also been shown helpful for summarization (Knight and Marcu, 2000),</S>
      </P>
      <P>
        <S ID="S-2213">&#8727; This work has been supported by the Emmy Noether</S>
      </P>
      <P>
        <S ID="S-2214">Program of the German Research Foundation (DFG) under the grant No.</S>
        <S ID="S-2215">GU 798/3-1, and by the Volkswagen Foundation as part of the Lichtenberg-Professorship Program under the grant No.</S>
        <S ID="S-2216">I/82806.</S>
      </P>
      <P>
        <S ID="S-2217">sentence fusion (Filippova and Strube, 2008b), semantic role labeling (Vickrey and Koller, 2008), question generation (Heilman and Smith, 2009), paraphrase generation (Zhao et al., 2009) and biomedical information extraction (Jonnalagadda and Gonzalez, 2009).</S>
        <S ID="S-2218">At sentence level, reading difficulty stems either from lexical or syntactic complexity.</S>
        <S ID="S-2219">Sentence simplification can therefore be classified into two types: lexical simplification and syntactic simplification (Carroll et al., 1999).</S>
        <S ID="S-2220">These two types of simplification can be further implemented by a set of simplification operations.</S>
        <S ID="S-2221">Splitting, dropping, reordering, and substitution are widely accepted as important simplification operations.</S>
        <S ID="S-2222">The splitting operation splits a long sentence into several shorter sentences to decrease the complexity of the long sentence.</S>
        <S ID="S-2223">The dropping operation further removes unimportant parts of a sentence to make it more concise.</S>
        <S ID="S-2224">The reordering operation interchanges the order of the split sentences (Siddharthan, 2006) or parts in a sentence (Watanabe et al., 2009).</S>
        <S ID="S-2225">Finally, the substitution operation replaces difficult phrases or words with their simpler synonyms.</S>
        <S ID="S-2226">In most cases, different simplification operations happen simultaneously.</S>
        <S ID="S-2227">It is therefore necessary to consider the simplification process as a combination of different operations and treat them as a whole.</S>
        <S ID="S-2228">However, most of the existing models only consider one of these operations.</S>
        <S ID="S-2229">Siddharthan (2006) and Petersen and Ostendorf (2007) focus on sentence splitting, while sentence compression systems (Filippova and Strube, 2008a) mainly use the dropping operation.</S>
        <S ID="S-2230">As far as lexical simplification is concerned, word substitution is usually done by selecting simpler synonyms from Wordnet based on word frequency (Carroll et al., 1999).</S>
      </P>
      <P>
        <S ID="S-2231">In this paper, we propose a sentence simplification model by tree transformation which is based</S>
      </P>
      <P>
        <S ID="S-2232">on techniques from statistical machine translation (SMT) (Yamada and Knight, 2001; Yamada and Knight, 2002; Graehl et al., 2008).</S>
        <S ID="S-2233">Our model integrally covers splitting, dropping, reordering and phrase/word substitution.</S>
        <S ID="S-2234">The parameters of our model can be efficiently learned from complexsimple parallel datasets.</S>
        <S ID="S-2235">The transformation from a complex sentence to a simple sentence is conducted by applying a sequence of simplification operations.</S>
        <S ID="S-2236">An expectation maximization (EM) algorithm is used to iteratively train our model.</S>
        <S ID="S-2237">We also propose a method based on monolingual word mapping which speeds up the training process significantly.</S>
        <S ID="S-2238">Finally, a decoder is designed to generate the simplified sentences using a greedy strategy and integrates language models.</S>
      </P>
      <P>
        <S ID="S-2239">In order to train our model, we further compile a large-scale complex-simple parallel dataset (PWKP) from Simple English Wikipedia 1 and English Wikipedia 2 , as such datasets are rare.</S>
      </P>
      <P>
        <S ID="S-2240">We organize the remainder of the paper as follows: Section 2 describes the PWKP dataset.</S>
        <S ID="S-2241">Section 3 presents our TSM model.</S>
        <S ID="S-2242">Sections 4 and 5 are devoted to training and decoding, respectively.</S>
        <S ID="S-2243">Section 6 details the evaluation.</S>
        <S ID="S-2244">The conclusions follow in the final section.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>2 Wikipedia Dataset: PWKP</HEADER>
      <P>
        <S ID="S-2245">We collected a paired dataset from the English Wikipedia and Simple English Wikipedia.</S>
        <S ID="S-2246">The targeted audience of Simple Wikipedia includes &#8220;children and adults who are learning English language&#8221;.</S>
        <S ID="S-2247">The authors are requested to &#8220;use easy words and short sentences&#8221; to compose articles.</S>
        <S ID="S-2248">We processed the dataset as follows:</S>
      </P>
      <P>
        <S ID="S-2249">Article Pairing 65,133 articles from Simple Wikipedia 3 and Wikipedia 4 were paired by following the &#8220;language link&#8221; using the dump files in Wikimedia.</S>
        <S ID="S-2250">5 Administration articles were further removed.</S>
      </P>
      <P>
        <S ID="S-2251">Plain Text Extraction We use JWPL (Zesch et al., 2008) to extract plain texts from Wikipedia articles by removing specific Wiki tags.</S>
      </P>
      <P>
        <S ID="S-2252">Pre-processing including sentence boundary detection and tokenization with the Stanford</S>
      </P>
      <P>
        <S ID="S-2253">1 http://simple.wikipedia.org 2 http://en.wikipedia.org 3 As of Aug 17th, 2009 4 As of Aug 22nd, 2009 5 http://download.wikimedia.org</S>
      </P>
      <P>
        <S ID="S-2254">Parser package (Klein and Manning, 2003), and lemmatization with the TreeTagger (Schmid, 1994).</S>
      </P>
      <P>
        <S ID="S-2255">Monolingual Sentence Alignment As we need a parallel dataset aligned at the sentence level, we further applied monolingual sentence alignment on the article pairs.</S>
        <S ID="S-2256">In order to achieve the best sentence alignment on our dataset, we tested three similarity measures: (i) sentence-level TF*IDF (Nelken and Shieber, 2006), (ii) word overlap (Barzilay and Elhadad, 2003) and (iii) word-based maximum edit distance (MED) (Levenshtein, 1966) with costs of insertion, deletion and substitution set to 1.</S>
        <S ID="S-2257">To evaluate their performance we manually annotated 120 sentence pairs from the article pairs.</S>
        <S ID="S-2258">Tab.</S>
        <S ID="S-2259">1 reports the precision and recall of these three measures.</S>
        <S ID="S-2260">We manually adjusted the similarity threshold to obtain a recall value as close as possible to 55.8% which was previously adopted by Nelken and Shieber (2006).</S>
      </P>
      <P>
        <S ID="S-2261">Similarity Precision Recall TF*IDF 91.3% 55.4% Word Overlap 50.5% 55.1% MED 13.9% 54.7%</S>
      </P>
      <P>
        <S ID="S-2262">In order to account for sentence splitting, we allow 1 to n sentence alignment to map one complex sentence to several simple sentences.</S>
        <S ID="S-2263">We first perform 1 to 1 mapping with sentence-level TF*IDF and then combine the pairs with the same complex sentence and adjacent simple sentences.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>3 The Simplification Model: TSM</HEADER>
      <P>
        <S ID="S-2403">We apply the following simplification operations to the parse tree of a complex sentence: splitting,</S>
      </P>
      <P>
        <S ID="S-2404">dropping, reordering and substitution.</S>
        <S ID="S-2405">In this section, we use a running example to illustrate this process.</S>
        <S ID="S-2406">c is the complex sentence to be simplified in our example.</S>
        <S ID="S-2407">Fig.</S>
        <S ID="S-2408">1 shows the parse tree of c (we skip the POS level).</S>
        <S ID="S-2409">c: August was the sixth month in the ancient Roman calendar which started in 735BC.</S>
      </P>
      <P>
        <S ID="S-2410">NP</S>
      </P>
      <P>
        <S ID="S-2411">August was</S>
      </P>
      <P>
        <S ID="S-2412">S</S>
      </P>
      <P>
        <S ID="S-2413">NP</S>
      </P>
      <P>
        <S ID="S-2414">VP</S>
      </P>
      <P>
        <S ID="S-2415">the sixth month in</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>3.1 Splitting</HEADER>
        <P>
          <S ID="S-2264">NP</S>
        </P>
        <P>
          <S ID="S-2265">PP</S>
        </P>
        <P>
          <S ID="S-2266">NP</S>
        </P>
        <P>
          <S ID="S-2267">SBAR</S>
        </P>
        <P>
          <S ID="S-2268">WHNP</S>
        </P>
        <P>
          <S ID="S-2269">the ancient Roman calendar which VP</S>
        </P>
        <P>
          <S ID="S-2270">started PP</S>
        </P>
        <P>
          <S ID="S-2271">in 735BC</S>
        </P>
        <P>
          <S ID="S-2272">The first operation is sentence splitting, which we further decompose into two subtasks: (i) segmentation, which decides where and whether to split a sentence and (ii) completion, which makes the new split sentences complete.</S>
        </P>
        <P>
          <S ID="S-2273">First, we decide where we can split a sentence.</S>
          <S ID="S-2274">In our model, the splitting point is judged by the syntactic constituent of the split boundary word in the complex sentence.</S>
          <S ID="S-2275">The decision whether a sentence should be split is based on the length of the complex sentence.</S>
          <S ID="S-2276">The features used in the segmentation step are shown in Tab.</S>
          <S ID="S-2277">3.</S>
        </P>
        <P>
          <S ID="S-2278">Actually, we do not use the direct constituent of a word in the parse tree.</S>
          <S ID="S-2279">In our example, the direct constituent of the word &#8220;which&#8221; is &#8220;WHNP&#8221;.</S>
          <S ID="S-2280">Instead, we use Alg.</S>
          <S ID="S-2281">1 to calculate the constituent of a word.</S>
          <S ID="S-2282">Alg.</S>
          <S ID="S-2283">1 returns &#8220;SBAR&#8221; as the adjusted constituent for &#8220;which&#8221;.</S>
          <S ID="S-2284">Moreover, directly using the length of the complex sentence is affected by the data sparseness problem.</S>
          <S ID="S-2285">Instead, we use iLength as the feature which is calculated as iLength = ceiling( comLength avgSimLength ), where comLength is the length of the complex sentence and avgSimLength is the average length of simple sentences in the training dataset.</S>
          <S ID="S-2286">The &#8220;Prob.&#8221; column shows the probabilities obtained after training on our dataset.</S>
        </P>
        <P>
          <S ID="S-2287">S</S>
        </P>
        <P>
          <S ID="S-2288">Algorithm 1 adjustConstituent(word, tree)</S>
        </P>
        <P>
          <S ID="S-2289">constituent &#8592; word.father; father &#8592; constituent.father; while father &#8800; NULL AND constituent is the most left child of father do</S>
        </P>
        <P>
          <S ID="S-2290">constituent &#8592; father; father &#8592; father.father;</S>
        </P>
        <P>
          <S ID="S-2291">end while return constituent;</S>
        </P>
        <P>
          <S ID="S-2292">In our model, one complex sentence can be split into two or more sentences.</S>
          <S ID="S-2293">Since many splitting operations are possible, we need to select the most likely one.</S>
          <S ID="S-2294">The probability of a segmentation operation is calculated as:</S>
        </P>
        <P>
          <S ID="S-2295">P (seg|c) = &#8719; w:c SF T (w|c) (1)</S>
        </P>
        <P>
          <S ID="S-2296">where w is a word in the complex sentence c and SF T (w|c) is the probability of the word w in the Segmentation Feature Table (SFT); Fig.</S>
          <S ID="S-2297">2 shows a possible segmentation result of our example.</S>
        </P>
        <P>
          <S ID="S-2298">NP</S>
        </P>
        <P>
          <S ID="S-2299">August was</S>
        </P>
        <P>
          <S ID="S-2300">S</S>
        </P>
        <P>
          <S ID="S-2301">NP</S>
        </P>
        <P>
          <S ID="S-2302">VP</S>
        </P>
        <P>
          <S ID="S-2303">the sixth month in NP</S>
        </P>
        <P>
          <S ID="S-2304">PP</S>
        </P>
        <P>
          <S ID="S-2305">NP</S>
        </P>
        <P>
          <S ID="S-2306">SBAR</S>
        </P>
        <P>
          <S ID="S-2307">WHNP</S>
        </P>
        <P>
          <S ID="S-2308">the ancient Roman calendar S</S>
        </P>
        <P>
          <S ID="S-2309">which VP</S>
        </P>
        <P>
          <S ID="S-2310">started PP</S>
        </P>
        <P>
          <S ID="S-2311">in 735BC</S>
        </P>
        <P>
          <S ID="S-2312">Const.</S>
          <S ID="S-2313">Word isDropped Prob.</S>
          <S ID="S-2314">WHNP which True 1.0 WHNP which False Prob.Min</S>
        </P>
        <P>
          <S ID="S-2315">In order to copy the necessary parts to complete the new sentences, we must decide which parts should be copied and where to put these parts in the new sentences.</S>
          <S ID="S-2316">In our model, this is judged by two features: the dependency relation and the constituent.</S>
          <S ID="S-2317">We use the Stanford Parser for parsing the dependencies.</S>
          <S ID="S-2318">In our example, the de-</S>
        </P>
        <P>
          <S ID="S-2319">For dependent NPs, we copy the whole NP phrase rather than only the head noun.</S>
          <S ID="S-2320">7 In our example, we copy the whole NP phrase &#8220;the ancient Roman calendar&#8221; to the new position rather than only the word &#8220;calendar&#8221;.</S>
          <S ID="S-2321">The probability of a completion operation can be calculated as</S>
        </P>
        <P>
          <S ID="S-2322">P (com|seg) = Y bw:s BDF T (bw|s) Y w:s Y</S>
        </P>
        <P>
          <S ID="S-2323">dep:w</S>
        </P>
        <P>
          <S ID="S-2324">CF T (dep).</S>
        </P>
        <P>
          <S ID="S-2325">where s are the split sentences, bw is a border word in s, w is a word in s, dep is a dependency of w which is out of the scope of s. Fig.</S>
          <S ID="S-2326">3 shows the most likely result of the completion operation for our example.</S>
        </P>
        <P>
          <S ID="S-2327">NP</S>
        </P>
        <P>
          <S ID="S-2328">August was</S>
        </P>
        <P>
          <S ID="S-2329">pt1</S>
        </P>
        <P>
          <S ID="S-2330">NP pt2 PP</S>
        </P>
        <P>
          <S ID="S-2331">the sixth month in NP VP NP started PP the ancient Roman calendar</S>
        </P>
        <P>
          <S ID="S-2332">the ancient Roman calendar in 735BC</S>
        </P>
        <P>
          <S ID="S-2333">VP</S>
        </P>
        <P>
          <S ID="S-2334">NP</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.2 Dropping and Reordering</HEADER>
        <P>
          <S ID="S-2335">6 With Stanford Parser, &#8220;which&#8221; is a referent of &#8220;calender&#8221;</S>
        </P>
        <P>
          <S ID="S-2336">and the nsubj of &#8220;started&#8221;.</S>
          <S ID="S-2337">&#8220;calender&#8221; thus can be considered to be the nsubj of &#8220;started&#8221; with &#8220;started&#8221; as the governor.</S>
          <S ID="S-2338">7 The copied NP phrase can be further simplified in the</S>
        </P>
        <P>
          <S ID="S-2339">following steps.</S>
        </P>
        <P>
          <S ID="S-2340">The bits &#8216;1&#8217; and &#8216;0&#8217; in the &#8220;Drop&#8221; column indicate whether the corresponding constituent is retained or dropped.</S>
          <S ID="S-2341">The number in the &#8220;Reorder&#8221; column represents the new order for the children.</S>
          <S ID="S-2342">The probabilities of the dropping and reordering operations can be calculated as Equ.</S>
          <S ID="S-2343">2 and Equ.</S>
          <S ID="S-2344">3.</S>
        </P>
        <P>
          <S ID="S-2345">P (dp|node) = DF T (node) (2)</S>
        </P>
        <P>
          <S ID="S-2346">P (ro|node) = RF T (node) (3)</S>
        </P>
        <P>
          <S ID="S-2347">In our example, one of the possible results is dropping the NNP &#8220;Roman&#8221;, as shown in Fig.</S>
          <S ID="S-2348">4.</S>
        </P>
        <P>
          <S ID="S-2349">the ancient NP</S>
        </P>
        <P>
          <S ID="S-2350">NP</S>
        </P>
        <P>
          <S ID="S-2351">August was</S>
        </P>
        <P>
          <S ID="S-2352">pt1</S>
        </P>
        <P>
          <S ID="S-2353">VP</S>
        </P>
        <P>
          <S ID="S-2354">NP</S>
        </P>
        <P>
          <S ID="S-2355">NP pt2 PP</S>
        </P>
        <P>
          <S ID="S-2356">the sixth month in NP VP</S>
        </P>
        <P>
          <S ID="S-2357">started PP the ancient calendar</S>
        </P>
        <P>
          <S ID="S-2358">calendar in 735BC</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.3 Substitution</HEADER>
        <P>
          <S ID="S-2359">3.3.1 Word Substitution Word substitution only happens on the terminal nodes of the parse tree.</S>
          <S ID="S-2360">In our model, the conditioning features include the original word and the substitution.</S>
          <S ID="S-2361">The substitution for a word can be another word or a multi-word expression (see Tab.</S>
          <S ID="S-2362">8).</S>
          <S ID="S-2363">The probability of a word substitution operation can be calculated as P (sub|w) = SubF T (Substitution|Origin).</S>
        </P>
        <P>
          <S ID="S-2364">3.3.2 Phrase Substitution</S>
        </P>
        <P>
          <S ID="S-2365">Phrase substitution happens on the nonterminal nodes and uses the same conditioning features as word substitution.</S>
          <S ID="S-2366">The &#8220;Origin&#8221; consists of the leaves of the subtree rooted at the node.</S>
          <S ID="S-2367">When we apply phrase substitution on a non-terminal node, then any simplification operation (including dropping, reordering and substitution) cannot happen on its descendants any more</S>
        </P>
        <P>
          <S ID="S-2368">because when a node has been replaced then its descendants are no longer existing.</S>
          <S ID="S-2369">Therefore, for each non-terminal node we must decide whether a substitution should take place at this node or at its descendants.</S>
          <S ID="S-2370">We perform substitution for a nonterminal node if the following constraint is met:</S>
        </P>
        <P>
          <S ID="S-2371">Max(SubF T (&#8727;|node)) &#8805; Y</S>
        </P>
        <P>
          <S ID="S-2372">ch:node</S>
        </P>
        <P>
          <S ID="S-2373">Max(SubF T (&#8727;|ch)).</S>
        </P>
        <P>
          <S ID="S-2374">where ch is a child of the node.</S>
          <S ID="S-2375">&#8220;&#8727;&#8221; can be any substitution in the SubFT.</S>
          <S ID="S-2376">The probability of the phrase substitution is calculated as P (sub|node) = SubF T (Substitution|Origin).</S>
          <S ID="S-2377">Fig.</S>
          <S ID="S-2378">5 shows one of the possible substitution results for our example where &#8220;ancient&#8221; is replaced by &#8220;old&#8221;.</S>
        </P>
        <P>
          <S ID="S-2379">the old</S>
        </P>
        <P>
          <S ID="S-2380">NP</S>
        </P>
        <P>
          <S ID="S-2381">NP</S>
        </P>
        <P>
          <S ID="S-2382">August was</S>
        </P>
        <P>
          <S ID="S-2383">pt1</S>
        </P>
        <P>
          <S ID="S-2384">VP</S>
        </P>
        <P>
          <S ID="S-2385">NP</S>
        </P>
        <P>
          <S ID="S-2386">NP pt2 PP</S>
        </P>
        <P>
          <S ID="S-2387">the sixth month in VP</S>
        </P>
        <P>
          <S ID="S-2388">started PP the old</S>
        </P>
        <P>
          <S ID="S-2389">calendar in 735BC</S>
        </P>
        <P>
          <S ID="S-2390">NP</S>
        </P>
        <P>
          <S ID="S-2391">calendar</S>
        </P>
        <P>
          <S ID="S-2392">As a result of all the simplification operations, we obtain the following two sentences: s1 = Str(pt1)=&#8220;August was the sixth month in the old calendar.&#8221; and s2 = Str(pt2)=&#8220;The old calendar started in 735BC.&#8221;</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.4 The Probabilistic Model</HEADER>
        <P>
          <S ID="S-2393">Our model can be formalized as a direct translation model from complex to simple P (s|c) multiplied by a language model P (s) as shown in Equ.</S>
          <S ID="S-2394">4. s = argmax P (s|c)P (s) (4)</S>
        </P>
        <P>
          <S ID="S-2395">s</S>
        </P>
        <P>
          <S ID="S-2396">We combine the parts described in the previous sections to get the direct translation model: &#8721; P (s|c) = (P (seg|c)P (com|seg)</S>
        </P>
        <P>
          <S ID="S-2397">&#952;:Str(&#952;(c))=s</S>
        </P>
        <P>
          <S ID="S-2398">node</S>
        </P>
        <P>
          <S ID="S-2399">&#8719; (sub|w)).</S>
        </P>
        <P>
          <S ID="S-2400">w</S>
        </P>
        <P>
          <S ID="S-2401">where &#952; is a sequence of simplification operations and Str(&#952;(c)) corresponds to the leaves of a simplified tree.</S>
          <S ID="S-2402">There can be many sequences of operations that result in the same simplified sentence and we sum up all of their probabilities.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>4 Training</HEADER>
      <P>
        <S ID="S-2416">In this section, we describe how we train the probabilities in the tables.</S>
        <S ID="S-2417">Following the work of Yamada and Knight (2001), we train our model by maximizing P (s|c) over the training corpus with the EM algorithm described in Alg.</S>
        <S ID="S-2418">2, using a constructed graph structure.</S>
        <S ID="S-2419">We develop the Training Tree (Fig.</S>
        <S ID="S-2420">6) to calculate P (s|c).</S>
        <S ID="S-2421">P (s|c) is equal to the inside probability of the root in the Training Tree.</S>
        <S ID="S-2422">Alg.</S>
        <S ID="S-2423">3 and Alg.</S>
        <S ID="S-2424">4 are used to calculate the inside and outside probabilities.</S>
        <S ID="S-2425">We refer readers to Yamada and Knight (2001) for more details.</S>
        <S ID="S-2426">Algorithm 2 EM Training (dataset)</S>
      </P>
      <P>
        <S ID="S-2427">Initialize all probability tables using the uniform distribution; for several iterations do</S>
      </P>
      <P>
        <S ID="S-2428">reset all cnt = 0; for each sentence pair &lt; c, s &gt; in dataset do</S>
      </P>
      <P>
        <S ID="S-2429">tt = buildTrainingTree(&lt; c, s &gt;); calcInsideProb(tt); calcOutsideProb(tt); update cnt for each conditioning feature in each node of tt: cnt = cnt + node.insideP rob &#8727; node.outsideP rob/root.insideP rob; end for updateProbability();</S>
      </P>
      <P>
        <S ID="S-2430">end for</S>
      </P>
      <P>
        <S ID="S-2431">(5) Figure 6: Training Tree (Left) and Decoding Tree &#8719; (Right) P (dp|node)P (ro|node)P (sub|node)</S>
      </P>
      <P>
        <S ID="S-2432">sp_res1</S>
      </P>
      <P>
        <S ID="S-2433">mp_res</S>
      </P>
      <P>
        <S ID="S-2434">sub</S>
      </P>
      <P>
        <S ID="S-2435">root</S>
      </P>
      <P>
        <S ID="S-2436">sp</S>
      </P>
      <P>
        <S ID="S-2437">mp_res1</S>
      </P>
      <P>
        <S ID="S-2438">dp</S>
      </P>
      <P>
        <S ID="S-2439">ro</S>
      </P>
      <P>
        <S ID="S-2440">mp</S>
      </P>
      <P>
        <S ID="S-2441">sp_res2</S>
      </P>
      <P>
        <S ID="S-2442">sub</S>
      </P>
      <P>
        <S ID="S-2443">dp</S>
      </P>
      <P>
        <S ID="S-2444">ro</S>
      </P>
      <P>
        <S ID="S-2445">mp</S>
      </P>
      <P>
        <S ID="S-2446">mp_res</S>
      </P>
      <P>
        <S ID="S-2447">mp_res2</S>
      </P>
      <P>
        <S ID="S-2448">sub</S>
      </P>
      <P>
        <S ID="S-2449">sp_res</S>
      </P>
      <P>
        <S ID="S-2450">ro_res</S>
      </P>
      <P>
        <S ID="S-2451">sub</S>
      </P>
      <P>
        <S ID="S-2452">sub_res</S>
      </P>
      <P>
        <S ID="S-2453">root</S>
      </P>
      <P>
        <S ID="S-2454">sp</S>
      </P>
      <P>
        <S ID="S-2455">ro_res</S>
      </P>
      <P>
        <S ID="S-2456">dp</S>
      </P>
      <P>
        <S ID="S-2457">ro</S>
      </P>
      <P>
        <S ID="S-2458">sp_res</S>
      </P>
      <P>
        <S ID="S-2459">sub</S>
      </P>
      <P>
        <S ID="S-2460">dp</S>
      </P>
      <P>
        <S ID="S-2461">ro</S>
      </P>
      <P>
        <S ID="S-2462">ro_res</S>
      </P>
      <P>
        <S ID="S-2463">sub_res</S>
      </P>
      <P>
        <S ID="S-2464">ro_res</S>
      </P>
      <P>
        <S ID="S-2465">sub</S>
      </P>
      <P>
        <S ID="S-2466">sub_res</S>
      </P>
      <P>
        <S ID="S-2467">We illustrate the construction of the training tree with our running example.</S>
        <S ID="S-2468">There are two kinds of nodes in the training tree: data nodes in rectangles and operation nodes in circles.</S>
        <S ID="S-2469">Data nodes contain data and operation nodes execute operations.</S>
        <S ID="S-2470">The training is a supervised learning</S>
      </P>
      <P>
        <S ID="S-2471">process with the parse tree of c as input and the two strings s1 and s2 as the desired output.</S>
        <S ID="S-2472">root stores the parse tree of c and also s1 and s2.</S>
        <S ID="S-2473">sp, ro, mp and sub are splitting, reordering, mapping and substitution operations.</S>
        <S ID="S-2474">sp res and mp res store the results of sp and mp.</S>
        <S ID="S-2475">In our example, sp splits the parse tree into two parse trees pt1 and pt2 (Fig.</S>
        <S ID="S-2476">3).</S>
        <S ID="S-2477">sp res1 contains pt1 and s1.</S>
        <S ID="S-2478">sp res2 contains pt2 and s2.</S>
        <S ID="S-2479">Then dp, ro and mp are iteratively applied to each non-terminal node at each level of pt1 and pt2 from top to down.</S>
        <S ID="S-2480">This process continues until the terminal nodes are reached or is stopped by a sub node.</S>
        <S ID="S-2481">The function of mp operation is similar to the word mapping operation in the string-based machine translation.</S>
        <S ID="S-2482">It maps substrings in the complex sentence which are dominated by the children of the current node to proper substrings in the simple sentences.</S>
      </P>
      <P>
        <S ID="S-2483">Speeding Up The example above is only one of the possible paths.</S>
        <S ID="S-2484">We try all of the promising paths in training.</S>
        <S ID="S-2485">Promising paths are the paths which are likely to succeed in transforming the parse tree of c into s1 and s2.</S>
        <S ID="S-2486">We select the promising candidates using monolingual word mapping as shown in Fig.</S>
        <S ID="S-2487">7.</S>
        <S ID="S-2488">In this example, only the word &#8220;which&#8221; can be a promising candidate for splitting.</S>
        <S ID="S-2489">We can select the promising candidates for the dropping, reordering and mapping operations similarly.</S>
        <S ID="S-2490">With this improvement, we can train on the PWKP dataset within 1 hour excluding the parsing time taken by the Stanford Parser.</S>
      </P>
      <P>
        <S ID="S-2491">We initialize the probabilities with the uniform distribution.</S>
        <S ID="S-2492">The binary features, such as SFT and BDFT, are assigned the initial value of 0.5.</S>
        <S ID="S-2493">For DFT and RFT, the initial probability is 1 N!</S>
        <S ID="S-2494">, where N is the number of the children.</S>
        <S ID="S-2495">CFT is initialized as 0.25.</S>
        <S ID="S-2496">SubFT is initialized as 1.0 for any substitution at the first iteration.</S>
        <S ID="S-2497">After each iteration, the updateP robability function recalculates these probabilities based on the cnt for each feature.</S>
      </P>
      <P>
        <S ID="S-2498">Algorithm 3 calcInsideProb (TrainingTree tt)</S>
      </P>
      <P>
        <S ID="S-2499">for each node from level = N to root of tt do if node is a sub node then</S>
      </P>
      <P>
        <S ID="S-2500">node.insideP rob = P (sub|node); else if node is a mp OR sp node then</S>
      </P>
      <P>
        <S ID="S-2501">node.insideP rob = Q child child.insideP rob;</S>
      </P>
      <P>
        <S ID="S-2502">else</S>
      </P>
      <P>
        <S ID="S-2503">end if end for</S>
      </P>
      <P>
        <S ID="S-2504">node.insideP rob = P child child.insideP rob;</S>
      </P>
      <P>
        <S ID="S-2505">Algorithm 4 calcOutsideProb (TrainingTree tt)</S>
      </P>
      <P>
        <S ID="S-2506">for each node from root to level = N of tt do if node is the root then</S>
      </P>
      <P>
        <S ID="S-2507">node.outsideP rob = 1.0; else if node is a sp res OR mp res node then</S>
      </P>
      <P>
        <S ID="S-2508">{COMMENT: father are the fathers of the current node, sibling are the children of father excluding the current node} node.outsideP rob = P father father.outsideP rob &#8727; Q sibling sibling.insideP rob;</S>
      </P>
      <P>
        <S ID="S-2509">else if node is a mp node then</S>
      </P>
      <P>
        <S ID="S-2510">node.outsideP rob = father.outsideP rob &#8727; 1.0; else if node is a sp, ro, dp or sub node then</S>
      </P>
      <P>
        <S ID="S-2511">node.outsideP rob = father.outsideP rob &#8727; P (sp or ro or dp or sub|node);</S>
      </P>
      <P>
        <S ID="S-2512">end if end for</S>
      </P>
      <P>
        <S ID="S-2513">Complex sentence</S>
      </P>
      <P>
        <S ID="S-2514">August was the sixth monthin the ancient Roman calendar which stated in 735BC .</S>
      </P>
      <P>
        <S ID="S-2515">August was the sixth month in the old Roman calendar.</S>
        <S ID="S-2516">The old calendar stated in 735BC .</S>
      </P>
      <P>
        <S ID="S-2517">Simple sentences</S>
      </P>
      <P>
        <S ID="S-2518">For decoding, we construct the decoding tree (Fig.</S>
        <S ID="S-2519">6) similarly to the construction of the training tree.</S>
        <S ID="S-2520">The decoding tree does not have mp operations and there can be more than one sub nodes attached to a single ro res.</S>
        <S ID="S-2521">The root contains the parse tree of the complex sentence.</S>
        <S ID="S-2522">Due to space limitations, we cannot provide all the details of the decoder.</S>
        <S ID="S-2523">We calculate the inside probability and outside probability for each node in the decoding tree.</S>
        <S ID="S-2524">When we simplify a complex sentence, we start from the root and greedily select the branch with the highest outside probability.</S>
        <S ID="S-2525">For the substitution operation, we also integrate a trigram language model to make the generated sentences more fluent.</S>
        <S ID="S-2526">We train the language model with SRILM (Stolcke, 2002).</S>
        <S ID="S-2527">All the articles from the Simple Wikipedia are used as the training corpus, amounting to about 54 MB.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>6 Evaluation</HEADER>
      <P>
        <S ID="S-2601">Our evaluation dataset consists of 100 complex sentences and 131 parallel simple sentences from PWKP.</S>
        <S ID="S-2602">They have not been used for training.</S>
        <S ID="S-2603">Four baseline systems are compared in our evaluation.</S>
        <S ID="S-2604">The first is Moses which is a state of the art SMT system widely used as a baseline in MT community.</S>
        <S ID="S-2605">Obviously, the purpose of Moses is cross-lingual translation rather than monolin-</S>
      </P>
      <P>
        <S ID="S-2606">gual simplification.</S>
        <S ID="S-2607">The goal of our comparison is therefore to assess how well a standard SMT system may perform simplification when fed with a proper training dataset.</S>
        <S ID="S-2608">We train Moses with the same part of PWKP as our model.</S>
        <S ID="S-2609">The second baseline system is a sentence compression system (Filippova and Strube, 2008a) whose demo system is available online.</S>
        <S ID="S-2610">8 As the compression system can only perform dropping, we further extend it to our third and fourth baseline systems, in order to make a reasonable comparison.</S>
        <S ID="S-2611">In our third baseline system, we substitute the words in the output of the compression system with their simpler synonyms.</S>
        <S ID="S-2612">This is done by looking up the synonyms in Wordnet and selecting the most frequent synonym for replacement.</S>
        <S ID="S-2613">The word frequency is counted using the articles from Simple Wikipedia.</S>
        <S ID="S-2614">The fourth system performs sentence splitting on the output of the third system.</S>
        <S ID="S-2615">This is simply done by splitting the sentences at &#8220;and&#8221;, &#8220;or&#8221;, &#8220;but&#8221;, &#8220;which&#8221;, &#8220;who&#8221; and &#8220;that&#8221;, and discarding the border words.</S>
        <S ID="S-2616">In total, there are 5 systems in our evaluation: Moses, the MT system; C, the compression system; CS, the compression+substitution system; CSS, the compression+substitution+split system; TSM, our model.</S>
        <S ID="S-2617">We also provide evaluation measures for the sentences in the evaluation dataset: CW: complex sentences from Normal Wikipedia and SW: parallel simple sentences from Simple Wikipedia.</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>6.1 Basic Statistics and Examples</HEADER>
        <P>
          <S ID="S-2528">The first three columns in Tab.</S>
          <S ID="S-2529">9 present the basic statistics for the evaluation sentences and the output of the five systems.</S>
          <S ID="S-2530">tokenLen is the average length of tokens which may roughly reflect the lexical difficulty.</S>
          <S ID="S-2531">TSM achieves an average token length which is the same as the Simple Wikipedia (SW).</S>
          <S ID="S-2532">senLen is the average number of tokens in one sentence, which may roughly reflect the syntactic complexity.</S>
          <S ID="S-2533">Both TSM and CSS produce shorter sentences than SW.</S>
          <S ID="S-2534">Moses is very close to CW.</S>
          <S ID="S-2535">#sen gives the number of sentences.</S>
          <S ID="S-2536">Moses, C and CS cannot split sentences and thus produce about the same number of sentences as available in CW.</S>
          <S ID="S-2537">Here are two example results obtained with our TSM system.</S>
          <S ID="S-2538">Example 1.</S>
          <S ID="S-2539">CW: &#8220;Genetic engineering has expanded the genes available to breeders to utilize in creating desired germlines for new crops.&#8221; SW:</S>
        </P>
        <P>
          <S ID="S-2540">8 http://212.126.215.106/compression/</S>
        </P>
        <P>
          <S ID="S-2541">&#8220;New plants were created with genetic engineering.&#8221; TSM: &#8220;Engineering has expanded the genes available to breeders to use in making germlines for new crops.&#8221; Example 2.</S>
          <S ID="S-2542">CW: &#8220;An umbrella term is a word that provides a superset or grouping of related concepts, also called a hypernym.&#8221; SW: &#8220;An umbrella term is a word that provides a superset or grouping of related concepts.&#8221; TSM: &#8220;An umbrella term is a word.</S>
          <S ID="S-2543">A word provides a superset of related concepts, called a hypernym.&#8221; In the first example, both substitution and dropping happen.</S>
          <S ID="S-2544">TSM replaces &#8220;utilize&#8221; and &#8220;creating&#8221; with &#8220;use&#8221; and &#8220;making&#8221;.</S>
          <S ID="S-2545">&#8220;Genetic&#8221; is dropped.</S>
          <S ID="S-2546">In the second example, the complex sentence is split and &#8220;also&#8221; is dropped.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>6.2 Translation Assessment</HEADER>
        <P>
          <S ID="S-2547">In this part of the evaluation, we use traditional measures used for evaluating MT systems.</S>
          <S ID="S-2548">Tab.</S>
          <S ID="S-2549">9 shows the BLEU and NIST scores.</S>
          <S ID="S-2550">We use &#8220;mteval-v11b.pl&#8221; 9 as the evaluation tool.</S>
          <S ID="S-2551">CW and SW are used respectively as source and reference sentences.</S>
          <S ID="S-2552">TSM obtains a very high BLEU score (0.38) but not as high as Moses (0.55).</S>
          <S ID="S-2553">However, the original complex sentences (CW) from Normal Wikipedia get a rather high BLEU (0.50), when compared to the simple sentences.</S>
          <S ID="S-2554">We also find that most of the sentences generated by Moses are exactly the same as those in CW: this shows that Moses only performs few modifications to the original complex sentences.</S>
          <S ID="S-2555">This is confirmed by MT evaluation measures: if we set CW as both source and reference, the BLEU score obtained by Moses is 0.78.</S>
          <S ID="S-2556">TSM gets 0.55 in the same setting which is significantly smaller than Moses and demonstrates that TSM is able to generate simplifications with a greater amount of variation from the original sentence.</S>
          <S ID="S-2557">As shown in the &#8220;#Same&#8221; column of Tab.</S>
          <S ID="S-2558">9, 25 sentences generated by Moses are exactly identical to the complex sentences, while the number for TSM is 2 which is closer to SW.</S>
          <S ID="S-2559">It is however not clear how well BLEU and NIST discriminate simplification systems.</S>
          <S ID="S-2560">As discussed in Jurafsky and Martin (2008), &#8220;BLEU does poorly at comparing systems with radically different architectures and is most appropriate when evaluating incremental changes with similar architectures.&#8221; In our case, TSM and CSS can be considered as having similar architectures as both of them can do splitting, dropping</S>
        </P>
        <P>
          <S ID="S-2561">9 http://www.statmt.org/moses/</S>
        </P>
        <P>
          <S ID="S-2562">and substitution.</S>
          <S ID="S-2563">But Moses mostly cannot split and drop.</S>
          <S ID="S-2564">We may conclude that TSM and Moses have different architectures and BLEU or NIST is not suitable for comparing them.</S>
          <S ID="S-2565">Here is an example to illustrate this: (CW): &#8220;Almost as soon as he leaves, Annius and the guard Publius arrive to escort Vitellia to Titus, who has now chosen her as his empress.&#8221; (SW): &#8220;Almost as soon as he leaves, Annius and the guard Publius arrive to take Vitellia to Titus, who has now chosen her as his empress.&#8221; (Moses): The same as (SW).</S>
          <S ID="S-2566">(TSM): &#8220;Annius and the guard Publius arrive to take Vitellia to Titus.</S>
          <S ID="S-2567">Titus has now chosen her as his empress.&#8221; In this example, Moses generates an exactly identical sentence to SW, thus the BLUE and NIST scores of Moses is the highest.</S>
          <S ID="S-2568">TSM simplifies the complex sentence by dropping, splitting and substitution, which results in two sentences that are quite different from the SW sentence and thus gets lower BLUE and NIST scores.</S>
          <S ID="S-2569">Nevertheless, the sentences generated by TSM seem better than Moses in terms of simplification.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>6.3 Readability Assessment</HEADER>
        <P>
          <S ID="S-2570">Intuitively, readability scores should be suitable metrics for simplification systems.</S>
          <S ID="S-2571">We use the Linux &#8220;style&#8221; command to calculate the Flesch and Lix readability scores.</S>
          <S ID="S-2572">The results are presented in Tab.</S>
          <S ID="S-2573">9.</S>
          <S ID="S-2574">&#8220;PE&#8221; in the Flesch column stands for &#8220;Plain English&#8221; and the &#8220;Grade&#8221; in Lix represents the school year.</S>
          <S ID="S-2575">TSM achieves significantly better scores than Moses which has the best BLEU score.</S>
          <S ID="S-2576">This implies that good monolingual translation is not necessarily good simplification.</S>
          <S ID="S-2577">OOV is the percentage of words that are not in the Basic English BE850 list.</S>
          <S ID="S-2578">10 TSM is ranked as the second best system for this criterion.</S>
        </P>
        <P>
          <S ID="S-2579">The perplexity (PPL) is a score of text probability measured by a language model and normalized by the number of words in the text (Equ.</S>
          <S ID="S-2580">6).</S>
        </P>
        <P>
          <S ID="S-2581">10 http://simple.wikipedia.org/wiki/</S>
        </P>
        <P>
          <S ID="S-2582">Wikipedia:Basic_English_alphabetical_ wordlist</S>
        </P>
        <P>
          <S ID="S-2583">PPL can be used to measure how tight the language model fits the text.</S>
          <S ID="S-2584">Language models constitute an important feature for assessing readability (Schwarm and Ostendorf, 2005).</S>
          <S ID="S-2585">We train a trigram LM using the simple sentences in PWKP and calculate the PPL with SRILM.</S>
          <S ID="S-2586">TSM gets the best PPL score.</S>
          <S ID="S-2587">From this table, we can conclude that TSM achieves better overall readability than the baseline systems.</S>
        </P>
        <P>
          <S ID="S-2588">P P L(text) = P (w 1 w 2 ...w N ) &#8722; 1 N (6)</S>
        </P>
        <P>
          <S ID="S-2589">There are still some important issues to be considered in future.</S>
          <S ID="S-2590">Based on our observations, the current model performs well for word substitution and segmentation.</S>
          <S ID="S-2591">But the completion of the new sentences is still problematic.</S>
          <S ID="S-2592">For example, we copy the dependent NP to the new sentences.</S>
          <S ID="S-2593">This may break the coherence between sentences.</S>
          <S ID="S-2594">A better solution would be to use a pronoun to replace the NP.</S>
          <S ID="S-2595">Sometimes, excessive droppings occur, e.g., &#8220;older&#8221; and &#8220;twin&#8221; are dropped in &#8220;She has an older brother and a twin brother...&#8221;.</S>
          <S ID="S-2596">This results in a problematic sentence: &#8220;She has an brother and a brother...&#8221;.</S>
          <S ID="S-2597">There are also some errors which stem from the dependency parser.</S>
          <S ID="S-2598">In Example 2, &#8220;An umbrella term&#8221; should be a dependency of &#8220;called&#8221;.</S>
          <S ID="S-2599">But the parser returns &#8220;superset&#8221; as the dependency.</S>
          <S ID="S-2600">In the future, we will investigate more sophisticated features and rules to enhance TSM.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>7 Conclusions</HEADER>
      <P>
        <S ID="S-2618">In this paper, we presented a novel large-scale parallel dataset PWKP for sentence simplification.</S>
        <S ID="S-2619">We proposed TSM, a tree-based translation model for sentence simplification which covers splitting, dropping, reordering and word/phrase substitution integrally for the first time.</S>
        <S ID="S-2620">We also described an efficient training method with speeding up techniques for TSM.</S>
        <S ID="S-2621">The evaluation shows that TSM can achieve better overall readability scores than a set of baseline systems.</S>
      </P>
      <P>
        <S ID="S-2622">References</S>
      </P>
      <P>
        <S ID="S-2623">Barzilay, Regina and Noemie Elhadad.</S>
        <S ID="S-2624">2003.</S>
        <S ID="S-2625">Sentence alignment for monolingual comparable corpora.</S>
        <S ID="S-2626">In Proceedings of the 2003 Conference on Empirical Methods in Natural Language Processing, pages 25&#8211;32.</S>
        <S ID="S-2627">Carroll, John, Guido Minnen, Darren Pearce, Yvonne Canning, Siobhan Devlin, and John Tait.</S>
        <S ID="S-2628">1999.</S>
        <S ID="S-2629">Simplifying text for language-impaired readers.</S>
        <S ID="S-2630">In Proceedings of the 9th Conference of the European Chapter of the Association for Computational Linguistics (EACL&#8217;99), pages 269&#8211;270.</S>
        <S ID="S-2631">Chandrasekar, R., Christine Doran, and B. Srinivas.</S>
        <S ID="S-2632">1996.</S>
        <S ID="S-2633">Motivations and methods for text simplification.</S>
        <S ID="S-2634">In Proceedings of the Sixteenth International Conference on Computational Linguistics (COLING&#8217;96), pages 1041&#8211;1044.</S>
        <S ID="S-2635">Filippova, Katja and Michael Strube.</S>
        <S ID="S-2636">2008a.</S>
        <S ID="S-2637">Dependency tree based sentence compression.</S>
        <S ID="S-2638">In International Natural Language Generation Conference (INLG&#8217;08), pages 25&#8211;32.</S>
        <S ID="S-2639">Filippova, Katja and Michael Strube.</S>
        <S ID="S-2640">2008b.</S>
        <S ID="S-2641">Sentence fusion via dependency graph compression.</S>
        <S ID="S-2642">In EMNLP &#8217;08: Proceedings of the Conference on Empirical Methods in Natural Language Processing, pages 177&#8211;185.</S>
        <S ID="S-2643">Graehl, Jonathan, Kevin Knight, and Jonathan May.</S>
      </P>
      <P>
        <S ID="S-2644">2008.</S>
        <S ID="S-2645">Training tree transducers.</S>
        <S ID="S-2646">In Computational Linguistics, volume 34, pages 391&#8211;427.</S>
        <S ID="S-2647">MIT Press.</S>
        <S ID="S-2648">Heilman, M.</S>
        <S ID="S-2649">and N.</S>
        <S ID="S-2650">A. Smith.</S>
        <S ID="S-2651">2009.</S>
        <S ID="S-2652">Question generation via overgenerating transformations and ranking.</S>
        <S ID="S-2653">Technical Report CMU-LTI-09-013, Language Technologies Institute, Carnegie Mellon University.</S>
        <S ID="S-2654">Inui, Kentaro, Atsushi Fujita, Tetsuro Takahashi, Ryu Iida, and Tomoya Iwakura.</S>
        <S ID="S-2655">2003.</S>
        <S ID="S-2656">Text simplification for reading assistance: A project note.</S>
        <S ID="S-2657">In Proceedings of the 2nd International Workshop on Paraphrasing: Paraphrase Acquisition and Applications (IWP), pages 9&#8211;16.</S>
        <S ID="S-2658">Jonnalagadda, Siddhartha and Graciela Gonzalez.</S>
      </P>
      <P>
        <S ID="S-2659">2009.</S>
        <S ID="S-2660">Sentence simplification aids protein-protein interaction extraction.</S>
        <S ID="S-2661">In Proceedings of the 3rd International Symposium on Languages in Biology and Medicine.</S>
        <S ID="S-2662">Jurafsky, Daniel and James H. Martin.</S>
        <S ID="S-2663">2008.</S>
        <S ID="S-2664">Speech</S>
      </P>
      <P>
        <S ID="S-2665">and Language Processing (2nd Edition).</S>
        <S ID="S-2666">Prentice Hall, 2 edition.</S>
        <S ID="S-2667">Klein, Dan and Christopher D. Manning.</S>
        <S ID="S-2668">2003.</S>
        <S ID="S-2669">Fast exact inference with a factored model for natural language parsing.</S>
        <S ID="S-2670">In Advances in Neural Information Processing Systems 15 (NISP&#8217;02), pages 3&#8211;10.</S>
        <S ID="S-2671">Knight, Kevin and Daniel Marcu.</S>
        <S ID="S-2672">2000.</S>
        <S ID="S-2673">Statisticsbased summarization - step one: Sentence compression.</S>
        <S ID="S-2674">In AAAI, pages 703&#8211;710.</S>
        <S ID="S-2675">Levenshtein.</S>
        <S ID="S-2676">1966.</S>
        <S ID="S-2677">Binary code capable of correcting deletions, insertions and reversals.</S>
        <S ID="S-2678">In Soviet</S>
      </P>
      <P>
        <S ID="S-2679">Physics, pages 707&#8211;710.</S>
        <S ID="S-2680">Nelken, Rani and Stuart M. Shieber.</S>
        <S ID="S-2681">2006.</S>
        <S ID="S-2682">Towards robust context-sensitive sentence alignment for monolingual corpora.</S>
        <S ID="S-2683">In Proceedings of 11th Conference of the European Chapter of the Association for Computational Linguistics, pages 161&#8211;168.</S>
        <S ID="S-2684">Petersen, Sarah E. and Mari Ostendorf.</S>
        <S ID="S-2685">2007.</S>
        <S ID="S-2686">Text</S>
      </P>
      <P>
        <S ID="S-2687">simplification for language learners: a corpus analysis.</S>
        <S ID="S-2688">In Proc. of Workshop on Speech and Language Technology for Education, pages 69&#8211;72.</S>
        <S ID="S-2689">Schmid, Helmut.</S>
        <S ID="S-2690">1994.</S>
        <S ID="S-2691">Probabilistic part-of-speech</S>
      </P>
      <P>
        <S ID="S-2692">tagging using decision trees.</S>
        <S ID="S-2693">In International Conference on New Methods in Language Processing, pages 44&#8211;49.</S>
        <S ID="S-2694">Schwarm, Sarah E. and Mari Ostendorf.</S>
        <S ID="S-2695">2005.</S>
        <S ID="S-2696">Reading level assessment using support vector machines and statistical language models.</S>
        <S ID="S-2697">In ACL&#8217;05: Proceedings of the 43rd Annual Meeting on Association for Computational Linguistics, pages 523&#8211;530.</S>
        <S ID="S-2698">Siddharthan, Advaith.</S>
        <S ID="S-2699">2002.</S>
        <S ID="S-2700">An architecture for a text simplification system.</S>
        <S ID="S-2701">In Proceedings of the Language Engineering Conference (LEC&#8217;02), pages 64&#8211;71.</S>
        <S ID="S-2702">Siddharthan, Advaith.</S>
        <S ID="S-2703">2006.</S>
        <S ID="S-2704">Syntactic simplification and text cohesion.</S>
        <S ID="S-2705">In Research on Language &amp; Computation, volume 4, pages 77&#8211;109.</S>
        <S ID="S-2706">Springer Netherlands, June.</S>
      </P>
      <P>
        <S ID="S-2707">Stolcke, Andreas.</S>
        <S ID="S-2708">2002.</S>
        <S ID="S-2709">SRILM - An Extensible Language Modeling Toolkit.</S>
        <S ID="S-2710">pages 901&#8211;904.</S>
        <S ID="S-2711">Vickrey, David and Daphne Koller.</S>
        <S ID="S-2712">2008.</S>
        <S ID="S-2713">Sentence</S>
      </P>
      <P>
        <S ID="S-2714">simplification for semantic role labeling.</S>
        <S ID="S-2715">In Proceedings of ACL-08: HLT, pages 344&#8211;352, June.</S>
        <S ID="S-2716">Watanabe, Willian Massami, Arnaldo Candido Junior,</S>
      </P>
      <P>
        <S ID="S-2717">Vin&#237;cius Rodriguez Uz&#234;da, Renata Pontin de Mattos Fortes, Thiago Alexandre Salgueiro Pardo, and Sandra Maria Alu&#237;sio.</S>
        <S ID="S-2718">2009.</S>
        <S ID="S-2719">Facilita: reading assistance for low-literacy readers.</S>
        <S ID="S-2720">In SIGDOC &#8217;09: Proceedings of the 27th ACM international conference on Design of communication, pages 29&#8211;36.</S>
        <S ID="S-2721">ACM.</S>
        <S ID="S-2722">Yamada, Kenji and Kevin Knight.</S>
        <S ID="S-2723">2001.</S>
        <S ID="S-2724">A syntaxbased statistical translation model.</S>
        <S ID="S-2725">In ACL&#8217;01: Proceedings of the 39th Annual Meeting on Association for Computational Linguistics, pages 523&#8211;530.</S>
        <S ID="S-2726">Yamada, Kenji and Kevin Knight.</S>
        <S ID="S-2727">2002.</S>
        <S ID="S-2728">A decoder for</S>
      </P>
      <P>
        <S ID="S-2729">syntax-based statistical mt.</S>
        <S ID="S-2730">In ACL&#8217;02: Proceedings of the 40th Annual Meeting on Association for Computational Linguistics, pages 303&#8211;310.</S>
        <S ID="S-2731">Zesch, Torsten, Christof M&#252;ller, and Iryna Gurevych.</S>
      </P>
      <P>
        <S ID="S-2732">2008.</S>
        <S ID="S-2733">Extracting Lexical Semantic Knowledge</S>
      </P>
      <P>
        <S ID="S-2734">from Wikipedia and Wiktionary.</S>
        <S ID="S-2735">In Proceedings of the Sixth International Language Resources and Evaluation (LREC&#8217;08), pages 1646&#8211;1652.</S>
        <S ID="S-2736">Zhao, Shiqi, Xiang Lan, Ting Liu, and Sheng Li.</S>
      </P>
      <P>
        <S ID="S-2737">2009.</S>
        <S ID="S-2738">Application-driven statistical paraphrase generation.</S>
        <S ID="S-2739">In Proceedings of ACL-IJCNLP, pages 834&#8211;842, Suntec, Singapore, August.</S>
      </P>
    </DIV>
  </BODY>
  <ACKNOWLEDGMENTS/>
  <REFERENCES/>
</PAPER>
