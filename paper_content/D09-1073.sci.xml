<PAPER>
  <FILENO/>
  <TITLE>Tree Kernel-based SVM with Structured Syntactic Knowledge for BTG-based Phrase Reordering</TITLE>
  <AUTHORS/>
  <ABSTRACT>
    <A-S ID="S-5524">Structured syntactic knowledge is important for phrase reordering.</A-S>
    <A-S ID="S-5525">This paper proposes using convolution tree kernel over source parse tree to model structured syntactic knowledge for BTG-based phrase reordering in the context of statistical machine translation.</A-S>
    <A-S ID="S-5526">Our study reveals that the structured syntactic features over the source phrases are very effective for BTG constraint-based phrase reordering and those features can be well captured by the tree kernel.</A-S>
    <A-S ID="S-5527">We further combine the structured features and other commonly-used linear features into a composite kernel.</A-S>
    <A-S ID="S-5528">Experimental results on the NIST MT-2005 Chinese-English translation tasks show that our proposed phrase reordering model statistically significantly outperforms the baseline methods.</A-S>
  </ABSTRACT>
  <BODY>
    <DIV DEPTH="0">
      <HEADER>1 Introduction</HEADER>
      <P>
        <S ID="S-5529">Phrase-based method (<REF ID="R-11" RPTR="10">Koehn et al., 2003</REF>; <REF ID="R-23" RPTR="26">Och and Ney, 2004</REF>; <REF ID="R-12" RPTR="12">Koehn et al., 2007</REF>) and syntaxbased method (<REF ID="R-31" RPTR="37">Wu, 1997</REF>; <REF ID="R-35" RPTR="47">Yamada and Knight, 2001</REF>; <REF ID="R-04" RPTR="5">Eisner, 2003</REF>; <REF ID="R-00" RPTR="0">Chiang, 2005</REF>; Cowan et al., 2006; <REF ID="R-16" RPTR="20">Marcu et al., 2006</REF>; <REF ID="R-15" RPTR="19">Liu et al., 2007</REF>; <REF ID="R-41" RPTR="54">Zhang et al., 2007</REF><REF ID="R-42" RPTR="59">Zhang et al., 2007</REF><REF ID="R-43" RPTR="64">Zhang et al., 2007</REF>c, 2008a, 2008b; <REF ID="R-26" RPTR="32">Shen et al., 2008</REF>; <REF ID="R-17" RPTR="21">Mi and Huang, 2008</REF>) represent the state-of-the-art technologies in statistical machine translation (SMT).</S>
        <S ID="S-5530">As the two technologies are complementary in many ways, an interesting research topic is how to combine the strengths of the two methods.</S>
        <S ID="S-5531">Many research efforts have been made to address this issue, which can be summarized into two ideas.</S>
        <S ID="S-5532">One is to add syntax into phrase-based model while another one is to enhance syntaxbased model to handle non-syntactic phrases.</S>
        <S ID="S-5533">In this paper, we bring forward the first idea by studying the issue of how to utilize structured syntactic features for phrase reordering in a phrase-based SMT system with BTG (Bracketing Transduction Grammar) constraints (<REF ID="R-31" RPTR="38">Wu, 1997</REF>).</S>
      </P>
      <P>
        <S ID="S-5534">Word and phrase reordering is a crucial component in a SMT system.</S>
        <S ID="S-5535">In syntax-based method, word reordering is implicitly addressed by translation rules, thus the performance is subject to parsing errors to a large extent (zhang et al., 2007a) and the impact of syntax on reordering is difficult to single out (<REF ID="R-14" RPTR="15">Li et al., 2007</REF>).</S>
        <S ID="S-5536">In phrasebased method, local word reordering 1 can be effectively captured by phrase pairs directly while local phrase reordering is explicitly modeled by phrase reordering model and distortion model.</S>
        <S ID="S-5537">Recently, many phrase reordering methods have been proposed, ranging from simple distancebased distortion model (<REF ID="R-11" RPTR="11">Koehn et al., 2003</REF>; <REF ID="R-23" RPTR="27">Och and Ney, 2004</REF>), flat reordering model (<REF ID="R-31" RPTR="39">Wu, 1997</REF>; <REF ID="R-37" RPTR="49">Zens et al., 2004</REF>), lexicalized reordering model (<REF ID="R-28" RPTR="34">Tillmann, 2004</REF>; <REF ID="R-13" RPTR="14">Kumar and Byrne, 2005</REF>), to hierarchical phrase-based model (<REF ID="R-00" RPTR="1">Chiang, 2005</REF>; <REF ID="R-25" RPTR="31">Setiawan et al., 2007</REF>) and classifier-based reordering model with linear features (<REF ID="R-38" RPTR="50">Zens and Ney, 2006</REF>; <REF ID="R-33" RPTR="40">Xiong et al., 2006</REF>; <REF ID="R-41" RPTR="55">Zhang et al., 2007</REF><REF ID="R-42" RPTR="60">Zhang et al., 2007</REF><REF ID="R-43" RPTR="65">Zhang et al., 2007</REF>a; <REF ID="R-34" RPTR="45">Xiong et al., 2008</REF>).</S>
        <S ID="S-5538">However, one of the major limitations of these advances is the structured syntactic knowledge, which is important to global reordering (<REF ID="R-14" RPTR="16">Li et al., 2007</REF>; <REF ID="R-05" RPTR="6">Elming, 2008</REF>), has not been well exploited.</S>
        <S ID="S-5539">This makes the phrasebased method particularly weak in handling global phrase reordering.</S>
        <S ID="S-5540">From machine learning viewpoint (<REF ID="R-29" RPTR="35">Vapnik, 1995</REF>), it is computationally infeasible to explicitly generate features involving structured information in many NLP applica-</S>
      </P>
      <P>
        <S ID="S-5541">1 This paper follows the term convention of global reordering and local reordering of <REF ID="R-14" RPTR="18">Li et al. (2007)</REF>, between which the distinction is solely defined by reordering distance (whether beyond four source words) (<REF ID="R-14" RPTR="17">Li et al., 2007</REF>).</S>
      </P>
      <P>
        <S ID="S-5542">tions.</S>
        <S ID="S-5543">For example, one cannot enumerate efficiently all the sub-tree features for a full parse tree.</S>
        <S ID="S-5544">This would be the reason why structured features are not fully utilized in previous statistical feature-based phrase reordering model.</S>
      </P>
      <P>
        <S ID="S-5545">Thanks to the nice property of kernel-based machine learning method that can implicitly explore (structured) features in a high dimensional feature space (<REF ID="R-29" RPTR="36">Vapnik, 1995</REF>), in this paper we propose using convolution tree kernel (<REF ID="R-07" RPTR="7">Haussler, 1999</REF>; <REF ID="R-01" RPTR="2">Collins and Duffy, 2001</REF>) to explore the structured syntactic knowledge for phrase reordering and further combine the tree kernel with other diverse linear features into a composite kernel to strengthen the model&#8217;s predictive ability.</S>
        <S ID="S-5546">Indeed, using tree kernel methods to mine structured knowledge has shown success in some NLP applications like parsing (<REF ID="R-01" RPTR="3">Collins and Duffy, 2001</REF>), semantic role labeling (<REF ID="R-18" RPTR="22">Moschitti, 2004</REF>; <REF ID="R-41" RPTR="56">Zhang et al., 2007</REF><REF ID="R-42" RPTR="61">Zhang et al., 2007</REF><REF ID="R-43" RPTR="66">Zhang et al., 2007</REF>b), relation extraction (<REF ID="R-40" RPTR="52">Zhang et al., 2006</REF>), pronoun resolution (<REF ID="R-36" RPTR="48">Yang et al., 2006</REF>) and question classification (<REF ID="R-39" RPTR="51">Zhang and Lee, 2003</REF>).</S>
        <S ID="S-5547">However, to our knowledge, such technique still remains unexplored for phrase reordering.</S>
      </P>
      <P>
        <S ID="S-5548">In this paper, we look into the phrase reordering problem in two aspects: 1) how to model and optimize structured features, and 2) how to combine the structured features with other linear features and further integrate them into the loglinear model-based translation framework.</S>
        <S ID="S-5549">Our study shows that: 1) the structured syntactic features are very useful and 2) our kernel-based model can well explore diverse knowledge, including previously-used linear features and the structured syntactic features, for phrase reordering.</S>
        <S ID="S-5550">Our model displays one advantage over the previous work that it is able to utilize the structured syntactic features without the need for extensive feature engineering in decoding a parse tree into a set of linear syntactic features.</S>
      </P>
      <P>
        <S ID="S-5551">To have a more insightful evaluation, we design three experiments with three different evaluation metrics.</S>
        <S ID="S-5552">Experimental results on the NIST MT-2005 Chinese-English translation tasks show that our method statistically significantly outperforms the baseline methods in term of the three different evaluation metrics.</S>
      </P>
      <P>
        <S ID="S-5553">The rest of the paper is organized as follows.</S>
        <S ID="S-5554">Section 2 introduces the baseline method of BTG-based phrase translation method while section 3 discusses the proposed method in detail.</S>
        <S ID="S-5555">The experimental results are reported and discussed in section 4.</S>
        <S ID="S-5556">Finally, we conclude the paper in section 5.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>2 Baseline System and Method</HEADER>
      <P>
        <S ID="S-5557">We use the MaxEnt-based BTG translation system (<REF ID="R-33" RPTR="41">Xiong et al., 2006</REF>) as our baseline.</S>
        <S ID="S-5558">It is a phrase-based SMT system with BTG reordering constraint.</S>
        <S ID="S-5559">The system uses the BTG lexical translation rules ( &#65533;&#65533;&#65533;/&#65533;) to translate the source phrase &#65533; into target phrase &#65533; , and the BTG merging rules ( &#65533;&#65533;&#65533;&#65533;, &#65533;&#65533;| &#65533;&#65533;,&#65533;&#65533;) to combine two neighboring phrases with a straight or inverted order.</S>
        <S ID="S-5560">In the translation model, the BTG lexical rules are weighted with several features, such as phrase translation, word penalty and language models, in a log-linear form.</S>
        <S ID="S-5561">With the BTG constraint, the reordering model &#937; is defined on the two neighboring phrases &#65533; &#65533; and &#65533; &#65533; and their order &#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;, &#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533; as follows: &#937;&#65533;f(&#65533;, &#65533; &#65533; ,&#65533; &#65533; ) (1)</S>
      </P>
      <P>
        <S ID="S-5562">In the baseline system, a MaxEnt-based classifier with boundary words of the two neighboring phrases as features is used to model the merging/reordering order.</S>
        <S ID="S-5563">The baseline MaxEntbased reordering model is formulized as follows:</S>
      </P>
      <P>
        <S ID="S-5564">&#937;&#65533;&#65533; &#65533; (&#65533;|&#65533; &#65533; ,&#65533; &#65533; ) &#65533; &#65533;&#65533;&#65533;(&#8721; &#65533; &#65533; &#65533;&#65533; &#65533; (&#65533;,&#65533; &#65533; ,&#65533; &#65533; )) (2)</S>
      </P>
      <P>
        <S ID="S-5565">&#8721;&#65533; &#65533;&#65533;&#65533;(&#8721;&#65533; &#65533; &#65533; &#65533; &#65533; (&#65533;,&#65533; &#65533; ,&#65533; &#65533; ))</S>
      </P>
      <P>
        <S ID="S-5566">where the functions &#65533; &#65533; (&#65533;, &#65533; &#65533; ,&#65533; &#65533; ) &#65533; &#65533;0,1&#65533; are model feature functions using the boundary words of the two neighboring phrases as features, and &#65533; &#65533; are feature weights that are trained based on the MaxEnt-based criteria.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>3 Tree Kernel-based Phrase Reordering Model</HEADER>
      <P>
        <S ID="S-5714"></S>
      </P>
      <DIV DEPTH="1">
        <HEADER>3.1 Kernel-based Classifier Solution to</HEADER>
        <P>
          <S ID="S-5567">Phrase Reordering</S>
        </P>
        <P>
          <S ID="S-5568">In this paper, phrase reordering is recast as a classification issue as done in previous work (<REF ID="R-33" RPTR="42">Xiong et al., 2006</REF> &amp; 2008; <REF ID="R-41" RPTR="57">Zhang et al., 2007</REF><REF ID="R-42" RPTR="62">Zhang et al., 2007</REF><REF ID="R-43" RPTR="67">Zhang et al., 2007</REF>a).</S>
          <S ID="S-5569">In training, we use a machine learning algorithm training on the annotated phrase reordering instances that are automatically extracted from word-aligned, source sentence parsed training corpus, to learn a classifier.</S>
          <S ID="S-5570">In testing (decoding), the learned classifier is applied to two adjacent source phrases to decide whether they should be merged (straight) or reordered (inverted) and what their probabilities are, and then these probabilities are used as one feature in the log-linear model in a phrase-based decoder.</S>
        </P>
        <P>
          <S ID="S-5571">In addition to the previously-used linear features, we are more interested in the value of structured syntax in phrase reordering and how to capture it using kernel methods.</S>
          <S ID="S-5572">However, not</S>
        </P>
        <P>
          <S ID="S-5573">all classifiers are able to work with kernel methods.</S>
          <S ID="S-5574">Only those dot-product-based classifiers can work with kernels by replacing the dot product with a kernel function, where the kernel function is able to directly calculate the similarity between two (structured) objects without enumerating them into linear feature vectors.</S>
          <S ID="S-5575">In this paper, we select SVM as our classifier.</S>
          <S ID="S-5576">In this section, we first define the structured syntactic features and introduce the commonly used linear features, and then discuss how to utilize these features by kernel methods together SVM for phrase reordering</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.2 Structured Syntactic Features</HEADER>
        <P>
          <S ID="S-5577">A reordering instance &#65533;&#65533;&#65533;&#65533; &#65533; ,&#65533; &#65533; &#65533; (see Eq.1) in this paper refers to two adjacent source phrases &#65533; &#65533; and &#65533; &#65533; to be translated.</S>
          <S ID="S-5578">The structured syntactic feature spaces of a reordering instance are defined as the portion of a parse tree of the source sentence that at least covers the span of the reordering instance (i.e. the two neighboring phrases).</S>
          <S ID="S-5579">The syntactic features are defined as all</S>
        </P>
        <P>
          <S ID="S-5580">T 1 ) Minimum Sub-Tree (MST)</S>
        </P>
        <P>
          <S ID="S-5581">T 2 ) Minimum Sub-Structure (MSS) T 4 ) Chunking Tree (CT)</S>
        </P>
        <P>
          <S ID="S-5582">T 3 ) Context-sensitive Minimum Sub-Structure (CMSS)</S>
        </P>
        <P>
          <S ID="S-5583">Figure 1.</S>
          <S ID="S-5584">Different representations of structured syntactic features of a reordering instance in the example sentence excerpted from our training corpus &#8220;&#8230; &#24314; &#31435; /build &#35268; &#27169; /scale &#23439; &#22823; /mighty &#30340; /of &#21508; &#31867; /various types &#20154; &#25165; /qualified personnel &#38431; &#20237; /contingent &#39318; &#20808; /above all &#36843; &#20999; /urgently &#38656; &#35201; /necessary &#20013; &#22830; /central authorities &#32479; &#31609; /overall &#35268; &#21010; /planning&#8230;(To build a mighty contingent of qualified personnel of various types, it is necessary, above all, for the central authorities to make overall planning.</S>
          <S ID="S-5585">) &#8221;, where &#8220; &#21508; &#31867; /various types &#20154; &#25165; /qualified personnel &#38431; &#20237; /contingent (contingent of qualified personnel of various types)&#8221; is the 1 st /left phrase and &#8220; &#39318; &#20808; /above all &#36843; &#20999; /urgent &#38656; &#35201; /necessary (it is necessary, above all, &#8230;)&#8221; is the 2 nd /right phrase.</S>
          <S ID="S-5586">Note that different function tags are attached to the grammar tag of each internal node.</S>
        </P>
        <P>
          <S ID="S-5587">the possible subtrees in the structured feature spaces.</S>
          <S ID="S-5588">We can see that the structured feature spaces and their features are encapsulated by a full parse tree of source sentences.</S>
          <S ID="S-5589">Thus, it is critical to understand which portion of a parse tree (i.e. structured feature space) is the most effective to represent a reordering instance.</S>
          <S ID="S-5590">Motivated by the work of (<REF ID="R-40" RPTR="53">Zhang et al., 2006</REF>), we here examine four cases that contain different sub-structures as shown in Fig.</S>
          <S ID="S-5591">1.</S>
        </P>
        <P>
          <S ID="S-5592">(1) Minimum Sub-Tree (MST): the sub-tree rooted by the nearest common ancestor of the two phrases.</S>
          <S ID="S-5593">This feature records the minimum sub-structure covering the two phrases and its left and right contexts as shown in Fig 1.T 1 .</S>
          <S ID="S-5594">(2) Minimum Sub-Structure (MSS): the smallest common sub-structure covering the two phrases.</S>
          <S ID="S-5595">It is enclosed by the shortest path linking the two phrases.</S>
          <S ID="S-5596">Thus, its leaf nodes exactly consist of all the phrasal words.</S>
          <S ID="S-5597">(3) Context-sensitive Minimum Sub-Structure (CMSS): the MSS extending with the 1 st left sibling node of the left phrase and the 1 st right sibling node of the right phrase and their descendants.</S>
          <S ID="S-5598">If sibling is unavailable, then we move to the parent of current node and repeat the same process until the sibling is available or the root of the MST is reached.</S>
          <S ID="S-5599">(4) Chunking Tree (CT): the base phrase list extracted from the MSS.</S>
          <S ID="S-5600">We prune out all the internal structures of the MSS and only keep the root node and the base phrase list for generating the chunking tree.</S>
        </P>
        <P>
          <S ID="S-5601">Fig.</S>
          <S ID="S-5602">1 illustrates the different representations of an example reordering instance.</S>
          <S ID="S-5603">T 1 is the MST for the example instance, where the sub-structure circled by a dotted line is the MSS, which is also shown in T 2 for clarity.</S>
          <S ID="S-5604">We can see that the MSS is a subset of the MST.</S>
          <S ID="S-5605">By T 2 we would like to evaluate whether the structured information is effective for phrase reordering while by comparing the system performance when using T 1 and T 2, we would like to evaluate whether the structured context information embedded in the MST is useful to phrase reordering.</S>
          <S ID="S-5606">T 3 is the CMSS, where the two sub-structures circled by dotted lines are included as the context to T 2 and make T 3 limited context-sensitive.</S>
          <S ID="S-5607">This is to evaluate whether the limited context information in the CMSS is helpful.</S>
          <S ID="S-5608">By comparing the performance of T 1 and T 3, we would like to see whether the larger context in T 1 is a noisy feature.</S>
          <S ID="S-5609">T 4 is the CT, where only the basic structured information is kept.</S>
          <S ID="S-5610">By comparing the performance of T 2 and T 4, we would like to study whether the high-level structured syntactic features in T 2 are useful to phrase reordering.</S>
        </P>
        <P>
          <S ID="S-5611">After defining the four structured feature spaces, we further partition each feature space into five parts according to their functionalities.</S>
          <S ID="S-5612">Because it only makes sense to evaluate two partitions of the same functionality between two reordering instances, the feature space partition leads to a more precise similarity calculation.</S>
          <S ID="S-5613">As shown in Fig 1, all the internal nodes in each partition are labeled with a unique function tag in the following way:</S>
        </P>
        <P>
          <S ID="S-5614">&#8226; Left Context (-lc): nodes in this partition do not cover any phrase word and they are all in the left of the left phrase.</S>
        </P>
        <P>
          <S ID="S-5615">&#8226; Right Context (-rc): nodes in this partition do not cover any phrase word and they are all in the right of the right phrase.</S>
        </P>
        <P>
          <S ID="S-5616">&#8226; Left Phrase (-lp): nodes in this partition only cover the first phrase and/or its left context.</S>
        </P>
        <P>
          <S ID="S-5617">&#8226; Right Phrase (-rp): nodes in this partition only cover the second phrase and/or its right context.</S>
        </P>
        <P>
          <S ID="S-5618">&#8226; Shared Part (-sp): nodes in this partition at least cover both of the two phrases partially.</S>
        </P>
        <P>
          <S ID="S-5619">No lexical word is tagged since it is not a part of the structured features, and therefore not participating in the tree kernel computing.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.3 Linear Features</HEADER>
        <P>
          <S ID="S-5620">In our study, we define the following lexicalized linear features which are easily to be extracted and integrated to our composite kernel:</S>
        </P>
        <P>
          <S ID="S-5621">&#8226; Leftmost and rightmost boundary words of the left and right source phrases</S>
        </P>
        <P>
          <S ID="S-5622">&#8226; Leftmost and rightmost boundary words of the left and right target phrases</S>
        </P>
        <P>
          <S ID="S-5623">&#8226; Internal words of the four phrases (excluding boundary words)</S>
        </P>
        <P>
          <S ID="S-5624">&#8226; Target language model (LM) score difference (monotone-inverted)</S>
        </P>
        <P>
          <S ID="S-5625">In total, we arrive at 13 features, including 8 boundary word features, 4 (kinds of) internal word features and 1 LM feature.</S>
          <S ID="S-5626">The first 12 features have been proven useful (<REF ID="R-33" RPTR="43">Xiong et al., 2006</REF>; <REF ID="R-41" RPTR="58">Zhang et al., 2007</REF><REF ID="R-42" RPTR="63">Zhang et al., 2007</REF><REF ID="R-43" RPTR="68">Zhang et al., 2007</REF>a) to phrase reordering.</S>
          <S ID="S-5627">LM score is certainly a strong evidence for modeling word orders and lexical selection.</S>
          <S ID="S-5628">Although it is already used as a standalone feature in the log-linear model, we also would like to explicitly re-optimize it together with other reordering features in our reordering model.</S>
        </P>
        <P>
          <S ID="S-5629">3.4 Tree Kernel, Composite Kernel and Integrating into our Reordering Model</S>
        </P>
        <P>
          <S ID="S-5630">As discussed before, we use convolution tree kernel to capture the structured syntactic feature implicitly by directly computing similarity between the parse-tree representations of two reordering instances with explicitly enumerating all the features one by one.</S>
          <S ID="S-5631">In convolution tree kernel (<REF ID="R-01" RPTR="4">Collins and Duffy, 2001</REF>), a parse tree T is implicitly represented by a vector of integer counts of each sub-tree type (regardless of its ancestors):</S>
        </P>
        <P>
          <S ID="S-5632">&#966; ( T ) = (# subtree 1 (T), &#8230;, # subtree n (T))</S>
        </P>
        <P>
          <S ID="S-5633">where # subtree i (T) is the occurrence number of the i th sub-tree type (subtree i ) in T.</S>
          <S ID="S-5634">Since the number of different sub-trees is exponential with the parse tree size, it is computationally infeasible to directly use the feature vector &#966; ( T ) .</S>
          <S ID="S-5635">To solve this computational issue, Collins and Duffy (2001) proposed the following parse tree kernel to calculate the dot product between the above high dimensional vectors implicitly.</S>
          <S ID="S-5636">KT (</S>
        </P>
        <P>
          <S ID="S-5637">1, T2) =&lt; &#966;( T1), &#966;( T2) &gt;</S>
        </P>
        <P>
          <S ID="S-5638">= I ( n ) I ( n )</S>
        </P>
        <P>
          <S ID="S-5639">&#8721; ((</S>
        </P>
        <P>
          <S ID="S-5640">) (</S>
        </P>
        <P>
          <S ID="S-5641">))</S>
        </P>
        <P>
          <S ID="S-5642">i &#8721; subtree</S>
        </P>
        <P>
          <S ID="S-5643">&#8901;</S>
        </P>
        <P>
          <S ID="S-5644">n1&#8712;N1 i</S>
        </P>
        <P>
          <S ID="S-5645">&#8721;n subtree</S>
        </P>
        <P>
          <S ID="S-5646">2&#8712;N2 i</S>
        </P>
        <P>
          <S ID="S-5647">&#8721; &#8721; 1 2</S>
        </P>
        <P>
          <S ID="S-5648">= &#916;( n , n )</S>
        </P>
        <P>
          <S ID="S-5649">n1&#8712;N1 n2&#8712;N2</S>
        </P>
        <P>
          <S ID="S-5650">where N 1 and N 2 are the sets of nodes in trees T 1 and T 2 , respectively, and I</S>
        </P>
        <P>
          <S ID="S-5651">subtree i</S>
        </P>
        <P>
          <S ID="S-5652">( n ) is a function</S>
        </P>
        <P>
          <S ID="S-5653">that is 1 iff the subtree i occurs with root at node n and zero otherwise, and &#916; ( n1, n2) is the number of the common subtrees rooted at n 1 and n 2 , i.e.,</S>
        </P>
        <P>
          <S ID="S-5654">&#916; ( n1, n2) = &#8721; Isubtree ( n1) &#8901; I (</S>
        </P>
        <P>
          <S ID="S-5655">2) i i subtree</S>
        </P>
        <P>
          <S ID="S-5656">n</S>
        </P>
        <P>
          <S ID="S-5657">i</S>
        </P>
        <P>
          <S ID="S-5658">&#916;( n1, n2) can be further computed efficiently by the following recursive rules: Rule 1: if the productions (CFG rules) at n 1 and</S>
        </P>
        <P>
          <S ID="S-5659">n</S>
        </P>
        <P>
          <S ID="S-5660">are different, &#916; ( n1, n2) = 0; Rule 2: else if both n 1 and n</S>
        </P>
        <P>
          <S ID="S-5661">are pre-terminals</S>
        </P>
        <P>
          <S ID="S-5662">(POS tags), &#916; ( n1, n2) = 1&#215; &#955; ; Rule 3: else,</S>
        </P>
        <P>
          <S ID="S-5663">( 1 )</S>
        </P>
        <P>
          <S ID="S-5664">&#916; ( n 1, n 2) = &#955;&#8719; nc n (1 + &#916;( ch ( n 1 1, j ), ch ( n 2, j ))), j = where nc( n1 ) is the child number of n</S>
        </P>
        <P>
          <S ID="S-5665">, ch(n,j) is</S>
        </P>
        <P>
          <S ID="S-5666">the j th child of node n and &#955; (0&lt; &#955; &lt;1) is the decay factor in order to make the kernel value less variable with respect to the subtree sizes.</S>
          <S ID="S-5667">In addition, the recursive Rule 3 holds because given two nodes with the same children, one can construct common sub-trees using these children and common sub-trees of further offspring.</S>
          <S ID="S-5668">The time</S>
        </P>
        <P>
          <S ID="S-5669">complexity for computing this kernel is O(| N1| &#8901;| N2 |) and in practice in near to linear computational time without the need of enumerating all subtree features.</S>
        </P>
        <P>
          <S ID="S-5670">In our study, the linear feature-based similarity is simply calculated using dot-product.</S>
          <S ID="S-5671">We then define the following composite kernel to combine the structured features-based and the linear features-based similarities:</S>
        </P>
        <P>
          <S ID="S-5672">&#65533; &#65533; (&#65533; &#65533; ,&#65533; &#65533; ) &#65533;&#65533;&#183;&#65533; &#65533; (&#65533; &#65533; ,&#65533; &#65533; ) &#65533; (1 &#65533;&#65533;) &#183;&#65533; &#65533; (&#65533; &#65533; ,&#65533; &#65533; ) (3)</S>
        </P>
        <P>
          <S ID="S-5673">where K t is the tree kernel over the structured features and K l is the linear kernel (dot-product) over the linear features.</S>
          <S ID="S-5674">The composite kernel K c is a linear combination of the two individual kernels, where the coefficient &#945; is set to its default value 0.3 as that in <REF ID="R-18" RPTR="24">Moschitti (2004)</REF>&#8217;s implementation.</S>
          <S ID="S-5675">The kernels return the similarities between two reordering instances based on their features used.</S>
          <S ID="S-5676">Our basic assumption is, the more similar the two reordering instances of x 1 and x 2 are, the more chance they share the same order.</S>
        </P>
        <P>
          <S ID="S-5677">Now let us see how to integrate the kernel functions into SVM.</S>
          <S ID="S-5678">The linear classifier learned by SVM is formulized as:</S>
        </P>
        <P>
          <S ID="S-5679">f ( x) = sgn( &#8721; ya</S>
        </P>
        <P>
          <S ID="S-5680">i ix&#8226; xi + b) (4) i</S>
        </P>
        <P>
          <S ID="S-5681">where ai is the weight of a support vector x</S>
        </P>
        <P>
          <S ID="S-5682">i</S>
        </P>
        <P>
          <S ID="S-5683">(i.e.,</S>
        </P>
        <P>
          <S ID="S-5684">a support reordering instance &#65533; &#65533; &#65533;&#65533;&#65533; &#65533; ,&#65533; &#65533; &#65533;in our study), y</S>
        </P>
        <P>
          <S ID="S-5685">i</S>
        </P>
        <P>
          <S ID="S-5686">is its class label (1: &#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533; or -</S>
        </P>
        <P>
          <S ID="S-5687">1: &#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533; in our study) and b is the intercept of the hyperplane.</S>
          <S ID="S-5688">An input reordering instance x is classified as positive (negative) if f ( x ) &gt;0 ( f ( x ) &lt;0).</S>
          <S ID="S-5689">Based on the linear classifier, a kernelized SVM can be easily implemented by simply replacing the dot product x &#8727; xi in Eq (4) with a</S>
        </P>
        <P>
          <S ID="S-5690">kernel function Kxx ( , i ) .</S>
          <S ID="S-5691">Thus, the kernelized SVM classifier is formulated as:</S>
        </P>
        <P>
          <S ID="S-5692">f ( x) = sgn( &#8721; yaK</S>
        </P>
        <P>
          <S ID="S-5693">i i</S>
        </P>
        <P>
          <S ID="S-5694">( x, xi) + b) (5)</S>
        </P>
        <P>
          <S ID="S-5695">i</S>
        </P>
        <P>
          <S ID="S-5696">where Kxx ( , i ) is either Kc( x, x</S>
        </P>
        <P>
          <S ID="S-5697">i) , Kt( x, xi) or</S>
        </P>
        <P>
          <S ID="S-5698">K ( x, x ) in our study.</S>
          <S ID="S-5699">Following Eq (1), our</S>
        </P>
        <P>
          <S ID="S-5700">l i</S>
        </P>
        <P>
          <S ID="S-5701">reordering model (implemented by the kernelized SVM) can be formulized as follows:</S>
        </P>
        <P>
          <S ID="S-5702">&#937;&#65533;f(&#65533;, &#65533; &#65533; ,&#65533; &#65533; ) &#65533;&#65533; &#65533;&#65533;&#65533; (&#65533;|&#65533; &#65533;&#65533;&#65533; &#65533; ,&#65533; &#65533; &#65533;) &#65533;&#65533;&#65533;&#65533;(&#8721; &#65533; (&#65533; &#65533; &#65533; &#65533; &#65533;(&#65533;, &#65533; &#65533; ) &#65533;&#65533;) ) (6)</S>
        </P>
        <P>
          <S ID="S-5703">A reordering instance x is classified as straight (or inverted) if &#65533; &#65533;&#65533;&#65533; (&#65533;|&#65533;) &#65533;0 (or &#65533; &#65533;&#65533;&#65533; (&#65533;|&#65533;) &#65533; 0).</S>
          <S ID="S-5704">Eq (6) and Eq (2) show the difference between our kernalized SVM-based reordering</S>
        </P>
        <P>
          <S ID="S-5705">model and the MaxEnt-based reordering model.</S>
          <S ID="S-5706">The main difference between them lies in that our model is able to utilize structured syntactic features by kernalized SVM while the previous work can only use lexicalized word features by MaxEnt-based classifier.</S>
        </P>
        <P>
          <S ID="S-5707">Finally, because the return value of &#65533; &#65533;&#65533;&#65533; (&#65533;|&#65533;) is a distance function rather than a probability, we use a sigmoid function to convert &#65533; &#65533;&#65533;&#65533; (&#65533;|&#65533;) to a posterior probability as shown using the following to functions and apply it as one feature to the log-linear model in the decoding.</S>
          <S ID="S-5708">1</S>
        </P>
        <P>
          <S ID="S-5709">P( straight | x) = and +</S>
        </P>
        <P>
          <S ID="S-5710">psvm ( o| x) 1 e &#8722;</S>
        </P>
        <P>
          <S ID="S-5711">1 Pinverted ( | x) =</S>
        </P>
        <P>
          <S ID="S-5712">psvm ( o| x) 1 + e</S>
        </P>
        <P>
          <S ID="S-5713">where straight represents a positive instance and inverted represents a negative instance.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>4 Experiments and Discussion</HEADER>
      <P>
        <S ID="S-5812"></S>
      </P>
      <DIV DEPTH="1">
        <HEADER>4.1 Experimental Settings</HEADER>
        <P>
          <S ID="S-5715">Basic Settings: we evaluate our method on Chinese-English translation task.</S>
          <S ID="S-5716">We use the FBIS corpus as training set, the NIST MT-2002 test set as development (dev) set and the NIST MT-2005 test set as test set.</S>
          <S ID="S-5717">The Stanford parser (<REF ID="R-09" RPTR="8">Klein and Manning, 2003</REF>) is used to parse Chinese sentences on the training, dev and test sets.</S>
          <S ID="S-5718">GIZA++ (<REF ID="R-23" RPTR="28">Och and Ney, 2004</REF>) and the heuristics &#8220;growdiag-final-and&#8221; are used to generate m-to-n word alignments.</S>
          <S ID="S-5719">The translation model is trained on the FBIS corpus and a 4-gram language model is trained on the Xinhua portion of the English Gigaword corpus using the SRILM Toolkits (<REF ID="R-27" RPTR="33">Stolcke, 2002</REF>) with modified Kneser-Ney smoothing (<REF ID="R-10" RPTR="9">Kenser and Ney, 1995</REF>).</S>
          <S ID="S-5720">For the MER training (<REF ID="R-21" RPTR="25">Och, 2003</REF>), we modify Koehn&#8217;s MER trainer (Koehn, 2004) to train our system.</S>
          <S ID="S-5721">For significance test, we use Zhang et al&#8217;s implementation (Zhang et al, 2004).</S>
        </P>
        <P>
          <S ID="S-5722">Baseline Systems: we set three baseline systems: B1) Moses (<REF ID="R-12" RPTR="13">Koehn et al., 2007</REF>) that uses lexicalized unigram reordering model to predict three orientations: monotone, swap and discontinuous; B2) MaxEnt-based reordering model with lexical boundary word features only (<REF ID="R-33" RPTR="44">Xiong et al., 2006</REF>); B3) Linguistically annotated reordering model for BTG-based (LABTG) SMT (<REF ID="R-34" RPTR="46">Xiong et al., 2008</REF>).</S>
          <S ID="S-5723">For Moses, we used the default settings.</S>
          <S ID="S-5724">We build a CKY-style decoder and integrate the corresponding reordering modelling methods into the decoder to implement the 2 nd and the 3 rd baseline systems and our system.</S>
          <S ID="S-5725">Except reordering models, all the four systems use the same features in translation model, language model and distortion model as Moses in the loglinear framework.</S>
          <S ID="S-5726">We tune the four systems using the strategies as discussed previously in this section.</S>
        </P>
        <P>
          <S ID="S-5727">Reordering Model Training: we extract all reordering instances from the m-to-n wordaligned training corpus.</S>
          <S ID="S-5728">The reordering instances include the two source phrases, two target phrases, order label and its corresponding parse tree.</S>
          <S ID="S-5729">We generate the boundary word features from the extracted reordering instances in the same way as discussed in Xiong et al. (2006) and use Zhang&#8217;s MaxEnt Tools 2 to train a reordering model for the 2 nd baseline system.</S>
          <S ID="S-5730">Similarly, we use the algorithm 1 in Xiong et al. (2008) to extract features and use the same MaxEnt Tools to train a reordering model for the 3 rd baseline system.</S>
          <S ID="S-5731">Based on the extracted reordering instances, we generate the four structured features and the linear features, and then use the Tree Kernel Tools (<REF ID="R-18" RPTR="23">Moschitti, 2004</REF>) to train our kernel-based reordering model (linear, tree and composite).</S>
        </P>
        <P>
          <S ID="S-5732">Experimental Design and Evaluation Metrics: we design three experiments and evaluate them using three metrics.</S>
        </P>
        <P>
          <S ID="S-5733">Classification-based: in the first experiment, we extract all reordering instances and their features from the dev and test sets, and then use the reordering models trained on the training set to classify (label) those instances extracted from the dev and test sets.</S>
          <S ID="S-5734">In this way, we can isolate the reordering problem from the influence of others, such as translation model, pruning and decoding strategies, to better examine the reordering models&#8217; ability and to give analytical insights into the features.</S>
          <S ID="S-5735">Classification Accuracy (CAcc), the percentage of the correctly labeled instances over all trials, is used as the evaluation metric.</S>
        </P>
        <P>
          <S ID="S-5736">Forced decoding 3 -based and normal decodingbased: the two experiments evaluate the reordering models through a real SMT system.</S>
          <S ID="S-5737">The reordering model and the language model are the same in the two experiments.</S>
          <S ID="S-5738">However, in forced decoding, we train two translation models, one using training data only while another using both</S>
        </P>
        <P>
          <S ID="S-5739">2 http://homepages.inf.ed.ac.uk/s0450736/maxent.html 3 A normal SMT decoder filters a translation model according to the source sentences, whereas in forced decoding, a translation model is filtered based on both source sentence and target references.</S>
          <S ID="S-5740">In other words, in forced decoding, the decoder is forced to use those phrases whose translations are already in the references.</S>
        </P>
        <P>
          <S ID="S-5741">training, dev and test data.</S>
          <S ID="S-5742">By forced decoding, we aim to isolate the reordering problem from those of OOV and lexical selections resulting from imperfect translation model in the context of a real SMT task.</S>
          <S ID="S-5743">Besides the the case-sensitive BLEU-4 (<REF ID="R-24" RPTR="29">Papineni et al., 2002</REF>) used in the two experiments, we design another evaluation metrics Reordering Accuracy (RAcc) for forced decoding evaluation.</S>
          <S ID="S-5744">RAcc is the percentage of the adjacent word pairs with correct word order 4 over all words in one-best translation results.</S>
          <S ID="S-5745">Similar to BLEU score, we also use the similar Brevity Penalty BP (<REF ID="R-24" RPTR="30">Papineni et al., 2002</REF>) to penalize the short translations in computing RAcc.</S>
          <S ID="S-5746">Finally, please note for the three evaluation metrics, the higher values represent better performance.</S>
        </P>
        <P>
          <S ID="S-5747">Feature Spaces CAcc (%) Dev Test Minimum Sub-Tree (MST) 89.87 89.92</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>4.2 Experimental Results</HEADER>
        <P>
          <S ID="S-5748">Classification of Instances: Table 1 reports the performance of our defined four structured features, linear feature and the composite kernel.</S>
          <S ID="S-5749">The results are summarized as follows.</S>
        </P>
        <P>
          <S ID="S-5750">The last row reports the performance without using any reordering features.</S>
          <S ID="S-5751">We just suppose that all the translations are monotonic, no reordering happens.</S>
          <S ID="S-5752">The CAccs of 78.92% and 78.67% serve as the bottom line in our study.</S>
          <S ID="S-5753">Compared with the bottom line, the tree kernels over the 4 structured features are very effective for phrase</S>
        </P>
        <P>
          <S ID="S-5754">4 An adjacent word pair w i w i+1 in a translation have correct</S>
        </P>
        <P>
          <S ID="S-5755">word order if and only if w i appears before w i+1 in translation references.</S>
          <S ID="S-5756">Note than the two words may not be adjacent in the references even if they have correct word order.</S>
        </P>
        <P>
          <S ID="S-5757">reordering since only structured information is used in the tree kernel 5 .</S>
        </P>
        <P>
          <S ID="S-5758">The CTs performs the worst among the 4 structured features.</S>
          <S ID="S-5759">This suggests that the middle and high-level structures beyond base phrases are very useful for phrase reordering.</S>
          <S ID="S-5760">The MSSs show lower performance than the CMSSs and the MSTs achieve the best performance.</S>
          <S ID="S-5761">This clearly indicates that the structured context information is useful for phrase reordering.</S>
          <S ID="S-5762">For this reason, the subsequent discussions are focused on the MSTs, unless otherwise specified.</S>
          <S ID="S-5763">The MSSs without using the 5 function tags perform much worse than the original ones.</S>
          <S ID="S-5764">This suggests that the partitions of the structured feature spaces are very helpful, which can effectively avoid the undesired matching between partitions of different functionalities.</S>
          <S ID="S-5765">Comparison of K l and K l-LM shows the LM plays an important role in phrase reordering.</S>
          <S ID="S-5766">The composite kernel (K c ) performs much better than the two individual kernels.</S>
          <S ID="S-5767">This suggests that the structured and linear features are complementary and the composite kernel can well integrate them for phrase reordering.</S>
        </P>
        <P>
          <S ID="S-5768">Methods CAcc (%) Dev Test Minimum Sub-Tree (MST) 89.87 89.92 Linear Features (K l ) 90.79 90.46 Composite Kernel (K c : MST+K l ) 92.98 92.67 MaxEnt+boundary word (B2) 88.33 86.97 MaxEnt+linguistic features (B3_1) 84.83 83.92 MaxEnt+LABTG (B3: B2+ B3_1) 88.82 88.18</S>
        </P>
        <P>
          <S ID="S-5769">Table 2 compares the performance of the baseline methods with ours.</S>
          <S ID="S-5770">Comparison between B3_1 and MST clearly demonstrates that the structured syntactic features are much more effective than the linear syntactic features that are manually extracted via heuristics.</S>
          <S ID="S-5771">It also suggests that the tree kernel can well capture the structured features implicitly.</S>
          <S ID="S-5772">K l outperforms B2.</S>
          <S ID="S-5773">This is mainly due to the contribution of LM features.</S>
          <S ID="S-5774">B2 (MaxEnt-based) significantly outperforms K l-</S>
        </P>
        <P>
          <S ID="S-5775">LM in Table 1 (SVM-based).</S>
          <S ID="S-5776">This suggests that</S>
        </P>
        <P>
          <S ID="S-5777">phrase reordering may not be a good linearly binary-separable task if only boundary word features are used.</S>
          <S ID="S-5778">Our composite kernel (K c ) significantly outperforms LABTG (B3).</S>
          <S ID="S-5779">This mainly</S>
        </P>
        <P>
          <S ID="S-5780">5 The tree kernel algorithm only compares internal structures.</S>
          <S ID="S-5781">It does not concern any lexical leaf nodes.</S>
        </P>
        <P>
          <S ID="S-5782">attributes to the contributions of structured syntactic features, LM and the tree kernel.</S>
        </P>
        <P>
          <S ID="S-5783">Forced Decoding: Table 3 compares the performance of our composite kernel with that of the LABTG (Baseline 3) in forced decoding.</S>
          <S ID="S-5784">As discussed before, here we try two translation models.</S>
        </P>
        <P>
          <S ID="S-5785">The composite kernel outperforms the LABTG in all test cases.</S>
          <S ID="S-5786">This further validates the effectiveness of the kernel methods in phrase reordering.</S>
          <S ID="S-5787">There are still around 30% words reordered incorrectly even if we use the translation model trained on both training, dev and test sets.</S>
          <S ID="S-5788">This reveals the limitations of current SMT modeling methods and suggests interesting future work in this area.</S>
          <S ID="S-5789">The source language OOV 6 rate in forced decoding (13.6%) is much higher that in normal decoding (6.22%, see table 4).</S>
          <S ID="S-5790">This is mainly due to the fact that the phrase table in forced decoding is filtered out based on both source and target languages while in normal decoding it is based on source language only.</S>
          <S ID="S-5791">As a result, more phrases are filtered out in the forced decoding.</S>
          <S ID="S-5792">There is 1.4% OOV even if the translation model is trained on the test set.</S>
          <S ID="S-5793">This is due to the incorrect word alignment, large-span word alignment and different English tokenization strategies used in BLEU-scoring tool and ours.</S>
        </P>
        <P>
          <S ID="S-5794">MaxEnt+LABTG (B3) +translation model on training, dev and test 48.96 71.45 13.6 1.41 37.32 62.14</S>
        </P>
        <P>
          <S ID="S-5795">Methods Test Set BLEU(%) OOV(%) Composite Kernel (K c ) 27.65 6.26 Moses (B1) 25.71 6.17</S>
        </P>
        <P>
          <S ID="S-5796">MaxEnt+boundary word(B2) 25.99 6.22</S>
        </P>
        <P>
          <S ID="S-5797">MaxEnt+LABTG (B3) 26.63 6.22</S>
        </P>
        <P>
          <S ID="S-5798">6 OOV means a source words has no any English translation</S>
        </P>
        <P>
          <S ID="S-5799">according to the translation model.</S>
          <S ID="S-5800">OOV rate is the percentage of the number of OOV words over all the source words.</S>
        </P>
        <P>
          <S ID="S-5801">Normal Decoding/Translation: Table 4 reports the translation performance of our system and the three baseline systems.</S>
        </P>
        <P>
          <S ID="S-5802">Moses (B1) and the MaxEnt-based boundary word model (B2) achieve comparable performance.</S>
          <S ID="S-5803">This means the lexicalized orientationbased reordering model in Moses performs similarly to the boundary word-based reordering model since the two models are both lexical word-based.</S>
          <S ID="S-5804">However, theoretically, the Max- Ent-based model may suffer less from data sparseness issue since it does not depends on internal phrasal words and uses MaxEnt to optimize feature weights while the orientationbased model uses relative frequency of the entire phrases to compute the posterior probabilities.</S>
          <S ID="S-5805">s.</S>
          <S ID="S-5806">The MaxEnt-based LABTG model significantly outperforms (p&lt;0.05) the MaxEnt-based boundary word model and the lexicalized orientationbased reordering model.</S>
          <S ID="S-5807">This indicates that the linearly linguistically syntactic information is a useful feature to phrase reordering.</S>
        </P>
        <P>
          <S ID="S-5808">Our composite kernel-based model significantly outperforms (p&lt;0.01) the three baseline methods.</S>
          <S ID="S-5809">This again proves that the structured syntactic features are much more effective than the linear syntactic features for phrase reordering and the tree kernel method can well capture the informative structured features.</S>
          <S ID="S-5810">The four methods show very slight difference in OOV rates.</S>
          <S ID="S-5811">This is mainly due to the difference in implementation detail, such as different OOV penalties and other pruning thresholds.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>5 Conclusion and Future Work</HEADER>
      <P>
        <S ID="S-5813"></S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>6 OOV means a source words has no any English translation</HEADER>
      <P>
        <S ID="S-5814">according to the translation model.</S>
        <S ID="S-5815">OOV rate is the percentage of the number of OOV words over all the source words.</S>
        <S ID="S-5816">Normal Decoding/Translation: Table 4 reports the translation performance of our system and the three baseline systems.</S>
        <S ID="S-5817">Moses (B1) and the MaxEnt-based boundary word model (B2) achieve comparable performance.</S>
        <S ID="S-5818">This means the lexicalized orientationbased reordering model in Moses performs similarly to the boundary word-based reordering model since the two models are both lexical word-based.</S>
        <S ID="S-5819">However, theoretically, the Max- Ent-based model may suffer less from data sparseness issue since it does not depends on internal phrasal words and uses MaxEnt to optimize feature weights while the orientationbased model uses relative frequency of the entire phrases to compute the posterior probabilities.</S>
        <S ID="S-5820">s.</S>
        <S ID="S-5821">The MaxEnt-based LABTG model significantly outperforms (p&amp;lt;0.05) the MaxEnt-based boundary word model and the lexicalized orientationbased reordering model.</S>
        <S ID="S-5822">This indicates that the linearly linguistically syntactic information is a useful feature to phrase reordering.</S>
        <S ID="S-5823">Our composite kernel-based model significantly outperforms (p&amp;lt;0.01) the three baseline methods.</S>
        <S ID="S-5824">This again proves that the structured syntactic features are much more effective than the linear syntactic features for phrase reordering and the tree kernel method can well capture the informative structured features.</S>
        <S ID="S-5825">The four methods show very slight difference in OOV rates.</S>
        <S ID="S-5826">This is mainly due to the difference in implementation detail, such as different OOV penalties and other pruning thresholds.</S>
      </P>
      <P>
        <S ID="S-5827">Structured syntactic knowledge is very useful to phrase reordering.</S>
        <S ID="S-5828">This paper provides insights into how the structured feature can be used for phrase reordering.</S>
        <S ID="S-5829">In previous work, the structured features are selected manually by heuristics and represented by a linear feature vector.</S>
        <S ID="S-5830">This may largely compromise the contribution of the structured features to phrase reordering.</S>
        <S ID="S-5831">Thanks to the nice properties of kernel-based learning method and SVM classifier, we propose leveraging on the kernelized SVM learning algorithm to address the problem.</S>
        <S ID="S-5832">Specifically, we propose using convolution tree kernel to capture the structured features and design a composite kernel to combine the structured features and other linear features for phrase reordering.</S>
        <S ID="S-5833">The tree kernel is able to directly take the structured reordering instances as inputs and compute their similarities without enumerating them into a set of liner 705 features.</S>
        <S ID="S-5834">In addition, we also study how to find the optimal structured feature space and how to partition the structured feature spaces according to their functionalities.</S>
        <S ID="S-5835">Finally, we evaluate our method on the NIST MT-2005 Chinese-English translation tasks.</S>
        <S ID="S-5836">To provide insights into the model, we design three kinds of experiments together with three different evaluation metrics.</S>
        <S ID="S-5837">Experimental results show that the structured features are very effective and our composite kernel can well capture both the structured and the linear features without the need for extensive feature engineering.</S>
        <S ID="S-5838">It also shows that our method significantly outperforms the baseline methods.</S>
        <S ID="S-5839">The tree kernel-based phrase reordering method is not only applicable to adjacent phrases.</S>
        <S ID="S-5840">It is able to work with any long phrase pairs with gap of any length in-between.</S>
        <S ID="S-5841">We will study this case in the near future.</S>
        <S ID="S-5842">We would also like to use one individual tree kernel for one partition in a structured feature space.</S>
        <S ID="S-5843">In doing so, we are able to give different weights to different partitions according to their functionalities and contributions.</S>
        <S ID="S-5844">Note that these weights can be automatically tuned and optimized easily against a dev set.</S>
      </P>
    </DIV>
  </BODY>
  <ACKNOWLEDGMENTS/>
  <REFERENCES>
    <REFERENCE ID="0">
      <RAUTHOR>David Chiang</RAUTHOR>
      <REFTITLE>A hierarchical phrase-based model for SMT.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="1">
      <RAUTHOR>Michael Collins</RAUTHOR>
      <REFTITLE>Convolution Kernels for Natural Language.</REFTITLE>
      <DATE>2001</DATE>
    </REFERENCE>
    <REFERENCE ID="2">
      <RAUTHOR>M R Costa-juss&#224;</RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="3">
      <RAUTHOR>Brooke Cowan</RAUTHOR>
      <REFTITLE>Ivona Kucerova and Michael Collins.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="4">
      <RAUTHOR>Jason Eisner</RAUTHOR>
      <REFTITLE>Learning non-isomorphic tree mappings for MT.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="5">
      <RAUTHOR>Jakob Elming</RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="6">
      <RAUTHOR>Michel Galley</RAUTHOR>
      <REFTITLE>A Simple and Effective Hierarchical Phrase Reordering Model.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="7">
      <RAUTHOR>David Haussler</RAUTHOR>
      <REFTITLE>Convolution Kernels on Discrete Structures.</REFTITLE>
      <DATE>1999</DATE>
    </REFERENCE>
    <REFERENCE ID="8">
      <RAUTHOR>T Joachims</RAUTHOR>
      <REFTITLE>Text Categorization with SVM: learning with many relevant features.</REFTITLE>
      <DATE>1998</DATE>
    </REFERENCE>
    <REFERENCE ID="9">
      <RAUTHOR>Dan Klein</RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="10">
      <RAUTHOR>Reinhard Kenser</RAUTHOR>
      <REFTITLE>Improved backing-off for M-gram language modeling.</REFTITLE>
      <DATE>1995</DATE>
    </REFERENCE>
    <REFERENCE ID="11">
      <RAUTHOR>Philipp Koehn</RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="12">
      <RAUTHOR>Philipp Koehn</RAUTHOR>
      <REFTITLE>Moses: Open Source Toolkit for SMT.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="13">
      <RAUTHOR>Shankar Kumar</RAUTHOR>
      <REFTITLE>Local Phrase Reordering Models for Statistical Machine Translation.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="14">
      <RAUTHOR>Chi-Ho Li</RAUTHOR>
      <REFTITLE>A Probabilistic Approach to Syntax-based Reordering for Statistical Machine Translation.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="15">
      <RAUTHOR>Yang Liu</RAUTHOR>
      <REFTITLE>Forest-to-String Statistical Translation Rules.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="16">
      <RAUTHOR>Daniel Marcu</RAUTHOR>
      <REFTITLE>SPMT: SMT with Syntactified Target Language Phrases.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="17">
      <RAUTHOR>Haitao Mi</RAUTHOR>
      <REFTITLE>Forest-based Translation Rule Extraction.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="18">
      <RAUTHOR>Alessandro Moschitti</RAUTHOR>
      <REFTITLE>A Study on Convolution Kernels for Shallow Semantic Parsing.</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="19">
      <RAUTHOR>Masaaki Nagata</RAUTHOR>
      <REFTITLE>A Clustered Global Phrase Reordering Model for Statistical Machine Translation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="20">
      <RAUTHOR>Franz J Och</RAUTHOR>
      <REFTITLE>Discriminative training and maximum entropy models for statistical machine translation.</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="21">
      <RAUTHOR>Franz J Och</RAUTHOR>
      <REFTITLE>Minimum error rate training in statistical machine translation.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="22">
      <RAUTHOR>Franz J Och</RAUTHOR>
      <REFTITLE>A Systematic Comparison of Various Statistical Alignment Methods.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="23">
      <RAUTHOR>Franz J Och</RAUTHOR>
      <REFTITLE>The alignment template approach to statistical machine translation.</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="24">
      <RAUTHOR>Kishore Papineni</RAUTHOR>
      <REFTITLE>BLEU: a method for automatic evaluation of machine translation.</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="25">
      <RAUTHOR>Hendra Setiawan</RAUTHOR>
      <REFTITLE>Ordering Phrases with Function Words.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="26">
      <RAUTHOR>Libin Shen</RAUTHOR>
      <REFTITLE>A New String-to-Dependency Machine Translation Algorithm with a Target Dependency Language Model.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="27">
      <RAUTHOR>Andreas Stolcke</RAUTHOR>
      <REFTITLE>SRILM - an extensible language modeling toolkit.</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="28">
      <RAUTHOR>Christoph Tillmann</RAUTHOR>
      <REFTITLE>A Unigram Orientation Model for Statistical Machine Translation.</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="29">
      <RAUTHOR>Vladimir N Vapnik</RAUTHOR>
      <REFTITLE>The Nature of Statistical Learning Theory.</REFTITLE>
      <DATE>1995</DATE>
    </REFERENCE>
    <REFERENCE ID="30">
      <RAUTHOR>M Collins Wang</RAUTHOR>
      <REFTITLE>Chinese Syntactic Reordering for Statistical Machine Translation.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="31">
      <RAUTHOR>Dekai Wu</RAUTHOR>
      <REFTITLE>Stochastic inversion transduction grammars and bilingual parsing of parallel corpora.</REFTITLE>
      <DATE>1997</DATE>
    </REFERENCE>
    <REFERENCE ID="32">
      <RAUTHOR>Fei Xia</RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="33">
      <RAUTHOR>Deyi Xiong</RAUTHOR>
      <REFTITLE>Maximum Entropy Based Phrase Reordering Model for SMT.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="34">
      <RAUTHOR>Deyi Xiong</RAUTHOR>
      <REFTITLE>A Linguistically Annotated Reordering Model for BTG-based Statistical Machine Translation. ACL-HLT-08 (short paper).</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="35">
      <RAUTHOR>Kenji Yamada</RAUTHOR>
      <REFTITLE>A syntax-based statistical translation model.</REFTITLE>
      <DATE>2001</DATE>
    </REFERENCE>
    <REFERENCE ID="36">
      <RAUTHOR>Xiaofeng Yang</RAUTHOR>
      <REFTITLE>Kernel-Based Pronoun Resolution with Structured Syntactic Knowledge.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="37">
      <RAUTHOR>Richard Zens</RAUTHOR>
      <REFTITLE>Reordering Constraints for Phrase-Based Statistical Machine Translation.</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="38">
      <RAUTHOR>Richard Zens</RAUTHOR>
      <REFTITLE>Discriminative Reordering Models for Statistical Machine Translation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="39">
      <RAUTHOR>Dell Zhang</RAUTHOR>
      <REFTITLE>Question classification using support vector machines.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="40">
      <RAUTHOR>Min Zhang</RAUTHOR>
      <REFTITLE>A Composite Kernel to Extract Relations between Entities with Both Flat and Structured Features.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="41">
      <RAUTHOR>Dongdong Zhang</RAUTHOR>
      <REFTITLE>Phrase Reordering Model Integrating Syntactic Knowledge for SMT.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="42">
      <RAUTHOR>Min Zhang</RAUTHOR>
      <REFTITLE>A Grammar-driven Convolution Tree Kernel for Semantic Role Classification.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="43">
      <RAUTHOR>Min Zhang</RAUTHOR>
      <REFTITLE>A Tree-to-Tree Alignment-based Model for Statistical Machine Translation.MT-Summit-07.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="44">
      <RAUTHOR>Min Zhang</RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
  </REFERENCES>
</PAPER>
