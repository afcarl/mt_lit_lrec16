<PAPER>
  <FILENO/>
  <TITLE>Tuning as Ranking</TITLE>
  <AUTHORS>
    <AUTHOR>Mark Hopkins</AUTHOR>
  </AUTHORS>
  <ABSTRACT>
    <A-S ID="S-11047">We offer a simple, effective, and scalable method for statistical machine translation parameter tuning based on the pairwise approach to ranking (<REF ID="R-17" RPTR="26">Herbrich et al., 1999</REF>).</A-S>
    <A-S ID="S-11048">Unlike the popular MERT algorithm (<REF ID="R-30" RPTR="43">Och, 2003</REF>), our pairwise ranking optimization (PRO) method is not limited to a handful of parameters and can easily handle systems with thousands of features.</A-S>
    <A-S ID="S-11049">Moreover, unlike recent approaches built upon the MIRA algorithm of Crammer and Singer (2003) (<REF ID="R-38" RPTR="58">Watanabe et al., 2007</REF>; <REF ID="R-06" RPTR="11">Chiang et al., 2008</REF>b), PRO is easy to implement.</A-S>
    <A-S ID="S-11050">It uses off-the-shelf linear binary classifier software and can be built on top of an existing MERT framework in a matter of hours.</A-S>
    <A-S ID="S-11051">We establish PRO&#8217;s scalability and effectiveness by comparing it to MERT and MIRA and demonstrate parity on both phrase-based and syntax-based systems in a variety of language pairs, using large scale data scenarios.</A-S>
  </ABSTRACT>
  <BODY>
    <DIV DEPTH="0">
      <HEADER>1 Introduction</HEADER>
      <P>
        <S ID="S-11052">The MERT algorithm (<REF ID="R-30" RPTR="44">Och, 2003</REF>) is currently the most popular way to tune the parameters of a statistical machine translation (MT) system.</S>
        <S ID="S-11053">MERT is well-understood, easy to implement, and runs quickly, but can behave erratically and does not scale beyond a handful of features.</S>
        <S ID="S-11054">This lack of scalability is a significant weakness, as it inhibits systems from using more than a couple dozen features to discriminate between candidate translations and stymies feature development innovation.</S>
      </P>
      <P>
        <S ID="S-11055">Several researchers have attempted to address this weakness.</S>
        <S ID="S-11056">Recently, <REF ID="R-38" RPTR="54">Watanabe et al. (2007)</REF> and <REF ID="R-06" RPTR="7">Chiang et al. (2008</REF>b) have developed tuning methods using the MIRA algorithm (<REF ID="R-10" RPTR="19">Crammer and Singer, 2003</REF>) as a nucleus.</S>
        <S ID="S-11057">The MIRA technique of Chiang et al. has been shown to perform well on large-scale tasks with hundreds or thousands of features (2009).</S>
        <S ID="S-11058">However, the technique is complex and architecturally quite different from MERT.</S>
        <S ID="S-11059">Tellingly, in the entire proceedings of ACL 2010 (Haji&#269; et al., 2010), only one paper describing a statistical MT system cited the use of MIRA for tuning (<REF ID="R-08" RPTR="18">Chiang, 2010</REF>), while 15 used MERT.</S>
        <S ID="S-11060">1</S>
      </P>
      <P>
        <S ID="S-11061">Here we propose a simpler approach to tuning that scales similarly to high-dimensional feature spaces.</S>
        <S ID="S-11062">We cast tuning as a ranking problem (<REF ID="R-03" RPTR="5">Chen et al., 2009</REF>), where the explicit goal is to learn to correctly rank candidate translations.</S>
        <S ID="S-11063">Specifically, we follow the pairwise approach to ranking (<REF ID="R-17" RPTR="27">Herbrich et al., 1999</REF>; <REF ID="R-12" RPTR="20">Freund et al., 2003</REF>; <REF ID="R-00" RPTR="0">Burges et al., 2005</REF>; <REF ID="R-01" RPTR="2">Cao et al., 2007</REF>), in which the ranking problem is reduced to the binary classification task of deciding between candidate translation pairs.</S>
      </P>
      <P>
        <S ID="S-11064">Of primary concern to us is the ease of adoption of our proposed technique.</S>
        <S ID="S-11065">Because of this, we adhere as closely as possible to the established MERT architecture and use freely available machine learning software.</S>
        <S ID="S-11066">The end result is a technique that scales and performs just as well as MIRA-based tuning, but which can be implemented in a couple of hours by anyone with an existing MERT implementation.</S>
        <S ID="S-11067">Mindful that many would-be enhancements to the</S>
      </P>
      <P>
        <S ID="S-11068">1 The remainder either did not specify their tuning method</S>
      </P>
      <P>
        <S ID="S-11069">(though a number of these used the Moses toolkit (<REF ID="R-19" RPTR="30">Koehn et al., 2007</REF>), which uses MERT for tuning) or, in one case, set weights by hand.</S>
      </P>
      <P>
        <S ID="S-11070">state-of-the-art are false positives that only show improvement in a narrowly defined setting or with limited data, we validate our claims on both syntax and phrase-based systems, using multiple language pairs and large data sets.</S>
      </P>
      <P>
        <S ID="S-11071">We describe tuning in abstract and somewhat formal terms in Section 2, describe the MERT algorithm in the context of those terms and illustrate its scalability issues via a synthetic experiment in Section 3, introduce our pairwise ranking optimization method in Section 4, present numerous large-scale MT experiments to validate our claims in Section 5, discuss some related work in Section 6, and conclude in Section 7.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>2 Tuning</HEADER>
      <P>
        <S ID="S-11072">In Figure 1, we show an example candidate space, defined as a tuple &#12296;&#8710;, I, J, f, e, x&#12297; where:</S>
      </P>
      <P>
        <S ID="S-11073">&#8226; &#8710; is a positive integer referred to as the dimensionality of the space</S>
      </P>
      <P>
        <S ID="S-11074">&#8226; I is a (possibly infinite) set of positive integers, referred to as sentence indices</S>
      </P>
      <P>
        <S ID="S-11075">&#8226; J maps each sentence index to a (possibly infinite) set of positive integers, referred to as candidate indices</S>
      </P>
      <P>
        <S ID="S-11076">&#8226; f maps each sentence index to a sentence from the source language</S>
      </P>
      <P>
        <S ID="S-11077">&#8226; e maps each pair &#12296;i, j&#12297; &#8712; I &#215; J(i) to the j th target-language candidate translation of source sentence f(i)</S>
      </P>
      <P>
        <S ID="S-11078">&#8226; x maps each pair &#12296;i, j&#12297; &#8712; I &#215; J(i) to a &#8710;-dimension feature vector representation of e(i, j)</S>
      </P>
      <P>
        <S ID="S-11079">The example candidate space has two source sentences, three candidate translations for each source sentence, and feature vectors of dimension 2.</S>
        <S ID="S-11080">It is an example of a finite candidate space, defined as a candidate space for which I is finite and J maps each index of I to a finite set.</S>
      </P>
      <P>
        <S ID="S-11081">A policy of candidate space &#12296;&#8710;, I, J, f, e, x&#12297; is a function that maps each member i &#8712; I to a member of J(i).</S>
        <S ID="S-11082">A policy corresponds to a choice of one candidate translation for each source sentence.</S>
        <S ID="S-11083">For the example in Figure 1, policy p 1 = {1 &#8614;&#8594; 2, 2 &#8614;&#8594; 3} corresponds to the choice of &#8220;he does not go&#8221; for the first source sentence and &#8220;I do not go&#8221; for the second source sentence.</S>
        <S ID="S-11084">Obviously some policies are better than others.</S>
        <S ID="S-11085">Policy p 2 = {1 &#8614;&#8594; 3, 2 &#8614;&#8594; 1} corresponds to the inferior translations &#8220;she not go&#8221; and &#8220;I go not.&#8221;</S>
      </P>
      <P>
        <S ID="S-11086">We assume the MT system distinguishes between policies using a scoring function for candidate translations of the form h w (i, j) = w &#183; x(i, j), where w is a weight vector of the same dimension as feature vector x(i, j).</S>
        <S ID="S-11087">This scoring function extends to a policy p by summing the cost of each of the policy&#8217;s candidate translations: H w (p) = &#8721; i&#8712;I h w(i, p(i)).</S>
        <S ID="S-11088">As can be seen in Figure 1, using w = [&#8722;2, 1], H w (p 1 ) = 9 and H w (p 2 ) = &#8722;8.</S>
      </P>
      <P>
        <S ID="S-11089">The goal of tuning is to learn a weight vector w such that H w (p) assigns a high score to good policies, and a low score to bad policies.</S>
        <S ID="S-11090">2 To do so, we need information about which policies are good and which are bad.</S>
        <S ID="S-11091">This information is provided by a &#8220;gold&#8221; scoring function G that maps each policy to a real-valued score.</S>
        <S ID="S-11092">Typically this gold function is BLEU (<REF ID="R-31" RPTR="46">Papineni et al., 2002</REF>), though there are several common alternatives (<REF ID="R-21" RPTR="33">Lavie and Denkowski, 2009</REF>; <REF ID="R-26" RPTR="39">Melamed et al., 2003</REF>; <REF ID="R-34" RPTR="50">Snover et al., 2006</REF>; <REF ID="R-06" RPTR="12">Chiang et al., 2008</REF>a).</S>
      </P>
      <P>
        <S ID="S-11093">We want to find a weight vector w such that H w behaves &#8220;similarly&#8221; to G on a candidate space s.</S>
        <S ID="S-11094">We assume a loss function l s (H w , G) which returns the real-valued loss of using scoring function H w when the gold scoring function is G and the candidate space is s.</S>
        <S ID="S-11095">Thus, we may say the goal of tuning is to find the weight vector w that minimizes loss.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>3 MERT</HEADER>
      <P>
        <S ID="S-11096">In general, the candidate space may have infinitely many source sentences, as well as infinitely many candidate translations per source sentence.</S>
        <S ID="S-11097">In practice, tuning optimizes over a finite subset of source sentences 3 and a finite subset of candidate translations as well.</S>
        <S ID="S-11098">The classic tuning architecture used in the dominant MERT approach (<REF ID="R-30" RPTR="45">Och, 2003</REF>) forms the translation subset and learns weight vector w via</S>
      </P>
      <P>
        <S ID="S-11099">2 Without loss of generality, we assume that a higher score</S>
      </P>
      <P>
        <S ID="S-11100">indicates a better translation.</S>
        <S ID="S-11101">3 See Section 5.2 for the tune sets used in this paper&#8217;s experiments.</S>
      </P>
      <P>
        <S ID="S-11102">Algorithm TUNE(s, G):</S>
      </P>
      <P>
        <S ID="S-11103">1: initialize pool: let s &#8242; = &#12296;&#8710;, I &#8242; , J &#8242; , f, e, x&#12297;,</S>
      </P>
      <P>
        <S ID="S-11104">where I &#8242; &#8838; I and J &#8242; = &#8709;</S>
      </P>
      <P>
        <S ID="S-11105">2: for the desired number of iterations do</S>
      </P>
      <P>
        <S ID="S-11106">3: candidate generation: choose index pairs</S>
      </P>
      <P>
        <S ID="S-11107">(i, j); for each, add j to J &#8242; (i)</S>
      </P>
      <P>
        <S ID="S-11108">4: optimization: find vector w that minimizes</S>
      </P>
      <P>
        <S ID="S-11109">l s &#8242;(H w , G)</S>
      </P>
      <P>
        <S ID="S-11110">5: return w</S>
      </P>
      <P>
        <S ID="S-11111">a feedback loop consisting of two phases.</S>
        <S ID="S-11112">Figure 2 shows the pseudocode.</S>
        <S ID="S-11113">During candidate generation, candidate translations are selected from a base candidate space s and added to a finite candidate space s &#8242; called the candidate pool.</S>
        <S ID="S-11114">During optimization, the weight vector w is optimized to minimize loss l s &#8242;(H w , G).</S>
      </P>
      <P>
        <S ID="S-11115">For its candidate generation phase, MERT generates the k-best candidate translations for each source sentence according to h w , where w is the weight vector from the previous optimization phase (or an arbitrary weight vector for the first iteration).</S>
      </P>
      <P>
        <S ID="S-11116">For its optimization phase, MERT defines the loss function as follows:</S>
      </P>
      <P>
        <S ID="S-11117">l s (H w , G) = max</S>
      </P>
      <P>
        <S ID="S-11118">p</S>
      </P>
      <P>
        <S ID="S-11119">G(p) &#8722; G(arg max H w (p))</S>
      </P>
      <P>
        <S ID="S-11120">p</S>
      </P>
      <P>
        <S ID="S-11121">In other words, it prefers weight vectors w such that the gold function G scores H w &#8217;s best policy as highly as possible (if H w &#8217;s best policy is the same as G&#8217;s best policy, then there is zero loss).</S>
        <S ID="S-11122">Typically the optimization phase is implemented using Och&#8217;s line optimization algorithm (2003).</S>
      </P>
      <P>
        <S ID="S-11123">MERT has proven itself effective at tuning candidate spaces with low dimensionality.</S>
        <S ID="S-11124">However, it is often claimed that MERT does not scale well with dimensionality.</S>
        <S ID="S-11125">To test this claim, we devised the following synthetic data experiment:</S>
      </P>
      <P>
        <S ID="S-11126">1.</S>
        <S ID="S-11127">We created a gold scoring function G that is also a linear function of the same form as H w , i.e., G(p) = H w &#8727;(p) for some gold weight vector w &#8727; .</S>
        <S ID="S-11128">Under this assumption, the role of the optimization phase reduces to learning back the gold weight vector w &#8727; .</S>
      </P>
      <P>
        <S ID="S-11129">2.</S>
        <S ID="S-11130">We generated a &#8710;-dimensionality candidate pool with 500 source &#8220;sentences&#8221; and 100 candidate &#8220;translations&#8221; per sentence.</S>
        <S ID="S-11131">We created the corresponding feature vectors by drawing &#8710; random real numbers uniformly from the interval [0, 500].</S>
      </P>
      <P>
        <S ID="S-11132">3.</S>
        <S ID="S-11133">We ran MERT&#8217;s line optimization on this synthetic candidate pool and compared the learned weight vector w to the gold weight vector w &#8727; using cosine similarity.</S>
      </P>
      <P>
        <S ID="S-11134">We used line optimization in the standard way, by generating 20 random starting weight vectors and hill-climbing on each independently until no further progress is made, then choosing the final weight vector that minimizes loss.</S>
        <S ID="S-11135">We tried various dimensionalities from 10 to 1000.</S>
        <S ID="S-11136">We repeated each setting three times, generating different random data each time.</S>
        <S ID="S-11137">The results in Figure 3 indicate that as the dimensionality of the problem increases MERT rapidly loses the ability to learn w &#8727; .</S>
        <S ID="S-11138">Note that this synthetic problem is considerably easier than a real MT scenario, where the data is noisy and interdependent, and the gold scoring function is nonlinear.</S>
        <S ID="S-11139">If</S>
      </P>
      <P>
        <S ID="S-11140">MERT cannot scale in this simple scenario, it has little hope of succeeding in a high-dimensionality deployment scenario.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>4 Optimization via Pairwise Ranking</HEADER>
      <P>
        <S ID="S-11204">We would like to modify MERT so that it scales well to high-dimensionality candidate spaces.</S>
        <S ID="S-11205">The most prominent example of a tuning method that performs well on high-dimensionality candidate spaces is the MIRA-based approach used by <REF ID="R-38" RPTR="55">Watanabe et al. (2007)</REF> and <REF ID="R-06" RPTR="8">Chiang et al. (2008</REF>b; 2009).</S>
        <S ID="S-11206">Unfortunately, this approach requires a complex architecture that diverges significantly from the MERT approach, and consequently has not been widely adopted.</S>
        <S ID="S-11207">Our goal is to achieve the same performance with minimal modification to MERT.</S>
      </P>
      <P>
        <S ID="S-11208">With MERT as a starting point, we have a choice: modify candidate generation, optimization, or both.</S>
        <S ID="S-11209">Although alternative candidate generation methods have been proposed (<REF ID="R-23" RPTR="36">Macherey et al., 2008</REF>; <REF ID="R-06" RPTR="13">Chiang et al., 2008</REF>b; <REF ID="R-02" RPTR="4">Chatterjee and Cancedda, 2010</REF>), we will restrict ourselves to MERT-style candidate generation, in order to minimize divergence from the established MERT tuning architecture.</S>
        <S ID="S-11210">Instead, we focus on the optimization phase.</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>4.1 Basic Approach</HEADER>
        <P>
          <S ID="S-11141">While intuitive, the MERT optimization module focuses attention on H w &#8217;s best policy, and not on its overall prowess at ranking policies.</S>
          <S ID="S-11142">We will create an optimization module that directly addresses H w &#8217;s ability to rank policies in the hope that this more holistic approach will generalize better to unseen data.</S>
        </P>
        <P>
          <S ID="S-11143">Assume that the gold scoring function G decomposes in the following way:</S>
        </P>
        <P>
          <S ID="S-11144">G(p) = &#8721; i&#8712;I g(i, p(i)) (1)</S>
        </P>
        <P>
          <S ID="S-11145">where g(i, j) is a local scoring function that scores the single candidate translation e(i, j).</S>
          <S ID="S-11146">We show an example g in Figure 1.</S>
          <S ID="S-11147">For an arbitrary pair of candidate translations e(i, j) and e(i, j &#8242; ), the local gold function g tells us which is the better translation.</S>
          <S ID="S-11148">Note that this induces a ranking on the candidate translations for each source sentence.</S>
        </P>
        <P>
          <S ID="S-11149">We follow the pairwise approach to ranking (<REF ID="R-17" RPTR="28">Herbrich et al., 1999</REF>; <REF ID="R-12" RPTR="21">Freund et al., 2003</REF>; <REF ID="R-00" RPTR="1">Burges et al., 2005</REF>; <REF ID="R-01" RPTR="3">Cao et al., 2007</REF>).</S>
          <S ID="S-11150">In the pairwise approach, the learning task is framed as the classification of candidate pairs into two categories: correctly ordered and incorrectly ordered.</S>
          <S ID="S-11151">Specifically, for candidate translation pair e(i, j) and e(i, j &#8242; ), we want: g(i, j) &gt; g(i, j &#8242; ) &#8660; h w (i, j) &gt; h w (i, j &#8242; ).</S>
          <S ID="S-11152">We can re-express this condition: g(i, j) &gt; g(i, j &#8242; ) &#8660; h w (i, j) &gt; h w (i, j &#8242; )</S>
        </P>
        <P>
          <S ID="S-11153">&#8660; h w (i, j) &#8722; h w (i, j &#8242; ) &gt; 0</S>
        </P>
        <P>
          <S ID="S-11154">&#8660; w &#183; x(i, j) &#8722; w &#183; x(i, j &#8242; ) &gt; 0</S>
        </P>
        <P>
          <S ID="S-11155">&#8660; w &#183; (x(i, j) &#8722; x(i, j &#8242; )) &gt; 0</S>
        </P>
        <P>
          <S ID="S-11156">Thus optimization reduces to a classic binary classification problem.</S>
          <S ID="S-11157">We create a labeled training instance for this problem by computing difference vector x(i, j) &#8722; x(i, j &#8242; ), and labeling it as a positive or negative instance based on whether, respectively, the first or second vector is superior according to gold function g. To ensure balance, we consider both possible difference vectors from a pair.</S>
          <S ID="S-11158">For example, given the candidate space of Figure 1, since g(1, 1) &gt; g(1, 3), we would add ([&#8722;4, 3], +) and ([4, &#8722;3], &#8722;) to our training set.</S>
          <S ID="S-11159">We can then feed this training data directly to any off-the-shelf classification tool that returns a linear classifier, in order to obtain a weight vector w that optimizes the above condition.</S>
          <S ID="S-11160">This weight vector can then be used directly by the MT system in the subsequent candidate generation phase.</S>
          <S ID="S-11161">The exact loss function l s &#8242;(H w , G) optimized depends on the choice of classifier.</S>
          <S ID="S-11162">4 Typical approaches to pairwise ranking enumerate all difference vectors as training data.</S>
          <S ID="S-11163">For tuning however, this means O(|I| &#8727; Jmax) 2 vectors, where J max is the cardinality of the largest J(i).</S>
          <S ID="S-11164">Since I and J max commonly range in the thousands, a full enumeration would produce billions of feature vectors.</S>
          <S ID="S-11165">Out of tractability considerations, we sample from the space of difference vectors, using the sampler template in Figure 4.</S>
          <S ID="S-11166">For each source sentence i, the sampler generates &#915; candidate translation pairs &#12296;j, j &#8242; &#12297;, and accepts each pair with probability &#945; i (|g(i, j) &#8722; g(i, j &#8242; )|).</S>
          <S ID="S-11167">Among the accepted pairs, it keeps the &#926; with greatest g differential, and adds their difference vectors to the training data.</S>
          <S ID="S-11168">5</S>
        </P>
        <P>
          <S ID="S-11169">4 See (<REF ID="R-03" RPTR="6">Chen et al., 2009</REF>) for a brief survey.</S>
          <S ID="S-11170">5 The intuition for biasing toward high score differential is</S>
        </P>
        <P>
          <S ID="S-11171">Cosine similarity of learned parameter weights</S>
        </P>
        <P>
          <S ID="S-11172">0.8</S>
        </P>
        <P>
          <S ID="S-11173">0.6</S>
        </P>
        <P>
          <S ID="S-11174">0.4</S>
        </P>
        <P>
          <S ID="S-11175">0.2</S>
        </P>
        <P>
          <S ID="S-11176">Synthetic parameter learning of MERT and PRO</S>
        </P>
        <P>
          <S ID="S-11177">PRO Noisy PRO</S>
        </P>
        <P>
          <S ID="S-11178">MERT Noisy MERT</S>
        </P>
        <P>
          <S ID="S-11179">0 0 200 400 600 800 1000 Dimensionality</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>4.2 Scalability</HEADER>
        <P>
          <S ID="S-11180">We repeated the scalability study from Section 3, now using our pairwise ranking optimization (hereafter, PRO) approach.</S>
          <S ID="S-11181">Throughout all experiments with PRO we choose &#915; = 5000, &#926; = 50, and the following step function &#945; for each &#945; i : 6 {</S>
        </P>
        <P>
          <S ID="S-11182">0 if n &lt; 0.05 &#945;(n) = 1 otherwise</S>
        </P>
        <P>
          <S ID="S-11183">We used MegaM (Daum&#233; III, 2004) as a binary classifier in our contrasting synthetic experiment and ran it &#8220;out of the box,&#8221; i.e., with all default settings for binary classification.</S>
          <S ID="S-11184">7 Figure 3 shows that PRO is able to learn w &#8727; nearly perfectly at all dimensionalities from 10 to 1000.</S>
        </P>
        <P>
          <S ID="S-11185">As noted previously, though, this is a rather simple task.</S>
          <S ID="S-11186">To encourage a disconnect between g and h w and make the synthetic scenario look more like MT reality, we repeated the synthetic experiments</S>
        </P>
        <P>
          <S ID="S-11187">that our primary goal is to ensure good translations are preferred to bad translations, and not to tease apart small differences.</S>
          <S ID="S-11188">6 We obtained these parameters by trial-and-error experimentation on a single MT system (Urdu-English SBMT), then held them fixed throughout our experiments.</S>
          <S ID="S-11189">We obtained similar results using &#915; = &#926; = 100, and for each &#945; i, a logistic sigmoid function centered at the mean g differential of candidate translation pairs for the i th source sentence.</S>
          <S ID="S-11190">This alternative approach has the advantage of being agnostic about which gold scoring function is used.</S>
          <S ID="S-11191">7 With the sampling settings previously described and</S>
        </P>
        <P>
          <S ID="S-11192">MegaM as our classifier we were able to optimize two to three times faster than with MERT&#8217;s line optimization.</S>
        </P>
        <P>
          <S ID="S-11193">but added noise to each feature vector, drawn from a zero-mean Gaussian with a standard deviation of 500.</S>
          <S ID="S-11194">The results of the noisy synthetic experiments, also in Figure 3 (the lines labeled &#8220;Noisy&#8221;), show that the pairwise ranking approach is less successful than before at learning w &#8727; at high dimensionality, but still greatly outperforms MERT.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>4.3 Discussion</HEADER>
        <P>
          <S ID="S-11195">The idea of learning from difference vectors also lies at the heart of the MIRA-based approaches (<REF ID="R-38" RPTR="59">Watanabe et al., 2007</REF>; <REF ID="R-06" RPTR="14">Chiang et al., 2008</REF>b) and the approach of <REF ID="R-32" RPTR="48">Roth et al. (2010)</REF><REF ID="R-15" RPTR="24">(2010)</REF>, which, similar to our method, uses sampling to select vectors.</S>
          <S ID="S-11196">Here, we isolate these aspects of those approaches to create a simpler tuning technique that closely mirrors the ubiquitous MERT architecture.</S>
          <S ID="S-11197">Among other simplifications, we abstract away the choice of MIRA as the classification method (our approach can use any classification technique that learns a separating hyperplane), and we eliminate the need for oracle translations.</S>
          <S ID="S-11198">An important observation is that BLEU does not satisfy the decomposability assumption of Equation (1).</S>
          <S ID="S-11199">An advantage of MERT is that it can directly optimize for non-decomposable scoring functions like BLEU.</S>
          <S ID="S-11200">In our experiments, we use the BLEU+1 approximation to BLEU (<REF ID="R-22" RPTR="34">Liang et al., 2006</REF>) to determine class labels.</S>
          <S ID="S-11201">We will nevertheless use BLEU to evaluate the trained systems.</S>
        </P>
        <P>
          <S ID="S-11202">BLEU.</S>
          <S ID="S-11203">For every choice of system, language pair, and feature set, PRO performs comparably with the other methods.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>5 Experiments</HEADER>
      <P>
        <S ID="S-11290">We now turn to real machine translation conditions to validate our thesis: We can cleanly replace MERT&#8217;s line optimization with pairwise ranking optimization and immediately realize the benefits of high-dimension tuning.</S>
        <S ID="S-11291">We now detail the three language pairs, two feature scenarios, and two MT models used for our experiments.</S>
        <S ID="S-11292">For each language pair and each MT model we used MERT, MIRA, and PRO to tune with a standard set of baseline features, and used the latter two methods to tune with an extended set of features.</S>
        <S ID="S-11293">8 At the end of every experiment we used the final feature weights to decode a held-out test set and evaluated it with case-sensitive</S>
      </P>
      <P>
        <S ID="S-11294">BLEU.</S>
        <S ID="S-11295">The results are in Table 1.</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>5.1 Systems</HEADER>
        <P>
          <S ID="S-11211">We used two systems, each based on a different MT model.</S>
          <S ID="S-11212">Our syntax-based system (hereafter, SBMT) follows the model of <REF ID="R-13" RPTR="22">Galley et al. (2004)</REF>.</S>
          <S ID="S-11213">Our</S>
        </P>
        <P>
          <S ID="S-11214">8 MERT could not run to a satisfactory completion in any</S>
        </P>
        <P>
          <S ID="S-11215">extended feature scenario; as implied in the synthetic data experiment of Section 3, the algorithm makes poor choices for its weights and this leads to low-quality k-best lists and dismal performance, near 0 BLEU in every iteration.</S>
        </P>
        <P>
          <S ID="S-11216">phrase-based system (hereafter, PBMT) follows the model of <REF ID="R-29" RPTR="42">Och and Ney (2004)</REF>.</S>
          <S ID="S-11217">In both systems we learn alignments with GIZA++ (<REF ID="R-27" RPTR="40">Och and Ney, 2000</REF>) using IBM Model 4; for Urdu-English and Chinese-English we merged alignments with the refined method, and for Arabic-English we merged with the union method.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>5.2 Data</HEADER>
        <P>
          <S ID="S-11218">Table 2 notes the sizes of the datasets used in our experiments.</S>
          <S ID="S-11219">All tune and test data have four English reference sets for the purposes of scoring.</S>
        </P>
        <P>
          <S ID="S-11220">5.2.1 Urdu-English</S>
        </P>
        <P>
          <S ID="S-11221">The training data for Urdu-English is that made available in the constrained track in the NIST 2009 MT evaluation.</S>
          <S ID="S-11222">This includes many lexicon entries and other single-word data, which accounts for the large number of lines relative to word count.</S>
          <S ID="S-11223">The NIST 2008 evaluation set, which contains newswire and web data, is split into two parts; we used roughly half each for tune and test.</S>
          <S ID="S-11224">We trained a 5-gram English language model on the English side of the training data.</S>
        </P>
        <P>
          <S ID="S-11225">5.2.2 Arabic-English</S>
        </P>
        <P>
          <S ID="S-11226">The training data for Arabic English is that made available in the constrained track in the NIST 2008 MT evaluation.</S>
          <S ID="S-11227">The tune set, which contains only newswire data, is a mix from NIST MT evaluation sets from 2003&#8211;2006 and from GALE development data.</S>
          <S ID="S-11228">The test set, which contains both web and newswire data, is the evaluation set from the NIST 2008 MT evaluation.</S>
          <S ID="S-11229">We trained a 4-gram English language model on the English side of the training data.</S>
        </P>
        <P>
          <S ID="S-11230">5.2.3 Chinese-English</S>
        </P>
        <P>
          <S ID="S-11231">For Chinese-English we used 173M words of training data from GALE 2008.</S>
          <S ID="S-11232">For SBMT we used a 32M word subset for extracting rules and building a language model, but used the entire training data for alignments, and for all PBMT training.</S>
          <S ID="S-11233">The tune and test sets both contain web and newswire data.</S>
          <S ID="S-11234">The tune set is selected from NIST MT evaluation sets from 2003&#8211;2006.</S>
          <S ID="S-11235">The test set is the evaluation set from the NIST 2008 MT evaluation.</S>
          <S ID="S-11236">We trained a 3-gram English language model on the English side of the training data.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>5.3 Features</HEADER>
        <P>
          <S ID="S-11237">For each of our systems we identify two feature sets: baseline, which correspond to the typical small feature set reported in current MT literature, and extended, a superset of baseline, which adds hundreds or thousands of features.</S>
          <S ID="S-11238">Specifically, we use 15 baseline features for PBMT, similar to the baseline features described by <REF ID="R-38" RPTR="56">Watanabe et al. (2007)</REF>.</S>
          <S ID="S-11239">We use 19 baseline features for SBMT, similar to the baseline features described by <REF ID="R-06" RPTR="9">Chiang et al. (2008</REF>b).</S>
          <S ID="S-11240">We used the following feature classes in SBMT and PBMT extended scenarios:</S>
        </P>
        <P>
          <S ID="S-11241">&#8226; Discount features for rule frequency bins (cf. <REF ID="R-07" RPTR="15">Chiang et al. (2009)</REF>, Section 4.1)</S>
        </P>
        <P>
          <S ID="S-11242">&#8226; Target word insertion features 9</S>
        </P>
        <P>
          <S ID="S-11243">We used the following feature classes in SBMT extended scenarios only (cf. <REF ID="R-07" RPTR="16">Chiang et al. (2009)</REF>, Section 4.1): 10</S>
        </P>
        <P>
          <S ID="S-11244">&#8226; Rule overlap features</S>
        </P>
        <P>
          <S ID="S-11245">&#8226; Node count features</S>
        </P>
        <P>
          <S ID="S-11246">9 For Chinese-English and Urdu-English SBMT these features only fired when the inserted target word was unaligned to any source word.</S>
          <S ID="S-11247">10 The parser used for Arabic-English had a different nonterminal set than that used for the other two SBMT systems, accounting for the wide disparity in feature count for these feature classes.</S>
        </P>
        <P>
          <S ID="S-11248">We used the following feature classes in PBMT extended scenarios only:</S>
        </P>
        <P>
          <S ID="S-11249">&#8226; Unigram word pair features for the 80 most frequent words in both languages plus tokens for unaligned and all other words (cf. <REF ID="R-38" RPTR="57">Watanabe et al. (2007)</REF>, Section 3.2.1) 11</S>
        </P>
        <P>
          <S ID="S-11250">&#8226; Source, target, and joint phrase length features from 1 to 7, e.g. &#8220;tgt=4&#8221;, &#8220;src=2&#8221;, and &#8220;src/tgt=2,4&#8221;</S>
        </P>
        <P>
          <S ID="S-11251">The feature classes and number of features used within those classes for each language pair are summarized in Table 3.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>5.4 Tuning settings</HEADER>
        <P>
          <S ID="S-11252">Each of the three approaches we compare in this study has various details associated with it that may prove useful to those wishing to reproduce our results.</S>
          <S ID="S-11253">We list choices made for the various tuning methods here, and note that all our decisions were made in keeping with best practices for each algorithm.</S>
        </P>
        <P>
          <S ID="S-11254">5.4.1 MERT</S>
        </P>
        <P>
          <S ID="S-11255">We used David Chiang&#8217;s CMERT implementation of MERT that is available with the Moses system (<REF ID="R-19" RPTR="31">Koehn et al., 2007</REF>).</S>
          <S ID="S-11256">We ran MERT for up to 30 iterations, using k = 1500, and stopping early when</S>
        </P>
        <P>
          <S ID="S-11257">11 This constitutes 6,723 features in principle (82 2 &#8722; 1 since</S>
        </P>
        <P>
          <S ID="S-11258">&#8220;unaligned-unaligned&#8221; is not considered) but in practice far fewer co-occurrences were seen.</S>
          <S ID="S-11259">Table 3 shows the number of actual unigram word pair features observed in data.</S>
        </P>
        <P>
          <S ID="S-11260">the accumulated k-best list does not change in an iteration.</S>
          <S ID="S-11261">In every tuning iteration we ran MERT once with weights initialized to the last iteration&#8217;s chosen weight set and 19 times with random weights, and chose the the best of the 20 ending points according to G on the development set.</S>
          <S ID="S-11262">The G we optimize is tokenized, lower-cased 4-gram BLEU (<REF ID="R-31" RPTR="47">Papineni et al., 2002</REF>).</S>
        </P>
        <P>
          <S ID="S-11263">5.4.2 MIRA</S>
        </P>
        <P>
          <S ID="S-11264">We for the most part follow the MIRA algorithm for machine translation as described by <REF ID="R-07" RPTR="17">Chiang et al. (2009)</REF> 12 but instead of using the 10-best of each of the best h w , h w +g, and h w -g, we use the 30-best according to h w .</S>
          <S ID="S-11265">13 We use the same sentence-level</S>
        </P>
        <P>
          <S ID="S-11266">BLEU calculated in the context of previous 1-best</S>
        </P>
        <P>
          <S ID="S-11267">translations as <REF ID="R-06" RPTR="10">Chiang et al. (2008</REF>b; 2009).</S>
          <S ID="S-11268">We ran MIRA for 30 iterations.</S>
        </P>
        <P>
          <S ID="S-11269">5.4.3 PRO</S>
        </P>
        <P>
          <S ID="S-11270">We used the MegaM classifier and sampled as described in Section 4.2.</S>
          <S ID="S-11271">As previously noted, we used</S>
        </P>
        <P>
          <S ID="S-11272">BLEU+1 (<REF ID="R-22" RPTR="35">Liang et al., 2006</REF>) for g. MegaM was easy</S>
        </P>
        <P>
          <S ID="S-11273">to set up and ran fairly quickly, however any linear binary classifier that operates on real-valued features can be used, and in fact we obtained similar results</S>
        </P>
        <P>
          <S ID="S-11274">12 and acknowledge the use of David Chiang&#8217;s code 13 This is a more realistic scenario for would-be implementers</S>
        </P>
        <P>
          <S ID="S-11275">of MIRA, as obtaining the so-called &#8220;hope&#8221; and &#8220;fear&#8221; translations from the lattice or forest is significantly more complicated than simply obtaining a k-best list.</S>
          <S ID="S-11276">Other tests comparing these methods have shown between 0.1 to 0.3 BLEU drop using 30- best h w on Chinese-English (<REF ID="R-36" RPTR="52">Wang, 2011</REF>).</S>
        </P>
        <P>
          <S ID="S-11277">using the support vector machine module of WEKA (<REF ID="R-16" RPTR="25">Hall et al., 2009</REF>) as well as the Stanford classifier (<REF ID="R-25" RPTR="38">Manning and Klein, 2003</REF>).</S>
          <S ID="S-11278">We ran for up to 30 iterations and used the same k and stopping criterion as was used for MERT, though variability of sampling precluded list convergence.</S>
        </P>
        <P>
          <S ID="S-11279">While MERT and MIRA use each iteration&#8217;s final weights as a starting point for hill-climbing the next iteration, the pairwise ranking approach has no explicit tie to previous iterations.</S>
          <S ID="S-11280">To incorporate such stability into our process we interpolated the weights w &#8242; learned by the classifier in iteration t with those from iteration t &#8722; 1 by a factor of &#936;, such that w t = &#936; &#183; w &#8242; + (1 &#8722; &#936;) &#183; w t&#8722;1 .</S>
          <S ID="S-11281">We found &#936; = 0.1 gave good performance across the board.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>5.5 Discussion</HEADER>
        <P>
          <S ID="S-11282">We implore the reader to avoid the natural tendency to compare results using baseline vs. extended features or between PBMT and SBMT on the same language pair.</S>
          <S ID="S-11283">Such discussions are indeed interesting, and could lead to improvements in feature engineering or sartorial choices due to the outcome of wagers (<REF ID="R-14" RPTR="23">Goodale, 2008</REF>), but they distract from our thesis.</S>
          <S ID="S-11284">As can be seen in Table 1, for each of the 12 choices of system, language pair, and feature set, the PRO method performed nearly the same as or better than MIRA and MERT on test data.</S>
        </P>
        <P>
          <S ID="S-11285">In Figure 5 we show the tune and test BLEU using the weights learned at every iteration for each Urdu-English SBMT experiment.</S>
          <S ID="S-11286">Typical of the rest of the experiments, we can clearly see that PRO appears to proceed more monotonically than the other methods.</S>
          <S ID="S-11287">We quantified PRO&#8217;s stability as compared to MERT by repeating the Urdu-English baseline PBMT experiment five times with each configuration.</S>
          <S ID="S-11288">The tune and test BLEU at each iteration is depicted in Figure 6.</S>
          <S ID="S-11289">The standard deviation of the final test BLEU of MERT was 0.13 across the five experiment instances, while PRO had a standard deviation of just 0.05.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>6 Related Work</HEADER>
      <P>
        <S ID="S-11296">Several works (<REF ID="R-33" RPTR="49">Shen et al., 2004</REF>; Cowan et al., 2006; <REF ID="R-37" RPTR="53">Watanabe et al., 2006</REF>) have used discriminative techniques to re-rank k-best lists for MT.</S>
        <S ID="S-11297"><REF ID="R-35" RPTR="51">Tillmann and Zhang (2005)</REF> used a customized form of</S>
      </P>
      <P>
        <S ID="S-11298">same Urdu-English PBMT baseline feature experiment.</S>
        <S ID="S-11299">PRO is more stable than MERT.</S>
        <S ID="S-11300">multi-class stochastic gradient descent to learn feature weights for an MT model.</S>
        <S ID="S-11301"><REF ID="R-28" RPTR="41">Och and Ney (2002)</REF> used maximum entropy to tune feature weights but did not compare pairs of derivations.</S>
        <S ID="S-11302"><REF ID="R-18" RPTR="29">Ittycheriah and Roukos (2005)</REF> used a maximum entropy classifier to train an alignment model using hand-labeled data.</S>
        <S ID="S-11303">Xiong et al. (2006) also used a maximum entropy classifier, in this case to train the reordering component of their MT model.</S>
        <S ID="S-11304">Lattice- and hypergraphbased variants of MERT (<REF ID="R-23" RPTR="37">Macherey et al., 2008</REF>; <REF ID="R-20" RPTR="32">Kumar et al., 2009</REF>) are more stable than traditional MERT, but also require significant engineering efforts.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>7 Conclusion</HEADER>
      <P>
        <S ID="S-11305">We have described a simple technique for tuning an MT system that is on par with the leading techniques, exhibits reliable behavior, scales gracefully to high-dimension feature spaces, and is remarkably easy to implement.</S>
        <S ID="S-11306">We have demonstrated, via a litany of experiments, that our claims are valid and that this technique is widely applicable.</S>
        <S ID="S-11307">It is our hope that the adoption of PRO tuning leads to fewer headaches during tuning and motivates advanced MT feature engineering research.</S>
      </P>
    </DIV>
  </BODY>
  <ACKNOWLEDGMENTS>
    <P>
      <S ID="S-11308">Thanks to Markus Dreyer, Kevin Knight, Saiyam Kohli, Greg Langmead, Daniel Marcu, Dragos Munteanu, and Wei Wang for their assistance.</S>
      <S ID="S-11309">Thanks also to the anonymous reviewers, especially the reviewer who implemented PRO during the review period and replicated our results.</S>
    </P>
  </ACKNOWLEDGMENTS>
  <REFERENCES>
    <REFERENCE ID="0">
      <RAUTHOR>Chris Burges</RAUTHOR>
      <REFTITLE>Learning to rank using gradient descent.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="1">
      <RAUTHOR>Zhe Cao</RAUTHOR>
      <REFTITLE>Learning to rank: From pairwise approach to listwise approach.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="2">
      <RAUTHOR>Samidh Chatterjee</RAUTHOR>
      <REFTITLE>Minimum error rate training by sampling the translation lattice.</REFTITLE>
      <DATE>2010</DATE>
    </REFERENCE>
    <REFERENCE ID="3">
      <RAUTHOR>Wei Chen</RAUTHOR>
      <REFTITLE>Ranking measures and loss functions in learning to rank. In</REFTITLE>
      <DATE>2009</DATE>
    </REFERENCE>
    <REFERENCE ID="4">
      <RAUTHOR>David Chiang</RAUTHOR>
      <REFTITLE>Steve DeNeefe, Yee Seng Chan, and Hwee Tou Ng. 2008a. Decomposability of translation metrics for improved evaluation and efficient algorithms.</REFTITLE>
      <DATE></DATE>
    </REFERENCE>
    <REFERENCE ID="5">
      <RAUTHOR></RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE></DATE>
    </REFERENCE>
    <REFERENCE ID="6">
      <RAUTHOR>David Chiang</RAUTHOR>
      <REFTITLE>Online large-margin training of syntactic and structural translation features.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="7">
      <RAUTHOR>David Chiang</RAUTHOR>
      <REFTITLE>11,001 new features for statistical machine translation.</REFTITLE>
      <DATE>2009</DATE>
    </REFERENCE>
    <REFERENCE ID="8">
      <RAUTHOR>David Chiang</RAUTHOR>
      <REFTITLE>Learning to translate with source and target syntax.</REFTITLE>
      <DATE>2010</DATE>
    </REFERENCE>
    <REFERENCE ID="9">
      <RAUTHOR>Brooke Cowan</RAUTHOR>
      <REFTITLE>A discriminative model for tree-to-tree translation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="10">
      <RAUTHOR>Koby Crammer</RAUTHOR>
      <REFTITLE>Ultraconservative online algorithms for multiclass problems.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="11">
      <RAUTHOR>Hal Daum&#233;</RAUTHOR>
      <REFTITLE>Notes on CG and LM-BFGS optimization of logistic regression. Paper available at http://pub.hal3.name#daume04cg-bfgs, implementation available at http://hal3.name/ megam/,</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="12">
      <RAUTHOR>Yoav Freund</RAUTHOR>
      <REFTITLE>An efficient boosting algorithm for combining preferences.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="13">
      <RAUTHOR>Michel Galley</RAUTHOR>
      <REFTITLE>What&#8217;s in a translation rule?</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="14">
      <RAUTHOR>Gloria Goodale</RAUTHOR>
      <REFTITLE>Language Weaver: fast in translation.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="15">
      <RAUTHOR></RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE>2010</DATE>
    </REFERENCE>
    <REFERENCE ID="16">
      <RAUTHOR>Mark Hall</RAUTHOR>
      <REFTITLE>The WEKA data mining software: An update.</REFTITLE>
      <DATE>2009</DATE>
    </REFERENCE>
    <REFERENCE ID="17">
      <RAUTHOR>Ralf Herbrich</RAUTHOR>
      <REFTITLE>Support vector learning for ordinal regression.</REFTITLE>
      <DATE>1999</DATE>
    </REFERENCE>
    <REFERENCE ID="18">
      <RAUTHOR>Abraham Ittycheriah</RAUTHOR>
      <REFTITLE>A maximum entropy word aligner for Arabic-English machine translation.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="19">
      <RAUTHOR>Philipp Koehn</RAUTHOR>
      <REFTITLE>Moses: Open source toolkit for statistical machine translation.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="20">
      <RAUTHOR>Shankar Kumar</RAUTHOR>
      <REFTITLE>Efficient minimum error rate training and minimum bayes-risk decoding for translation hypergraphs and lattices.</REFTITLE>
      <DATE>2009</DATE>
    </REFERENCE>
    <REFERENCE ID="21">
      <RAUTHOR>Alon Lavie</RAUTHOR>
      <REFTITLE>The METEOR metric for automatic evaluation of machine translation.</REFTITLE>
      <DATE>2009</DATE>
    </REFERENCE>
    <REFERENCE ID="22">
      <RAUTHOR>Percy Liang</RAUTHOR>
      <REFTITLE>An end-to-end discriminative approach to machine translation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="23">
      <RAUTHOR>Wolfgang Macherey</RAUTHOR>
      <REFTITLE>Lattice-based minimum error rate training for statistical machine translation.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="24">
      <RAUTHOR></RAUTHOR>
      <REFTITLE>Association for Computational Linguistics.</REFTITLE>
      <DATE></DATE>
    </REFERENCE>
    <REFERENCE ID="25">
      <RAUTHOR>Christopher Manning</RAUTHOR>
      <REFTITLE>Optimization, maxent models, and conditional estimation without magic.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="26">
      <RAUTHOR>I Dan Melamed</RAUTHOR>
      <REFTITLE>Precision and recall of machine translation.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="27">
      <RAUTHOR>Franz Och</RAUTHOR>
      <REFTITLE>Improved statistical alignment models.</REFTITLE>
      <DATE>2000</DATE>
    </REFERENCE>
    <REFERENCE ID="28">
      <RAUTHOR>Franz Josef Och</RAUTHOR>
      <REFTITLE>Discriminative training and maximum entropy models for statistical machine translation.</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="29">
      <RAUTHOR>Franz Och</RAUTHOR>
      <REFTITLE>The alignment template approach to statistical machine translation.</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="30">
      <RAUTHOR>Franz Och</RAUTHOR>
      <REFTITLE>Minimum error rate training in statistical machine translation.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="31">
      <RAUTHOR>Kishore Papineni</RAUTHOR>
      <REFTITLE>BLEU: a method for automatic evaluation of machine translation.</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="32">
      <RAUTHOR>Benjamin Roth</RAUTHOR>
      <REFTITLE>Machine translation using overlapping alignments and samplerank.</REFTITLE>
      <DATE>2010</DATE>
    </REFERENCE>
    <REFERENCE ID="33">
      <RAUTHOR>Libin Shen</RAUTHOR>
      <REFTITLE>Discriminative reranking for machine translation.</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="34">
      <RAUTHOR>Matthew Snover</RAUTHOR>
      <REFTITLE>A study of translation edit rate with targeted human annotation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="35">
      <RAUTHOR>Christoph Tillmann</RAUTHOR>
      <REFTITLE>A localized prediction model for statistical machine translation.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="36">
      <RAUTHOR>Wei Wang</RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE>2011</DATE>
    </REFERENCE>
    <REFERENCE ID="37">
      <RAUTHOR>Taro Watanabe</RAUTHOR>
      <REFTITLE>NTT statistical machine translation for IWSLT</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="38">
      <RAUTHOR>Taro Watanabe</RAUTHOR>
      <REFTITLE>Online large-margin training for statistical machine translation.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
  </REFERENCES>
</PAPER>
