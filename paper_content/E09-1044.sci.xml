<PAPER>
  <FILENO/>
  <TITLE>Rule Filtering by Pattern for Efficient Hierarchical Translation</TITLE>
  <AUTHORS/>
  <ABSTRACT>
    <A-S ID="S-18444">We describe refinements to hierarchical translation search procedures intended to reduce both search errors and memory usage through modifications to hypothesis expansion in cube pruning and reductions in the size of the rule sets used in translation.</A-S>
    <A-S ID="S-18445">Rules are put into syntactic classes based on the number of non-terminals and the pattern, and various filtering strategies are then applied to assess the impact on translation speed and quality.</A-S>
    <A-S ID="S-18446">Results are reported on the 2008 NIST Arabic-to- English evaluation task.</A-S>
  </ABSTRACT>
  <BODY>
    <DIV DEPTH="0">
      <HEADER>1 Introduction</HEADER>
      <P>
        <S ID="S-18469">Hierarchical phrase-based translation (<REF ID="R-07" RPTR="9">Chiang, 2005</REF>) has emerged as one of the dominant current approaches to statistical machine translation.</S>
        <S ID="S-18470">Hiero translation systems incorporate many of the strengths of phrase-based translation systems, such as feature-based translation and strong target language models, while also allowing flexible translation and movement based on hierarchical rules extracted from aligned parallel text.</S>
        <S ID="S-18471">The approach has been widely adopted and reported to be competitive with other large-scale data driven approaches, e.g. (<REF ID="R-16" RPTR="26">Zollmann et al., 2008</REF>).</S>
      </P>
      <P>
        <S ID="S-18472">Large-scale hierarchical SMT involves automatic rule extraction from aligned parallel text, model parameter estimation, and the use of cube pruning k-best list generation in hierarchical translation.</S>
        <S ID="S-18473">The number of hierarchical rules extracted far exceeds the number of phrase translations typically found in aligned text.</S>
        <S ID="S-18474">While this may lead to improved translation quality, there is also the risk of lengthened translation times and increased memory usage, along with possible search errors due to the pruning procedures needed in search.</S>
      </P>
      <P>
        <S ID="S-18475">We describe several techniques to reduce memory usage and search errors in hierarchical translation.</S>
        <S ID="S-18476">Memory usage can be reduced in cube pruning (<REF ID="R-08" RPTR="16">Chiang, 2007</REF>) through smart memoization, and spreading neighborhood exploration can be used to reduce search errors.</S>
        <S ID="S-18477">However, search errors can still remain even when implementing simple phrase-based translation.</S>
        <S ID="S-18478">We describe a &#8216;shallow&#8217; search through hierarchical rules which greatly speeds translation without any effect on quality.</S>
        <S ID="S-18479">We then describe techniques to analyze and reduce the set of hierarchical rules.</S>
        <S ID="S-18480">We do this based on the structural properties of rules and develop strategies to identify and remove redundant or harmful rules.</S>
        <S ID="S-18481">We identify groupings of rules based on non-terminals and their patterns and assess the impact on translation quality and computational requirements for each given rule group.</S>
        <S ID="S-18482">We find that with appropriate filtering strategies rule sets can be greatly reduced in size without impact on translation performance.</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>1.1 Related Work</HEADER>
        <P>
          <S ID="S-18447">The search and rule pruning techniques described in the following sections add to a growing literature of refinements to the hierarchical phrasebased SMT systems originally described by <REF ID="R-07" RPTR="6">Chiang (2005</REF>; 2007).</S>
          <S ID="S-18448">Subsequent work has addressed improvements and extensions to the search procedure itself, the extraction of the hierarchical rules needed for translation, and has also reported contrastive experiments with other SMT architectures.</S>
          <S ID="S-18449">Hiero Search Refinements <REF ID="R-11" RPTR="21">Huang and Chiang (2007)</REF><REF ID="R-08" RPTR="10">Chiang (2007)</REF> offer several refinements to cube pruning to improve translation speed.</S>
          <S ID="S-18450"><REF ID="R-25" RPTR="40">Venugopal et al. (2007)</REF> introduce a Hiero variant with relaxed constraints for hypothesis recombination during parsing; speed and results are comparable to those of cube pruning, as described by <REF ID="R-08" RPTR="11">Chiang (2007)</REF>.</S>
          <S ID="S-18451"><REF ID="R-15" RPTR="25">Li and Khudanpur (2008)</REF> report significant improvements in translation speed by taking unseen n- grams into account within cube pruning to minimize language model requests.</S>
          <S ID="S-18452"><REF ID="R-10" RPTR="20">Dyer et al. (2008)</REF></S>
        </P>
        <P>
          <S ID="S-18453">extend the translation of source sentences to translation of input lattices following <REF ID="R-06" RPTR="5">Chappelier et al. (1999)</REF>.</S>
        </P>
        <P>
          <S ID="S-18454">Extensions to Hiero <REF ID="R-03" RPTR="2">Blunsom et al. (2008)</REF> discuss procedures to combine discriminative latent models with hierarchical SMT.</S>
          <S ID="S-18455">The Syntax- Augmented Machine Translation system (Zollmann and Venugopal, 2006) incorporates target language syntactic constituents in addition to the synchronous grammars used in translation.</S>
          <S ID="S-18456">Shen at al. (2008) make use of target dependency trees and a target dependency language model during decoding.</S>
          <S ID="S-18457"><REF ID="R-19" RPTR="32">Marton and Resnik (2008)</REF> exploit shallow correspondences of hierarchical rules with source syntactic constituents extracted from parallel text, an approach also investigated by <REF ID="R-07" RPTR="7">Chiang (2005</REF><REF ID="R-07" RPTR="8">Chiang (2005)</REF>.</S>
          <S ID="S-18458"><REF ID="R-26" RPTR="41">Zhang and Gildea (2006)</REF> propose binarization for synchronous grammars as a means to control search complexity arising from more complex, syntactic, hierarchical rules sets.</S>
        </P>
        <P>
          <S ID="S-18459">Hierarchical rule extraction <REF ID="R-27" RPTR="42">Zhang et al. (2008)</REF> describe a linear algorithm, a modified version of shift-reduce, to extract phrase pairs organized into a tree from which hierarchical rules can be directly extracted.</S>
          <S ID="S-18460"><REF ID="R-17" RPTR="29">Lopez (2007)</REF> extracts rules on-the-fly from the training bitext during decoding, searching efficiently for rule patterns using suffix arrays.</S>
        </P>
        <P>
          <S ID="S-18461">Analysis and Contrastive Experiments Zollman et al. (2008) compare phrase-based, hierarchical and syntax-augmented decoders for translation of Arabic, Chinese, and Urdu into English, and they find that attempts to expedite translation by simple schemes which discard rules also degrade translation performance.</S>
          <S ID="S-18462"><REF ID="R-18" RPTR="31">Lopez (2008)</REF> explores whether lexical reordering or the phrase discontiguity inherent in hierarchical rules explains improvements over phrase-based systems.</S>
          <S ID="S-18463">Hierarchical translation has also been used to great effect in combination with other translation architectures (e.g. (<REF ID="R-23" RPTR="38">Sim et al., 2007</REF>; <REF ID="R-21" RPTR="34">Rosti et al., 2007</REF>)).</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>1.2 Outline</HEADER>
        <P>
          <S ID="S-18464">The paper proceeds as follows.</S>
          <S ID="S-18465">Section 2 describes memoization and spreading neighborhood exploration in cube pruning intended to reduce memory usage and search errors, respectively.</S>
          <S ID="S-18466">A detailed comparison with a simple phrase-based system is presented.</S>
          <S ID="S-18467">Section 3 describes patternbased rule filtering and various procedures to select rule sets for use in translation with an aim to improving translation quality while minimizing rule set size.</S>
          <S ID="S-18468">Finally, Section 4 concludes.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>2 Two Refinements in Cube Pruning</HEADER>
      <P>
        <S ID="S-18530"><REF ID="R-08" RPTR="12">Chiang (2007)</REF> introduced cube pruning to apply language models in pruning during the generation of k-best translation hypotheses via the application of hierarchical rules in the CYK algorithm.</S>
        <S ID="S-18531">In the implementation of Hiero described here, there is the parser itself, for which we use a variant of the CYK algorithm closely related to CYK+ (<REF ID="R-05" RPTR="4">Chappelier and Rajman, 1998</REF>); it employs hypothesis recombination, without pruning, while maintaining back pointers.</S>
        <S ID="S-18532">Before k-best list generation with cube pruning, we apply a smart memoization procedure intended to reduce memory consumption during k-best list expansion.</S>
        <S ID="S-18533">Within the cube pruning algorithm we use spreading neighborhood exploration to improve robustness in the face of search errors.</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>2.1 Smart Memoization</HEADER>
        <P>
          <S ID="S-18483">Each cell in the chart built by the CYK algorithm contains all possible derivations of a span of the source sentence being translated.</S>
          <S ID="S-18484">After the parsing stage is completed, it is possible to make a very efficient sweep through the backpointers of the CYK grid to count how many times each cell will be accessed by the k-best generation algorithm.</S>
          <S ID="S-18485">When k-best list generation is running, the number of times each cell is visited is logged so that, as each cell is visited for the last time, the k-best list associated with each cell is deleted.</S>
          <S ID="S-18486">This continues until the one k-best list remaining at the top of the chart spans the entire sentence.</S>
          <S ID="S-18487">Memory reductions are substantial for longer sentences: for the longest sentence in the tuning set described later (105 words in length), smart memoization reduces memory usage during the cube pruning stage from 2.1GB to 0.7GB.</S>
          <S ID="S-18488">For average length sentences of approx.</S>
          <S ID="S-18489">30 words, memory reductions of 30% are typical.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>2.2 Spreading Neighborhood Exploration</HEADER>
        <P>
          <S ID="S-18490">In generation of a k-best list of translations for a source sentence span, every derivation is transformed into a cube containing the possible translations arising from that derivation, along with their translation and language model scores (<REF ID="R-08" RPTR="17">Chiang, 2007</REF>).</S>
          <S ID="S-18491">These derivations may contain nonterminals which must be expanded based on hypotheses generated by lower cells, which them-</S>
        </P>
        <P>
          <S ID="S-18492">selves may contain non-terminals.</S>
          <S ID="S-18493">For efficiency each cube maintains a queue of hypotheses, called here the frontier queue, ranked by translation and language model score; it is from these frontier queues that hypotheses are removed to create the k-best list for each cell.</S>
          <S ID="S-18494">When a hypothesis is extracted from a frontier queue, that queue is updated by searching through the neighborhood of the extracted item to find novel hypotheses to add; if no novel hypotheses are found, that queue necessarily shrinks.</S>
          <S ID="S-18495">This shrinkage can lead to search errors.</S>
          <S ID="S-18496">We therefore require that, when a hypothesis is removed, new candidates must be added by exploring a neighborhood which spreads from the last extracted hypothesis.</S>
          <S ID="S-18497">Each axis of the cube is searched (here, to a depth of 20) until a novel hypothesis is found.</S>
          <S ID="S-18498">In this way, up to three new candidates are added for each entry extracted from a frontier queue.</S>
          <S ID="S-18499"><REF ID="R-08" RPTR="13">Chiang (2007)</REF> describes an initialization procedure in which these frontier queues are seeded with a single candidate per axis; we initialize each frontier queue to a depth of b Nnt+1 , where N nt is the number of non-terminals in the derivation and b is a search parameter set throughout to 10.</S>
          <S ID="S-18500">By starting with deep frontier queues and by forcing them to grow during search we attempt to avoid search errors by ensuring that the universe of items within the frontier queues does not decrease as the k-best lists are filled.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>2.3 A Study of Hiero Search Errors in Phrase-Based Translation</HEADER>
        <P>
          <S ID="S-18501">Experiments reported in this paper are based on the NIST MT08 Arabic-to-English translation task.</S>
          <S ID="S-18502">Alignments are generated over all allowed parallel data, (&#8764;150M words per language).</S>
          <S ID="S-18503">Features extracted from the alignments and used in translation are in common use: target language model, source-to-target and target-to-source phrase translation models, word and rule penalties, number of usages of the glue rule, source-to-target and target-to-source lexical models, and three rule Figure 1: Spreading neighborhood exploration within a cube, just before and after extraction of the item C.</S>
          <S ID="S-18504">Grey squares represent the frontier queue; black squares are candidates already extracted.</S>
          <S ID="S-18505"><REF ID="R-08" RPTR="14">Chiang (2007)</REF> would only consider adding items X to the frontier queue, so the queue would shrink.</S>
          <S ID="S-18506">Spreading neighborhood exploration adds candidates S to the frontier queue.</S>
        </P>
        <P>
          <S ID="S-18507">count features inspired by <REF ID="R-01" RPTR="1">Bender et al. (2007)</REF>.</S>
          <S ID="S-18508">MET (<REF ID="R-20" RPTR="33">Och, 2003</REF>) iterative parameter estimation under IBM BLEU is performed on the development set.</S>
          <S ID="S-18509">The English language used model is a 4-gram estimated over the parallel text and a 965 million word subset of monolingual data from the English Gigaword Third Edition.</S>
          <S ID="S-18510">In addition to the MT08 set itself, we use a development set mt02- 05-tune formed from the odd numbered sentences of the NIST MT02 through MT05 evaluation sets; the even numbered sentences form the validation set mt02-05-test.</S>
          <S ID="S-18511">The mt02-05-tune set has 2,075 sentences.</S>
          <S ID="S-18512">We first compare the cube pruning decoder to the TTM (<REF ID="R-14" RPTR="24">Kumar et al., 2006</REF>), a phrase-based SMT system implemented with Weighted Finite- State Tansducers (<REF ID="R-00" RPTR="0">Allauzen et al., 2007</REF>).</S>
          <S ID="S-18513">The system implements either a monotone phrase order translation, or an MJ1 (maximum phrase jump of 1) reordering model (<REF ID="R-13" RPTR="23">Kumar and Byrne, 2005</REF>).</S>
          <S ID="S-18514">Relative to the complex movement and translation allowed by Hiero and other models, MJ1 is clearly inferior (<REF ID="R-09" RPTR="19">Dreyer et al., 2007</REF>); MJ1 was developed with efficiency in mind so as to run with a minimum of search errors in translation and to be easily and exactly realized via WFSTs.</S>
          <S ID="S-18515">Even for the</S>
        </P>
        <P>
          <S ID="S-18516">large models used in an evaluation task, the TTM system is reported to run largely without pruning (Blackwood et al., 2008).</S>
        </P>
        <P>
          <S ID="S-18517">The Hiero decoder can easily be made to implement MJ1 reordering by allowing only a restricted set of reordering rules in addition to the usual glue rule, as shown in left-hand column of Table 1, where T is the set of terminals.</S>
          <S ID="S-18518">Constraining Hiero in this way makes it possible to compare its performance to the exact WFST TTM implementation and to identify any search errors made by Hiero.</S>
        </P>
        <P>
          <S ID="S-18519">Table 2 shows the lowercased IBM BLEU scores obtained by the systems for mt02-05-tune with monotone and reordered search, and with MET-optimised parameters for MJ1 reordering.</S>
          <S ID="S-18520">For Hiero, an N-best list depth of 10,000 is used throughout.</S>
          <S ID="S-18521">In the monotone case, all phrasebased systems perform similarly although Hiero does make search errors.</S>
          <S ID="S-18522">For simple MJ1 reordering, the basic Hiero search procedure makes many search errors and these lead to degradations in BLEU.</S>
          <S ID="S-18523">Spreading neighborhood expansion reduces the search errors and improves BLEU score significantly but search errors remain a problem.</S>
          <S ID="S-18524">Search errors are even more apparent after MET.</S>
          <S ID="S-18525">This is not surprising, given that mt02-05-tune is the set over which MET is run: MET drives up the likelihood of good hypotheses at the expense of poor hypotheses, but search errors often increase due to the expanded dynamic range of the hypothesis scores.</S>
        </P>
        <P>
          <S ID="S-18526">Our aim in these experiments was to demonstrate that spreading neighborhood exploration can aid in avoiding search errors.</S>
          <S ID="S-18527">We emphasize that we are not proposing that Hiero should be used to implement reordering models such as MJ1 which were created for completely different search procedures (e.g. WFST composition).</S>
          <S ID="S-18528">However these experiments do suggest that search errors may be an issue, particularly as the search space grows to include the complex long-range movement allowed by the hierarchical rules.</S>
          <S ID="S-18529">We next study various filtering procedures to reduce hierarchical rule sets to find a balance between translation speed, memory usage, and performance.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>3 Rule Filtering by Pattern</HEADER>
      <P>
        <S ID="S-18601">Hierarchical rules X &#8594; &#12296;&#947;,&#945;&#12297; are composed of sequences of terminals and non-terminals, which</S>
      </P>
      <P>
        <S ID="S-18602">we call elements.</S>
        <S ID="S-18603">In the source, a maximum of two non-adjacent non-terminals is allowed (<REF ID="R-08" RPTR="18">Chiang, 2007</REF>).</S>
        <S ID="S-18604">Leaving aside rules without nonterminals (i.e. phrase pairs as used in phrasebased translation), rules can be classed by their number of non-terminals, N nt , and their number of elements, N e .</S>
        <S ID="S-18605">There are 5 possible classes: N nt .N e = 1.2,1.3,2.3,2.4, 2.5.</S>
      </P>
      <P>
        <S ID="S-18606">During rule extraction we search each class separately to control memory usage.</S>
        <S ID="S-18607">Furthermore, we extract from alignments only those rules which are relevant to our given test set; for computation of backward translation probabilities we log general counts of target-side rules but discard unneeded rules.</S>
        <S ID="S-18608">Even with this restriction, our initial ruleset for mt02-05-tune exceeds 175M rules, of which only 0.62M are simple phrase pairs.</S>
      </P>
      <P>
        <S ID="S-18609">The question is whether all these rules are needed for translation.</S>
        <S ID="S-18610">If the rule set can be reduced without reducing translation quality, both memory efficiency and translation speed can be increased.</S>
        <S ID="S-18611">Previously published approaches to reducing the rule set include: enforcing a minimum span of two words per non-terminal (<REF ID="R-18" RPTR="30">Lopez, 2008</REF>), which would reduce our set to 115M rules; or a minimum count (mincount) threshold (<REF ID="R-16" RPTR="27">Zollmann et al., 2008</REF>), which would reduce our set to 78M (mincount=2) or 57M (mincount=3) rules.</S>
        <S ID="S-18612"><REF ID="R-22" RPTR="35">Shen et al. (2008)</REF> describe the result of filtering rules by insisting that target-side rules are well-formed dependency trees.</S>
        <S ID="S-18613">This reduces their rule set from 140M to 26M rules.</S>
        <S ID="S-18614">This filtering leads to a degradation in translation performance (see Table 2 of <REF ID="R-22" RPTR="36">Shen et al. (2008)</REF>), which they counter by adding a dependency LM in translation.</S>
        <S ID="S-18615">As another reference point, <REF ID="R-08" RPTR="15">Chiang (2007)</REF> reports Chinese-to-English translation experiments based on 5.5M rules.</S>
      </P>
      <P>
        <S ID="S-18616">Zollmann et al. (2008) report that filtering rules</S>
      </P>
      <P>
        <S ID="S-18617">en masse leads to degradation in translation performance.</S>
        <S ID="S-18618">Rather than apply a coarse filtering, such as a mincount for all rules, we follow a more syntactic approach and further classify our rules according to their pattern and apply different filters to each pattern depending on its value in translation.</S>
        <S ID="S-18619">The premise is that some patterns are more important than others.</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>3.1 Rule Patterns</HEADER>
        <P>
          <S ID="S-18534">Given a rule set, we define source patterns and target patterns by replacing every sequence of non-terminals by a single symbol &#8216;w&#8217; (indicating word, i.e. terminal string, w &#8712; T + ).</S>
          <S ID="S-18535">Each hierarchical rule has a unique source and target pattern which together define the rule pattern.</S>
        </P>
        <P>
          <S ID="S-18536">By ignoring the identity and the number of adjacent terminals, the rule pattern represents a natural generalization of any rule, capturing its structure and the type of reordering it encodes.</S>
          <S ID="S-18537">In total, there are 66 possible rule patterns.</S>
          <S ID="S-18538">Table 3 presents a few examples extracted for mt02-05- tune, showing that some patterns are much more diverse than others.</S>
          <S ID="S-18539">For example, patterns with two non-terminals (N nt =2) are richer than patterns with N nt =1, as they cover many more distinct rules.</S>
          <S ID="S-18540">Additionally, patterns with two nonterminals which also have a monotonic relationship between source and target non-terminals are much more diverse than their reordered counterparts.</S>
        </P>
        <P>
          <S ID="S-18541">Some examples of extracted rules and their corresponding pattern follow, where Arabic is shown in Buckwalter encoding.</S>
        </P>
        <P>
          <S ID="S-18542">Pattern &#12296;wX 1 , wX 1 w&#12297; :</S>
        </P>
        <P>
          <S ID="S-18543">&#12296;w+ qAl X 1 , the X 1 said&#12297; Pattern &#12296;wX 1 w , wX 1 &#12297; :</S>
        </P>
        <P>
          <S ID="S-18544">&#12296;fy X 1 kAnwn Al&gt;wl , on december X 1 &#12297; Pattern &#12296;wX 1 wX 2 , wX 1 wX 2 w&#12297; :</S>
        </P>
        <P>
          <S ID="S-18545">&#12296;Hl X 1 lAzmp X 2 , a X 1 solution to the X 2 crisis&#12297;</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.2 Building an Initial Rule Set</HEADER>
        <P>
          <S ID="S-18546">We describe a greedy approach to building a rule set in which rules belonging to a pattern are added to the rule set guided by the improvements they yield on mt02-05-tune relative to the monotone Hiero system described in the previous section.</S>
          <S ID="S-18547">We find that certain patterns seem not to contribute to any improvement.</S>
          <S ID="S-18548">This is particularly significant as these patterns often encompass large numbers of rules, as with patterns with matching source and target patterns.</S>
          <S ID="S-18549">For instance, we found no improvement when adding the pattern &#12296;X 1 w,X 1 w&#12297;, of which there were 1.2M instances (Table 3).</S>
          <S ID="S-18550">Since concatenation is already possible under the general glue rule, rules with this pattern are redundant.</S>
          <S ID="S-18551">By contrast, the much less frequent reordered counterpart, i.e. the &#12296;wX 1 ,X 1 w&#12297; pattern (0.01M instances), provides substantial gains.</S>
          <S ID="S-18552">The situation is analogous for rules with two nonterminals (N nt =2).</S>
        </P>
        <P>
          <S ID="S-18553">Based on exploratory analyses (not reported here, for space) an initial rule set was built by excluding patterns reported in Table 4.</S>
          <S ID="S-18554">In total, 171.5M rules are excluded, for a remaining set of 4.2M rules, 3.5M of which are hierarchical.</S>
          <S ID="S-18555">We acknowledge that adding rules in this way, by greedy search, is less than ideal and inevitably raises questions with respect to generality and repeatability.</S>
          <S ID="S-18556">However in our experience this is a robust approach, mainly because the initial translation system runs very fast; it is possible to run many exploratory experiments in a short time.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.3 Shallow versus Fully Hierarchical Translation</HEADER>
        <P>
          <S ID="S-18557">In measuring the effectiveness of rules in translation, we also investigate whether a &#8216;fully hierarchical&#8217; search is needed or whether a shallow search is also effective.</S>
          <S ID="S-18558">In constrast to full Hiero, in the shallow search, only phrases are allowed to be substituted into non-terminals.</S>
          <S ID="S-18559">The rules used in each case can be expressed as shown in the 2nd and 3rd columns of Table 1.</S>
          <S ID="S-18560">Shallow search can be considered (loosely) to be a form of rule filtering.</S>
        </P>
        <P>
          <S ID="S-18561">As can be seen in Table 5 there is no impact on BLEU, while translation speed increases by a factor of 7.</S>
          <S ID="S-18562">Of course, these results are specific to this Arabic-to-English translation task, and need not be expected to carry over to other language pairs, such as Chinese-to-English translation.</S>
          <S ID="S-18563">However, the impact of this search simplification is easy to measure, and the gains can be significant enough, that it may be worth investigation even for languages with complex long distance movement.</S>
        </P>
        <P>
          <S ID="S-18564">mt02-05- -tune -test</S>
        </P>
        <P>
          <S ID="S-18565">&#8226; Number of translations (NT).</S>
          <S ID="S-18566">We keep the NT most frequent &#945;, i.e. each &#947; is allowed to have at most NT rules.</S>
        </P>
        <P>
          <S ID="S-18567">&#8226; Number of reordered translations (NRT).</S>
          <S ID="S-18568">We keep the NRT most frequent &#945; with monotonic non-terminals and the NRT most frequent &#945; with reordered non-terminals.</S>
        </P>
        <P>
          <S ID="S-18569">&#8226; Count percentage (CP).</S>
          <S ID="S-18570">We keep the most frequent &#945; until their aggregated number of counts reaches a certain percentage CP of the total counts of X &#8594; &#12296;&#947;,&#8727;&#12297;.</S>
          <S ID="S-18571">Some &#947;&#8217;s are allowed to have more &#945;&#8217;s than others, depending on their count distribution.</S>
        </P>
        <P>
          <S ID="S-18572">Results applying these filters with various thresholds are given in Table 6, including number of rules and decoding time.</S>
          <S ID="S-18573">As shown, all filters achieve at least a 50% speed-up in decoding time by discarding 15% to 25% of the baseline rules.</S>
          <S ID="S-18574">Remarkably, performance is unaffected when applying the simple NT and NRT filters with a threshold of 20 translations.</S>
          <S ID="S-18575">Finally, the CM filter behaves slightly worse for thresholds of 90% for the same decoding time.</S>
          <S ID="S-18576">For this reason, we select NRT=20 as our general filter.</S>
        </P>
        <P>
          <S ID="S-18577">mt02-05- -tune -test</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.4 Individual Rule Filters</HEADER>
        <P>
          <S ID="S-18578">We now filter rules individually (not by class) according to their number of translations.</S>
          <S ID="S-18579">For each fixed &#947; /&#8712; T + (i.e. with at least 1 non-terminal), we define the following filters over rules X &#8594; &#12296;&#947;,&#945;&#12297;:</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.5 Pattern-based Rule Filters</HEADER>
        <P>
          <S ID="S-18580">In this section we first reconsider whether reintroducing the monotonic rules (originally excluded as described in rows &#8217;b&#8217;, &#8217;c&#8217;, &#8217;d&#8217; in Table 4) affects performance.</S>
          <S ID="S-18581">Results are given in the upper rows of Table 7.</S>
          <S ID="S-18582">For all classes, we find that reintroducing these rules increases the total number of rules</S>
        </P>
        <P>
          <S ID="S-18583">mt02-05- -tune -test N nt .N e Filter Time Rules BLEU BLEU</S>
        </P>
        <P>
          <S ID="S-18584">substantially, despite the NRT=20 filter, but leads to degradation in translation performance.</S>
        </P>
        <P>
          <S ID="S-18585">We next reconsider the mincount threshold values for N nt .N e classes 1.3, 2.3, 2.4 and 2.5 originally described in Table 4 (rows &#8217;e&#8217; to &#8217;h&#8217;).</S>
          <S ID="S-18586">Results under various mincount cutoffs for each class are given in Table 7 (middle five rows).</S>
          <S ID="S-18587">For classes 2.3 and 2.5, the mincount cutoff can be reduced to 1 (i.e. all rules are kept) with slight translation improvements.</S>
          <S ID="S-18588">In contrast, reducing the cutoff for classes 1.3 and 2.4 to 3 and 5, respectively, adds many more rules with no increase in performance.</S>
          <S ID="S-18589">We also find that increasing the cutoff to 15 for class 2.4 yields the same results with a smaller rule set.</S>
          <S ID="S-18590">Finally, we consider further filtering applied to class 1.2 with mincount 5 and 10 (final two rows in Table 7).</S>
          <S ID="S-18591">The number of rules is largely unchanged, but translation performance drops consistently as more rules are removed.</S>
        </P>
        <P>
          <S ID="S-18592">Based on these experiments, we conclude that it is better to apply separate mincount thresholds to the classes to obtain optimal performance with a minimum size rule set.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.6 Large Language Models and Evaluation</HEADER>
        <P>
          <S ID="S-18593">Finally, in this section we report results of our shallow hierarchical system with the 2.5 mincount=1 configuration from Table 7, after including the following N-best list rescoring steps.</S>
        </P>
        <P>
          <S ID="S-18594">&#8226; Large-LM rescoring.</S>
          <S ID="S-18595">We build sentencespecific zero-cutoff stupid-backoff (<REF ID="R-04" RPTR="3">Brants et al., 2007</REF>) 5-gram language models, estimated using &#8764;4.7B words of English newswire text, and apply them to rescore each 10000-best list.</S>
        </P>
        <P>
          <S ID="S-18596">&#8226; Minimum Bayes Risk (MBR).</S>
          <S ID="S-18597">We then rescore the first 1000-best hypotheses with MBR, taking the negative sentence level BLEU score as the loss function to minimise (<REF ID="R-12" RPTR="22">Kumar and Byrne, 2004</REF>).</S>
        </P>
        <P>
          <S ID="S-18598">Table 8 shows results for mt02-05-tune, mt02- 05-test, the NIST subsets from the MT06 evaluation (mt06-nist-nw for newswire data and mt06- nist-ng for newsgroup) and mt08, as measured by lowercased IBM BLEU and TER (<REF ID="R-24" RPTR="39">Snover et al., 2006</REF>).</S>
          <S ID="S-18599">Mixed case NIST BLEU for this system on mt08 is 42.5.</S>
          <S ID="S-18600">This is directly comparable to official MT08 evaluation results 1 .</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>4 Conclusions</HEADER>
      <P>
        <S ID="S-18620">This paper focuses on efficient large-scale hierarchical translation while maintaining good translation quality.</S>
        <S ID="S-18621">Smart memoization and spreading neighborhood exploration during cube pruning are described and shown to reduce memory consumption and Hiero search errors using a simple phrasebased system as a contrast.</S>
        <S ID="S-18622">We then define a general classification of hierarchical rules, based on their number of nonterminals, elements and their patterns, for refined extraction and filtering.</S>
        <S ID="S-18623">For a large-scale Arabic-to-English task, we show that shallow hierarchical decoding is as good</S>
      </P>
      <P>
        <S ID="S-18624">and MBR decoding.</S>
        <S ID="S-18625">as fully hierarchical search and that decoding time is dramatically decreased.</S>
        <S ID="S-18626">In addition, we describe individual rule filters based on the distribution of translations with further time reductions at no cost in translation scores.</S>
        <S ID="S-18627">This is in direct contrast to recent reported results in which other filtering strategies lead to degraded performance (<REF ID="R-22" RPTR="37">Shen et al., 2008</REF>; <REF ID="R-16" RPTR="28">Zollmann et al., 2008</REF>).</S>
        <S ID="S-18628">We find that certain patterns are of much greater value in translation than others and that separate minimum count filters should be applied accordingly.</S>
        <S ID="S-18629">Some patterns were found to be redundant or harmful, in particular those with two monotonic non-terminals.</S>
        <S ID="S-18630">Moreover, we show that the value of a pattern is not directly related to the number of rules it encompasses, which can lead to discarding large numbers of rules as well as to dramatic speed improvements.</S>
        <S ID="S-18631">Although reported experiments are only for Arabic-to-English translation, we believe the approach will prove to be general.</S>
        <S ID="S-18632">Pattern relevance will vary for other language pairs, but we expect filtering strategies to be equally worth pursuing.</S>
      </P>
    </DIV>
  </BODY>
  <ACKNOWLEDGMENTS>
    <P>
      <S ID="S-18633">This work was supported in part by the GALE program of the Defense Advanced Research Projects Agency, Contract No.</S>
      <S ID="S-18634">HR0011- 06-C-0022.</S>
      <S ID="S-18635">G. Iglesias supported by Spanish Government research grant BES-2007-15956 (project TEC2006- 13694-C03-03).</S>
    </P>
  </ACKNOWLEDGMENTS>
  <REFERENCES>
    <REFERENCE ID="0">
      <RAUTHOR>Cyril Allauzen</RAUTHOR>
      <REFTITLE>OpenFst: A general and efficient weighted finite-state transducer library.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="1">
      <RAUTHOR>Oliver Bender</RAUTHOR>
      <REFTITLE>The RWTH Arabic-to-English spoken language translation system.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="2">
      <RAUTHOR>Graeme Blackwood</RAUTHOR>
      <REFTITLE>Large-scale statistical machine translation with weighted finite state transducers.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="3">
      <RAUTHOR>Phil Blunsom</RAUTHOR>
      <REFTITLE>A discriminative latent variable model for statistical machine translation.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="4">
      <RAUTHOR>Thorsten Brants</RAUTHOR>
      <REFTITLE>Large language models in machine translation.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="5">
      <RAUTHOR>Jean-C&#233;dric Chappelier</RAUTHOR>
      <REFTITLE>A generalized CYK algorithm for parsing stochastic CFG.</REFTITLE>
      <DATE>1998</DATE>
    </REFERENCE>
    <REFERENCE ID="6">
      <RAUTHOR>Jean-C&#233;dric Chappelier</RAUTHOR>
      <REFTITLE>Lattice parsing for speech recognition.</REFTITLE>
      <DATE>1999</DATE>
    </REFERENCE>
    <REFERENCE ID="7">
      <RAUTHOR>David Chiang</RAUTHOR>
      <REFTITLE>A hierarchical phrase-based model for statistical machine translation.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="8">
      <RAUTHOR>David Chiang</RAUTHOR>
      <REFTITLE>Hierarchical phrase-based translation.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="9">
      <RAUTHOR>Markus Dreyer</RAUTHOR>
      <REFTITLE>Comparing reordering constraints for SMT using efficient BLEU oracle computation.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="10">
      <RAUTHOR>Christopher Dyer</RAUTHOR>
      <REFTITLE>Generalizing word lattice translation.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="11">
      <RAUTHOR>Liang Huang</RAUTHOR>
      <REFTITLE>Forest rescoring: Faster decoding with integrated language models.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="12">
      <RAUTHOR>Shankar Kumar</RAUTHOR>
      <REFTITLE>Minimum Bayes-risk decoding for statistical machine translation.</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="13">
      <RAUTHOR>Shankar Kumar</RAUTHOR>
      <REFTITLE>Local phrase reordering models for statistical machine translation.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="14">
      <RAUTHOR>Shankar Kumar</RAUTHOR>
      <REFTITLE>A weighted finite state transducer translation template model for statistical machine translation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="15">
      <RAUTHOR>Li</RAUTHOR>
      <REFTITLE>A scalable decoder for parsing-based machine translation with equivalent language model state maintenance.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="16">
      <RAUTHOR>Andreas Zollmann</RAUTHOR>
      <REFTITLE>A systematic comparison of phrase-based, hierarchical and syntax-augmented statistical MT.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="17">
      <RAUTHOR>Adam Lopez</RAUTHOR>
      <REFTITLE>Hierarchical phrase-based translation with suffix arrays.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="18">
      <RAUTHOR>Adam Lopez</RAUTHOR>
      <REFTITLE>Tera-scale translation models via pattern matching.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="19">
      <RAUTHOR>Yuval Marton</RAUTHOR>
      <REFTITLE>Soft syntactic constraints for hierarchical phrased-based translation.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="20">
      <RAUTHOR>Franz J Och</RAUTHOR>
      <REFTITLE>Minimum error rate training in statistical machine translation.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="21">
      <RAUTHOR>Antti-Veikko Rosti</RAUTHOR>
      <REFTITLE>Combining outputs from multiple machine translation systems.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="22">
      <RAUTHOR>Libin Shen</RAUTHOR>
      <REFTITLE>A new string-to-dependency machine translation algorithm with a target dependency language model.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="23">
      <RAUTHOR>Khe Chai Sim</RAUTHOR>
      <REFTITLE>Consensus network decoding for statistical machine translation system combination.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="24">
      <RAUTHOR>Matthew Snover</RAUTHOR>
      <REFTITLE>A study of translation edit rate with targeted human annotation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="25">
      <RAUTHOR>Ashish Venugopal</RAUTHOR>
      <REFTITLE>An efficient two-pass approach to synchronous-CFG driven statistical MT.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="26">
      <RAUTHOR>Hao Zhang</RAUTHOR>
      <REFTITLE>Synchronous binarization for machine translation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="27">
      <RAUTHOR>Hao Zhang</RAUTHOR>
      <REFTITLE>Extracting synchronous grammar rules from wordlevel alignments in linear time.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
  </REFERENCES>
</PAPER>
