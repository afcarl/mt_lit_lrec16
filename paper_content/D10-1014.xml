<document>
  <filename>D10-1014</filename>
  <authors>
    <author>Zhongqiang Huang</author>
    <author>Martin &#268;mejrek</author>
  </authors>
  <title>Soft Syntactic Constraints for Hierarchical Phrase-based Translation Using Latent Syntactic Distributions</title>
  <content>
    <sections>
      <section>
        <index>0</index>
        <title>Abstract</title>
        <text>In this paper, we present a novel approach to enhance hierarchical phrase-based machine translation systems with linguistically motivated syntactic features. Rather than directly using treebank categories as in previous studies, we learn a set of linguistically-guided latent syntactic categories automatically from a source-side parsed, word-aligned parallel corpus, based on the hierarchical structure among phrase pairs as well as the syntactic structure of the source side. In our model, each X nonterminal in a SCFG rule is decorated with a real-valued feature vector computed based on its distribution of latent syntactic categories. These feature vectors are utilized at decoding time to measure the similarity between the syntactic analysis of the source side and the syntax of the SCFG rules that are applied to derive translations. Our approach maintains the advantages of hierarchical phrase-based translation systems while at the same time naturally incorporates soft syntactic constraints.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>In this paper, we present a novel approach to enhance hierarchical phrase-based machine translation systems with linguistically motivated syntactic features.</text>
              <doc_id>0</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Rather than directly using treebank categories as in previous studies, we learn a set of linguistically-guided latent syntactic categories automatically from a source-side parsed, word-aligned parallel corpus, based on the hierarchical structure among phrase pairs as well as the syntactic structure of the source side.</text>
              <doc_id>1</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>In our model, each X nonterminal in a SCFG rule is decorated with a real-valued feature vector computed based on its distribution of latent syntactic categories.</text>
              <doc_id>2</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>These feature vectors are utilized at decoding time to measure the similarity between the syntactic analysis of the source side and the syntax of the SCFG rules that are applied to derive translations.</text>
              <doc_id>3</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Our approach maintains the advantages of hierarchical phrase-based translation systems while at the same time naturally incorporates soft syntactic constraints.</text>
              <doc_id>4</doc_id>
              <sec_id>4</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>1</index>
        <title>1 Introduction</title>
        <text>In recent years, syntax-based translation models (Chiang, 2007; Galley et al., 2004; Liu et al., 2006) have shown promising progress in improving translation quality, thanks to the incorporation of phrasal translation adopted from the widely used phrase-based models (Och and Ney, 2004) to handle local fluency and the engagement of synchronous context-free grammars (SCFG) to handle non-local phrase reordering. Approaches to syntaxbased translation models can be largely categorized
into two classes based on their dependency on annotated corpus (Chiang, 2007). Linguistically syntaxbased models (e.g., (Yamada and Knight, 2001; Galley et al., 2004; Liu et al., 2006)) utilize structures defined over linguistic theory and annotations (e.g., Penn Treebank) and guide the derivation of SCFG rules with explicit parsing on at least one side of the parallel corpus. Formally syntax-based models (e.g., (Wu, 1997; Chiang, 2007)) extract synchronous grammars from parallel corpora based on the hierarchical structure of natural language pairs without any explicit linguistic knowledge or annotations. In this work, we focus on the hierarchical phrase-based models of Chiang (2007), which is formally syntax-based, and always refer the term SCFG, from now on, to the grammars of this model class.
On the one hand, hierarchical phrase-based models do not suffer from errors in syntactic constraints that are unavoidable in linguistically syntax-based models. Despite the complete lack of linguistic guidance, the performance of hierarchical phrasebased models is competitive when compared to linguistically syntax-based models. As shown in (Mi and Huang, 2008), hierarchical phrase-based models significantly outperform tree-to-string models (Liu et al., 2006; Huang et al., 2006), even when attempts are made to alleviate parsing errors using either forest-based decoding (Mi et al., 2008) or forest-based rule extraction (Mi and Huang, 2008).
On the other hand, when properly used, syntactic constraints can provide invaluable benefits to improve translation quality. The tree-to-string models of Mi and Huang (2008) can actually signif-
icantly outperform hierarchical phrase-based models when using forest-based rule extraction together with forest-based decoding. Chiang (2010) also obtained significant improvement over his hierarchical baseline by using syntactic parse trees on both source and target sides to induce fuzzy (not exact) tree-to-tree rules and by also allowing syntactically mismatched substitutions.
In this paper, we augment rules in hierarchical phrase-based translation systems with novel syntactic features. Unlike previous studies (e.g., (Zollmann and Venugopal, 2006)) that directly use explicit treebank categories such as NP, NP/PP (NP missing PP from the right) to annotate phrase pairs, we induce a set of latent categories to capture the syntactic dependencies inherent in the hierarchical structure of phrase pairs, and derive a real-valued feature vector for each X nonterminal of a SCFG rule based on the distribution of the latent categories. Moreover, we convert the equality test of two sequences of syntactic categories, which are either identical or different, into the computation of a similarity score between their corresponding feature vectors. In our model, two symbolically different sequences of syntactic categories could have a high similarity score in the feature vector representation if they are syntactically similar, and a low score otherwise. In decoding, these feature vectors are utilized to measure the similarity between the syntactic analysis of the source side and the syntax of the SCFG rules that are applied to derive translations. Our approach maintains the advantages of hierarchical phrase-based translation systems while at the same time naturally incorporates soft syntactic constraints. To the best of our knowledge, this is the first work that applies real-valued syntactic feature vectors to machine translation.
The rest of the paper is organized as follows. Section 2 briefly reviews hierarchical phrase-based translation models. Section 3 presents an overview of our approach, followed by Section 4 describing the hierarchical structure of aligned phrase pairs and Section 5 describing how to induce latent syntactic categories. Experimental results are reported in Section 6, followed by discussions in Section 7. Section 8 concludes this paper.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>In recent years, syntax-based translation models (Chiang, 2007; Galley et al., 2004; Liu et al., 2006) have shown promising progress in improving translation quality, thanks to the incorporation of phrasal translation adopted from the widely used phrase-based models (Och and Ney, 2004) to handle local fluency and the engagement of synchronous context-free grammars (SCFG) to handle non-local phrase reordering.</text>
              <doc_id>5</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Approaches to syntaxbased translation models can be largely categorized</text>
              <doc_id>6</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>into two classes based on their dependency on annotated corpus (Chiang, 2007).</text>
              <doc_id>7</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Linguistically syntaxbased models (e.g., (Yamada and Knight, 2001; Galley et al., 2004; Liu et al., 2006)) utilize structures defined over linguistic theory and annotations (e.g., Penn Treebank) and guide the derivation of SCFG rules with explicit parsing on at least one side of the parallel corpus.</text>
              <doc_id>8</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Formally syntax-based models (e.g., (Wu, 1997; Chiang, 2007)) extract synchronous grammars from parallel corpora based on the hierarchical structure of natural language pairs without any explicit linguistic knowledge or annotations.</text>
              <doc_id>9</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>In this work, we focus on the hierarchical phrase-based models of Chiang (2007), which is formally syntax-based, and always refer the term SCFG, from now on, to the grammars of this model class.</text>
              <doc_id>10</doc_id>
              <sec_id>3</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>On the one hand, hierarchical phrase-based models do not suffer from errors in syntactic constraints that are unavoidable in linguistically syntax-based models.</text>
              <doc_id>11</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Despite the complete lack of linguistic guidance, the performance of hierarchical phrasebased models is competitive when compared to linguistically syntax-based models.</text>
              <doc_id>12</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>As shown in (Mi and Huang, 2008), hierarchical phrase-based models significantly outperform tree-to-string models (Liu et al., 2006; Huang et al., 2006), even when attempts are made to alleviate parsing errors using either forest-based decoding (Mi et al., 2008) or forest-based rule extraction (Mi and Huang, 2008).</text>
              <doc_id>13</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>On the other hand, when properly used, syntactic constraints can provide invaluable benefits to improve translation quality.</text>
              <doc_id>14</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>The tree-to-string models of Mi and Huang (2008) can actually signif-</text>
              <doc_id>15</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>icantly outperform hierarchical phrase-based models when using forest-based rule extraction together with forest-based decoding.</text>
              <doc_id>16</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Chiang (2010) also obtained significant improvement over his hierarchical baseline by using syntactic parse trees on both source and target sides to induce fuzzy (not exact) tree-to-tree rules and by also allowing syntactically mismatched substitutions.</text>
              <doc_id>17</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>In this paper, we augment rules in hierarchical phrase-based translation systems with novel syntactic features.</text>
              <doc_id>18</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Unlike previous studies (e.g., (Zollmann and Venugopal, 2006)) that directly use explicit treebank categories such as NP, NP/PP (NP missing PP from the right) to annotate phrase pairs, we induce a set of latent categories to capture the syntactic dependencies inherent in the hierarchical structure of phrase pairs, and derive a real-valued feature vector for each X nonterminal of a SCFG rule based on the distribution of the latent categories.</text>
              <doc_id>19</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Moreover, we convert the equality test of two sequences of syntactic categories, which are either identical or different, into the computation of a similarity score between their corresponding feature vectors.</text>
              <doc_id>20</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>In our model, two symbolically different sequences of syntactic categories could have a high similarity score in the feature vector representation if they are syntactically similar, and a low score otherwise.</text>
              <doc_id>21</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>In decoding, these feature vectors are utilized to measure the similarity between the syntactic analysis of the source side and the syntax of the SCFG rules that are applied to derive translations.</text>
              <doc_id>22</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Our approach maintains the advantages of hierarchical phrase-based translation systems while at the same time naturally incorporates soft syntactic constraints.</text>
              <doc_id>23</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>To the best of our knowledge, this is the first work that applies real-valued syntactic feature vectors to machine translation.</text>
              <doc_id>24</doc_id>
              <sec_id>6</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The rest of the paper is organized as follows.</text>
              <doc_id>25</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Section 2 briefly reviews hierarchical phrase-based translation models.</text>
              <doc_id>26</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Section 3 presents an overview of our approach, followed by Section 4 describing the hierarchical structure of aligned phrase pairs and Section 5 describing how to induce latent syntactic categories.</text>
              <doc_id>27</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Experimental results are reported in Section 6, followed by discussions in Section 7.</text>
              <doc_id>28</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Section 8 concludes this paper.</text>
              <doc_id>29</doc_id>
              <sec_id>4</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>2</index>
        <title>2 Hierarchical Phrase-Based Translation</title>
        <text>An SCFG is a synchronous rewriting system generating source and target side string pairs simultaneously based on a context-free grammar. Each synchronous production (i.e., rule) rewrites a nonterminal into a pair of strings, &#947; and &#945;, where &#947; (or &#945;) contains terminal and nonterminal symbols from the source (or target) language and there is a one-toone correspondence between the nonterminal symbols on both sides. In particular, the hierarchical model (Chiang, 2007) studied in this paper explores hierarchical structures of natural language and utilize only a unified nonterminal symbol X in the grammar,
X &#8594; &#12296;&#947;, &#945;, &#8764;&#12297;
where &#8764; is the one-to-one correspondence between X&#8217;s in &#947; and &#945;, and it can be indicated by underscripted co-indexes. Two example English-to- Chinese translation rules are represented as follows:
X &#8594; &#12296;give the pen to me, &#38050; &#31508; &#32473; &#25105; &#12297; (1)
X &#8594; &#12296;give X 1 to me, X 1 &#32473; &#25105; &#12297; (2)
The SCFG rules of hierarchical phrase-based models are extracted automatically from corpora of word-aligned parallel sentence pairs (Brown et al., 1993; Och and Ney, 2000). An aligned sentence pair is a tuple (E, F, A), where E = e 1 &#183; &#183; &#183; e n can be interpreted as an English sentence of length n, F = f 1 &#183; &#183; &#183; f m its translation of length m in a foreign language, and A a set of links between words of the two sentences. Figure 1 (a) shows an example of aligned English-to-Chinese sentence pair. Widely adopted in phrase-based models (Och and Ney, 2004), a pair of consecutive sequences of words from E and F is a phrase pair if all words are aligned only within the sequences and not to any word outside. We call a sequence of words a phrase if it corresponds to either side of a phrase pair, and a non-phrase otherwise. Note that the boundary words of a phrase pair may not be aligned to any other word. We call the phrase pairs with all boundary words aligned tight phrase pairs (Zhang et al., 2008). A tight phrase pair is the minimal phrase pair among all that share the same set of alignment links. Figure 1 (b) highlights the tight phrase pairs in the example sentence pair.
(a)
1 2 3 4 5
(b)
The extraction of SCFG rules proceeds as follows. In the first step, all phrase pairs below a maximum length are extracted as phrasal rules. In the second step, abstract rules are extracted from tight phrase pairs that contain other tight phrase pairs by replacing the sub phrase pairs with co-indexed X- nonterminals. Chiang (2007) also introduced several requirements (e.g., there are at most two nonterminals at the right hand side of a rule) to safeguard the quality of the abstract rules as well as keeping decoding efficient. In our example above, rule (2) can be extracted from rule (1) with the following sub phrase pair:
X &#8594; &#12296;the pen, &#38050; &#31508; &#12297;
The use of a unified X nonterminal makes hierarchical phrase-based models flexible at capturing non-local reordering of phrases. However, such flexibility also comes at the cost that it is not able to differentiate between different syntactic usages of phrases. Suppose rule X &#8594; &#12296;I am reading X 1 , &#183; &#183; &#183; &#12297; is extracted from a phrase pair with I am reading a book on the source side where X 1 is abstracted from the noun phrase pair . If this rule is used to translate I am reading the brochure of a book fair, it would be better to apply it over the entire string than over sub-strings such as I ... the brochure of. This is because the nonterminal X 1 in the rule was abstracted from a noun phrase on the source side of the training data and would thus be better (more informative) to be applied to phrases of the same type. Hierarchical phrase-based models are not able to distinguish syntactic differences like this.
Zollmann and Venugopal (2006) attempted to address this problem by annotating phrase pairs with treebank categories based on automatic parse trees. They introduced an extended set of categories (e.g., NP+V for she went and DT\NP for great wall, an noun phrase with a missing determiner on the left) to annotate phrase pairs that do not align with syntactic constituents. Their hard syntactic constraint requires that the nonterminals should match exactly to rewrite with a rule, which could rule out potentially correct derivations due to errors in the syntactic parses as well as to data sparsity. For example, NP cannot be instantiated with phrase pairs of type DT+NN, in spite of their syntactic similarity. Venugopal et al. (2009) addressed this problem by directly introducing soft syntactic preferences into SCFG rules using preference grammars, but they had to face the computational challenges of large preference vectors. Chiang (2010) also avoided hard constraints and took a soft alternative that directly models the cost of mismatched rule substitutions. This, however, would require a large number of parameters to be tuned on a generally small-sized heldout set, and it could thus suffer from over-tuning.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>An SCFG is a synchronous rewriting system generating source and target side string pairs simultaneously based on a context-free grammar.</text>
              <doc_id>30</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Each synchronous production (i.e., rule) rewrites a nonterminal into a pair of strings, &#947; and &#945;, where &#947; (or &#945;) contains terminal and nonterminal symbols from the source (or target) language and there is a one-toone correspondence between the nonterminal symbols on both sides.</text>
              <doc_id>31</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>In particular, the hierarchical model (Chiang, 2007) studied in this paper explores hierarchical structures of natural language and utilize only a unified nonterminal symbol X in the grammar,</text>
              <doc_id>32</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>X &#8594; &#12296;&#947;, &#945;, &#8764;&#12297;</text>
              <doc_id>33</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>where &#8764; is the one-to-one correspondence between X&#8217;s in &#947; and &#945;, and it can be indicated by underscripted co-indexes.</text>
              <doc_id>34</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Two example English-to- Chinese translation rules are represented as follows:</text>
              <doc_id>35</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>X &#8594; &#12296;give the pen to me, &#38050; &#31508; &#32473; &#25105; &#12297; (1)</text>
              <doc_id>36</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>X &#8594; &#12296;give X 1 to me, X 1 &#32473; &#25105; &#12297; (2)</text>
              <doc_id>37</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The SCFG rules of hierarchical phrase-based models are extracted automatically from corpora of word-aligned parallel sentence pairs (Brown et al., 1993; Och and Ney, 2000).</text>
              <doc_id>38</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>An aligned sentence pair is a tuple (E, F, A), where E = e 1 &#183; &#183; &#183; e n can be interpreted as an English sentence of length n, F = f 1 &#183; &#183; &#183; f m its translation of length m in a foreign language, and A a set of links between words of the two sentences.</text>
              <doc_id>39</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Figure 1 (a) shows an example of aligned English-to-Chinese sentence pair.</text>
              <doc_id>40</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Widely adopted in phrase-based models (Och and Ney, 2004), a pair of consecutive sequences of words from E and F is a phrase pair if all words are aligned only within the sequences and not to any word outside.</text>
              <doc_id>41</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>We call a sequence of words a phrase if it corresponds to either side of a phrase pair, and a non-phrase otherwise.</text>
              <doc_id>42</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Note that the boundary words of a phrase pair may not be aligned to any other word.</text>
              <doc_id>43</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>We call the phrase pairs with all boundary words aligned tight phrase pairs (Zhang et al., 2008).</text>
              <doc_id>44</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>A tight phrase pair is the minimal phrase pair among all that share the same set of alignment links.</text>
              <doc_id>45</doc_id>
              <sec_id>7</sec_id>
            </sentence>
            <sentence>
              <text>Figure 1 (b) highlights the tight phrase pairs in the example sentence pair.</text>
              <doc_id>46</doc_id>
              <sec_id>8</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>(a)</text>
              <doc_id>47</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>1 2 3 4 5</text>
              <doc_id>48</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>(b)</text>
              <doc_id>49</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The extraction of SCFG rules proceeds as follows.</text>
              <doc_id>50</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>In the first step, all phrase pairs below a maximum length are extracted as phrasal rules.</text>
              <doc_id>51</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>In the second step, abstract rules are extracted from tight phrase pairs that contain other tight phrase pairs by replacing the sub phrase pairs with co-indexed X- nonterminals.</text>
              <doc_id>52</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Chiang (2007) also introduced several requirements (e.g., there are at most two nonterminals at the right hand side of a rule) to safeguard the quality of the abstract rules as well as keeping decoding efficient.</text>
              <doc_id>53</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>In our example above, rule (2) can be extracted from rule (1) with the following sub phrase pair:</text>
              <doc_id>54</doc_id>
              <sec_id>4</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>X &#8594; &#12296;the pen, &#38050; &#31508; &#12297;</text>
              <doc_id>55</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The use of a unified X nonterminal makes hierarchical phrase-based models flexible at capturing non-local reordering of phrases.</text>
              <doc_id>56</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>However, such flexibility also comes at the cost that it is not able to differentiate between different syntactic usages of phrases.</text>
              <doc_id>57</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Suppose rule X &#8594; &#12296;I am reading X 1 , &#183; &#183; &#183; &#12297; is extracted from a phrase pair with I am reading a book on the source side where X 1 is abstracted from the noun phrase pair .</text>
              <doc_id>58</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>If this rule is used to translate I am reading the brochure of a book fair, it would be better to apply it over the entire string than over sub-strings such as I ... the brochure of.</text>
              <doc_id>59</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>This is because the nonterminal X 1 in the rule was abstracted from a noun phrase on the source side of the training data and would thus be better (more informative) to be applied to phrases of the same type.</text>
              <doc_id>60</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Hierarchical phrase-based models are not able to distinguish syntactic differences like this.</text>
              <doc_id>61</doc_id>
              <sec_id>5</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Zollmann and Venugopal (2006) attempted to address this problem by annotating phrase pairs with treebank categories based on automatic parse trees.</text>
              <doc_id>62</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>They introduced an extended set of categories (e.g., NP+V for she went and DT\NP for great wall, an noun phrase with a missing determiner on the left) to annotate phrase pairs that do not align with syntactic constituents.</text>
              <doc_id>63</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Their hard syntactic constraint requires that the nonterminals should match exactly to rewrite with a rule, which could rule out potentially correct derivations due to errors in the syntactic parses as well as to data sparsity.</text>
              <doc_id>64</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>For example, NP cannot be instantiated with phrase pairs of type DT+NN, in spite of their syntactic similarity.</text>
              <doc_id>65</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Venugopal et al. (2009) addressed this problem by directly introducing soft syntactic preferences into SCFG rules using preference grammars, but they had to face the computational challenges of large preference vectors.</text>
              <doc_id>66</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Chiang (2010) also avoided hard constraints and took a soft alternative that directly models the cost of mismatched rule substitutions.</text>
              <doc_id>67</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>This, however, would require a large number of parameters to be tuned on a generally small-sized heldout set, and it could thus suffer from over-tuning.</text>
              <doc_id>68</doc_id>
              <sec_id>6</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>3</index>
        <title>3 Approach Overview</title>
        <text>In this work, we take a different approach to introduce linguistic syntax to hierarchical phrase-based translation systems and impose soft syntactic constraints between derivation rules and the syntactic parse of the sentence to be translated. For each phrase pair extracted from a sentence pair of a source-side parsed parallel corpus, we abstract its syntax by the sequence of highest root categories, which we call a tag sequence, that exactly 1 dominates the syntactic tree fragments of the source-side phrase. Figure 3 (b) shows the source-side parse tree of a sentence pair. The tag sequence for &#8220;the pen&#8221; is simply &#8220;NP&#8221; because it is a noun phrase, while phrase &#8220;give the pen&#8221; is dominated by a verb followed by a noun phrase, and thus its tag sequence is &#8220;VBP NP&#8221;.
Let T S = {ts 1 , &#183; &#183; &#183; , ts m } be the set of all tag sequences extracted from a parallel corpus. The syntax of each X nonterminal 2 in a SCFG rule can be then
1 In case of a non-tight phrase pair, we only abstract and
compare the syntax of the largest tight part. 2 There are three X nonterminals (one on the left and two on
the right) for binary abstract rules, two for unary abstract rules, and one for phrasal rules.
Tag Sequence Probability
characterized by the distribution of tag sequences &#8407;P X (T S) = (p X (ts 1 ), &#183; &#183; &#183; , p X (ts m )), based on the phrase pairs it is abstracted from. Table 1 shows an example distribution of tag sequences for X 1 in X &#8594; &#12296;I am reading X 1 , &#183; &#183; &#183; &#12297;. Instead of directly using tag sequences, as we discussed their disadvantages above, we represent each of them by a real-valued feature vector. Suppose we have a collection of n latent syntactic categories C = {c 1 , &#183; &#183; &#183; , c n }. For each tag sequence ts, we compute its distribution of latent syntactic categories P &#8407; ts (C) = (p ts (c 1 ), &#183; &#183; &#183; , p ts (c n )). For example, P &#8407; &#8220;NP VP&#8221; (C) = {0.5, 0.2, 0.3} means that the latent syntactic categories c 1 , c 2 , and c 3 are distributed as p(c 1 ) = 0.5, p(c 2 ) = 0.2, and p(c 3 ) = 0.3 for tag sequence &#8220;NP VP&#8221;. We further convert the distribution to a normalized feature vector F &#8407; (ts) to represent tag sequence ts:
&#8407;F (ts) = (f 1 (ts), &#183; &#183; &#183; , f n (ts))
= (p ts(c 1 ), &#183; &#183; &#183; , p ts (c n )) &#8214;(p ts (c 1 ), &#183; &#183; &#183; , p ts (c n ))&#8214;
The advantage of using real-valued feature vectors is that the degree of similarity between two tag sequences ts and ts &#8242; in the space of the latent syntactic categories C can be simply computed as a dotproduct 3 of their feature vectors:
&#8407;F (ts) &#183; &#8407;F (ts &#8242; ) = &#8721; f i (ts)f i (ts &#8242; )
1&#8804;i&#8804;n
which computes a syntactic similarity score in the range of 0 (totally syntactically different) to 1 (completely syntactically identical).
Similarly, we can represent the syntax of each X nonterminal in a rule with a feature vector &#8407; F (X), computed as the sum of the feature vectors of tag
3 Other measures such as KL-divergence in the probability
space are also feasible.
sequences weighted by the distribution of tag sequences of the nonterminal X:
&#8407;F (X) = &#8721;
ts&#8712;T S
p X (ts) &#8407; F (ts)
Now we can impose soft syntactic constraints using these feature vectors when a SCFG rule is used to translate a parsed source sentence. Given that a X nonterminal in the rule is applied to a span with tag sequence 4 ts as determined by a syntactic parser, we can compute the following syntax similarity feature:
SynSim(X, ts) = &#8722; log( &#8407; F (ts) &#183; &#8407;F (X))
Except that it is computed on the fly, this feature can be used in the same way as the regular features in hierarchical translation systems to determine the best translation, and its feature weight can be tuned in the same way together with the other features on a held-out data set. In our approach, the set of latent syntactic categories is automatically induced from a source-side parsed, word-aligned parallel corpus based on the hierarchical structure among phrase pairs along with the syntactic parse of the source side. In what follows, we will explain the two critical aspects of our approach, i.e., how to identify the hierarchical structures among all phrase pairs in a sentence pair, and how to induce the latent syntactic categories from the hierarchy to syntactically explain the phrase pairs.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>In this work, we take a different approach to introduce linguistic syntax to hierarchical phrase-based translation systems and impose soft syntactic constraints between derivation rules and the syntactic parse of the sentence to be translated.</text>
              <doc_id>69</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>For each phrase pair extracted from a sentence pair of a source-side parsed parallel corpus, we abstract its syntax by the sequence of highest root categories, which we call a tag sequence, that exactly 1 dominates the syntactic tree fragments of the source-side phrase.</text>
              <doc_id>70</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Figure 3 (b) shows the source-side parse tree of a sentence pair.</text>
              <doc_id>71</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>The tag sequence for &#8220;the pen&#8221; is simply &#8220;NP&#8221; because it is a noun phrase, while phrase &#8220;give the pen&#8221; is dominated by a verb followed by a noun phrase, and thus its tag sequence is &#8220;VBP NP&#8221;.</text>
              <doc_id>72</doc_id>
              <sec_id>3</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Let T S = {ts 1 , &#183; &#183; &#183; , ts m } be the set of all tag sequences extracted from a parallel corpus.</text>
              <doc_id>73</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>The syntax of each X nonterminal 2 in a SCFG rule can be then</text>
              <doc_id>74</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>1 In case of a non-tight phrase pair, we only abstract and</text>
              <doc_id>75</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>compare the syntax of the largest tight part.</text>
              <doc_id>76</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>2 There are three X nonterminals (one on the left and two on</text>
              <doc_id>77</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>the right) for binary abstract rules, two for unary abstract rules, and one for phrasal rules.</text>
              <doc_id>78</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Tag Sequence Probability</text>
              <doc_id>79</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>characterized by the distribution of tag sequences &#8407;P X (T S) = (p X (ts 1 ), &#183; &#183; &#183; , p X (ts m )), based on the phrase pairs it is abstracted from.</text>
              <doc_id>80</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Table 1 shows an example distribution of tag sequences for X 1 in X &#8594; &#12296;I am reading X 1 , &#183; &#183; &#183; &#12297;.</text>
              <doc_id>81</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Instead of directly using tag sequences, as we discussed their disadvantages above, we represent each of them by a real-valued feature vector.</text>
              <doc_id>82</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Suppose we have a collection of n latent syntactic categories C = {c 1 , &#183; &#183; &#183; , c n }.</text>
              <doc_id>83</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>For each tag sequence ts, we compute its distribution of latent syntactic categories P &#8407; ts (C) = (p ts (c 1 ), &#183; &#183; &#183; , p ts (c n )).</text>
              <doc_id>84</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>For example, P &#8407; &#8220;NP VP&#8221; (C) = {0.5, 0.2, 0.3} means that the latent syntactic categories c 1 , c 2 , and c 3 are distributed as p(c 1 ) = 0.5, p(c 2 ) = 0.2, and p(c 3 ) = 0.3 for tag sequence &#8220;NP VP&#8221;.</text>
              <doc_id>85</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>We further convert the distribution to a normalized feature vector F &#8407; (ts) to represent tag sequence ts:</text>
              <doc_id>86</doc_id>
              <sec_id>6</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8407;F (ts) = (f 1 (ts), &#183; &#183; &#183; , f n (ts))</text>
              <doc_id>87</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>= (p ts(c 1 ), &#183; &#183; &#183; , p ts (c n )) &#8214;(p ts (c 1 ), &#183; &#183; &#183; , p ts (c n ))&#8214;</text>
              <doc_id>88</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The advantage of using real-valued feature vectors is that the degree of similarity between two tag sequences ts and ts &#8242; in the space of the latent syntactic categories C can be simply computed as a dotproduct 3 of their feature vectors:</text>
              <doc_id>89</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8407;F (ts) &#183; &#8407;F (ts &#8242; ) = &#8721; f i (ts)f i (ts &#8242; )</text>
              <doc_id>90</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>1&#8804;i&#8804;n</text>
              <doc_id>91</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>which computes a syntactic similarity score in the range of 0 (totally syntactically different) to 1 (completely syntactically identical).</text>
              <doc_id>92</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Similarly, we can represent the syntax of each X nonterminal in a rule with a feature vector &#8407; F (X), computed as the sum of the feature vectors of tag</text>
              <doc_id>93</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>3 Other measures such as KL-divergence in the probability</text>
              <doc_id>94</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>space are also feasible.</text>
              <doc_id>95</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>sequences weighted by the distribution of tag sequences of the nonterminal X:</text>
              <doc_id>96</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8407;F (X) = &#8721;</text>
              <doc_id>97</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>ts&#8712;T S</text>
              <doc_id>98</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>p X (ts) &#8407; F (ts)</text>
              <doc_id>99</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Now we can impose soft syntactic constraints using these feature vectors when a SCFG rule is used to translate a parsed source sentence.</text>
              <doc_id>100</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Given that a X nonterminal in the rule is applied to a span with tag sequence 4 ts as determined by a syntactic parser, we can compute the following syntax similarity feature:</text>
              <doc_id>101</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>SynSim(X, ts) = &#8722; log( &#8407; F (ts) &#183; &#8407;F (X))</text>
              <doc_id>102</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Except that it is computed on the fly, this feature can be used in the same way as the regular features in hierarchical translation systems to determine the best translation, and its feature weight can be tuned in the same way together with the other features on a held-out data set.</text>
              <doc_id>103</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>In our approach, the set of latent syntactic categories is automatically induced from a source-side parsed, word-aligned parallel corpus based on the hierarchical structure among phrase pairs along with the syntactic parse of the source side.</text>
              <doc_id>104</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>In what follows, we will explain the two critical aspects of our approach, i.e., how to identify the hierarchical structures among all phrase pairs in a sentence pair, and how to induce the latent syntactic categories from the hierarchy to syntactically explain the phrase pairs.</text>
              <doc_id>105</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>4</index>
        <title>4 Alignment-based Hierarchy</title>
        <text>The aforementioned abstract rule extraction algorithm of Chiang (2007) is based on the property that a tight phrase pair can contain other tight phrase pairs. Given two non-disjoint tight phrase pairs that share at least one common alignment link, there are only two relationships: either one completely includes another or they do not include one another but have a non-empty overlap, which we call a nontrivial overlap. In the second case, the intersection, differences, and union of the two phrase pairs are
4 A normalized uniform feature vector is used for tag sequences (of parsed test sentences) that are not seen on the training corpus.
X
X
X
also tight phrase pairs (see Figure 1 (b) for example), and the two phrase pairs, as well as their intersection and differences, are all sub phrase pairs of their union.
Zhang et al. (2008) exploited this property to construct a hierarchical decomposition tree (Bui-Xuan et al., 2005) of phrase pairs from a sentence pair to extract all phrase pairs in linear time. In this paper, we focus on learning the syntactic dependencies along the hierarchy of phrase pairs. Our hierarchy construction follows Heber and Stoye (2001).
Let P be the set of tight phrase pairs extracted from a sentence pair. We call a sequentially-ordered list 5 L = (p 1 , &#183; &#183; &#183; , p k ) of unique phrase pairs p i &#8712; P a chain if every two successive phrase pairs in L have a non-trivial overlap. A chain is maximal if it can not be extended to its left or right with other phrase pairs. Note that any sub-sequence of phrase pairs in a chain generates a tight phrase pair. In particular, chain L generates a tight phrase pair &#964;(L) that corresponds exactly to the union of the alignment links in p &#8712; L. We call the phrase pairs generated by maximal chains maximal phrase pairs and call the other phrase pairs non-maximal. Nonmaximal phrase pairs always overlap non-trivially with some other phrase pairs while maximal phrase pairs do not, and it can be shown that any nonmaximal phrase pair can be generated by a sequence of maximal phrase pairs. Note that the largest tight phrase pair that includes all alignment links in A is also a maximal phrase pair.
5 The phrase pairs can be sequentially ordered first by the
boundary positions of the source-side phrase and then by the boundary positions of the target-side phrase.
(a)
X X X
X X X B B B X X
X X X
X X X B B B X X
(c)
VBP
(b)
O(!) S X
CR X X CR I(!) X NP PP X
X B B B X X
VBP DT NN TO PRP .
O(!) S X VP X
CR X I(!) X NP PP X
X B B B X X
DT NN TO PRP .
(d)
Lemma 1 Given two different maximal phrase pairs p 1 and p 2 , exactly one of the following alternatives is true: p 1 and p 2 are disjoint, p 1 is a sub phrase pair of p 2 , or p 2 is a sub phrase pair of p 1 .
A direct outcome of Lemma 1 is that there is an unique decomposition tree T = (N, E) covering all of the tight phrase pairs of a sentence pair, where N is the set of maximal phrase pairs and E is the set of edges that connect between pairs of maximal phrase pairs if one is a sub phrase pair of another. All of the tight phrase pairs of a sentence pair can be extracted directly from the nodes of the decomposition tree (these phrase pairs are maximal), or generated by sequences of consecutive sibling nodes 6 (these phrase pairs are non-maximal). Figure 2 shows the decomposition tree as well as all of the tight phrase pairs that can be extracted from the example sentence pair in Figure 1.
We focus on the source side of the decomposition tree, and expand it to include all of the non-phrase
6 Unaligned words may be added.
single words within the scope of the decomposition tree as frontiers and attach each as a child of the lowest node that contains the word. We then abstract the trees nodes with two symbol, X for phrases, and B for non-phrases, and call the result the decomposition tree of the source side phrases. Figure 3 (a) depicts such tree for the English side of our example sentence pair. We further recursively binarize 7 the decomposition tree into a binarized decomposition forest such that all phrases are directly represented as nodes in the forest. Figure 3 (c) shows two of the many binarized decomposition trees in the forest.
The binarized decomposition forest compactly encodes the hierarchical structure among phrases and non-phrases. However, the coarse abstraction of phrases with X and non-phrases with B provides little information on the constraints of the hierarchy. In order to bring in syntactic constraints, we annotate the nodes in the decomposition forest with syntactic observations based on the automatic syntactic parse tree of the source side. If a node aligns with a constituent in the parse tree, we add the syntactic category (e.g., NP) of the constituent as an emitted observation of the node, otherwise, it crosses constituent boundaries and we add a designated crossing category CR as its observation. We call the resulting forest a syntactic decomposition forest. Figure 3 (d) shows two syntactic decomposition trees of the forest based on the parse tree in Figure 3 (b). We will next describe how to learn finer-grained X and B categories based on the hierarchical syntactic constraints.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>The aforementioned abstract rule extraction algorithm of Chiang (2007) is based on the property that a tight phrase pair can contain other tight phrase pairs.</text>
              <doc_id>106</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Given two non-disjoint tight phrase pairs that share at least one common alignment link, there are only two relationships: either one completely includes another or they do not include one another but have a non-empty overlap, which we call a nontrivial overlap.</text>
              <doc_id>107</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>In the second case, the intersection, differences, and union of the two phrase pairs are</text>
              <doc_id>108</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>4 A normalized uniform feature vector is used for tag sequences (of parsed test sentences) that are not seen on the training corpus.</text>
              <doc_id>109</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>X</text>
              <doc_id>110</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>X</text>
              <doc_id>111</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>X</text>
              <doc_id>112</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>also tight phrase pairs (see Figure 1 (b) for example), and the two phrase pairs, as well as their intersection and differences, are all sub phrase pairs of their union.</text>
              <doc_id>113</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Zhang et al. (2008) exploited this property to construct a hierarchical decomposition tree (Bui-Xuan et al., 2005) of phrase pairs from a sentence pair to extract all phrase pairs in linear time.</text>
              <doc_id>114</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>In this paper, we focus on learning the syntactic dependencies along the hierarchy of phrase pairs.</text>
              <doc_id>115</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Our hierarchy construction follows Heber and Stoye (2001).</text>
              <doc_id>116</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Let P be the set of tight phrase pairs extracted from a sentence pair.</text>
              <doc_id>117</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>We call a sequentially-ordered list 5 L = (p 1 , &#183; &#183; &#183; , p k ) of unique phrase pairs p i &#8712; P a chain if every two successive phrase pairs in L have a non-trivial overlap.</text>
              <doc_id>118</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>A chain is maximal if it can not be extended to its left or right with other phrase pairs.</text>
              <doc_id>119</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Note that any sub-sequence of phrase pairs in a chain generates a tight phrase pair.</text>
              <doc_id>120</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>In particular, chain L generates a tight phrase pair &#964;(L) that corresponds exactly to the union of the alignment links in p &#8712; L.</text>
              <doc_id>121</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>We call the phrase pairs generated by maximal chains maximal phrase pairs and call the other phrase pairs non-maximal.</text>
              <doc_id>122</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>Nonmaximal phrase pairs always overlap non-trivially with some other phrase pairs while maximal phrase pairs do not, and it can be shown that any nonmaximal phrase pair can be generated by a sequence of maximal phrase pairs.</text>
              <doc_id>123</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>Note that the largest tight phrase pair that includes all alignment links in A is also a maximal phrase pair.</text>
              <doc_id>124</doc_id>
              <sec_id>7</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>5 The phrase pairs can be sequentially ordered first by the</text>
              <doc_id>125</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>boundary positions of the source-side phrase and then by the boundary positions of the target-side phrase.</text>
              <doc_id>126</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>(a)</text>
              <doc_id>127</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>X X X</text>
              <doc_id>128</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>X X X B B B X X</text>
              <doc_id>129</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>X X X</text>
              <doc_id>130</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>X X X B B B X X</text>
              <doc_id>131</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>(c)</text>
              <doc_id>132</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>VBP</text>
              <doc_id>133</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>(b)</text>
              <doc_id>134</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>O(!</text>
              <doc_id>135</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>) S X</text>
              <doc_id>136</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>CR X X CR I(!</text>
              <doc_id>137</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>) X NP PP X</text>
              <doc_id>138</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>X B B B X X</text>
              <doc_id>139</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>VBP DT NN TO PRP .</text>
              <doc_id>140</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>O(!</text>
              <doc_id>141</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>) S X VP X</text>
              <doc_id>142</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>CR X I(!</text>
              <doc_id>143</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>) X NP PP X</text>
              <doc_id>144</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>X B B B X X</text>
              <doc_id>145</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>DT NN TO PRP .</text>
              <doc_id>146</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>(d)</text>
              <doc_id>147</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Lemma 1 Given two different maximal phrase pairs p 1 and p 2 , exactly one of the following alternatives is true: p 1 and p 2 are disjoint, p 1 is a sub phrase pair of p 2 , or p 2 is a sub phrase pair of p 1 .</text>
              <doc_id>148</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>A direct outcome of Lemma 1 is that there is an unique decomposition tree T = (N, E) covering all of the tight phrase pairs of a sentence pair, where N is the set of maximal phrase pairs and E is the set of edges that connect between pairs of maximal phrase pairs if one is a sub phrase pair of another.</text>
              <doc_id>149</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>All of the tight phrase pairs of a sentence pair can be extracted directly from the nodes of the decomposition tree (these phrase pairs are maximal), or generated by sequences of consecutive sibling nodes 6 (these phrase pairs are non-maximal).</text>
              <doc_id>150</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Figure 2 shows the decomposition tree as well as all of the tight phrase pairs that can be extracted from the example sentence pair in Figure 1.</text>
              <doc_id>151</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>We focus on the source side of the decomposition tree, and expand it to include all of the non-phrase</text>
              <doc_id>152</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>6 Unaligned words may be added.</text>
              <doc_id>153</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>single words within the scope of the decomposition tree as frontiers and attach each as a child of the lowest node that contains the word.</text>
              <doc_id>154</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>We then abstract the trees nodes with two symbol, X for phrases, and B for non-phrases, and call the result the decomposition tree of the source side phrases.</text>
              <doc_id>155</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Figure 3 (a) depicts such tree for the English side of our example sentence pair.</text>
              <doc_id>156</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>We further recursively binarize 7 the decomposition tree into a binarized decomposition forest such that all phrases are directly represented as nodes in the forest.</text>
              <doc_id>157</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Figure 3 (c) shows two of the many binarized decomposition trees in the forest.</text>
              <doc_id>158</doc_id>
              <sec_id>4</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The binarized decomposition forest compactly encodes the hierarchical structure among phrases and non-phrases.</text>
              <doc_id>159</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>However, the coarse abstraction of phrases with X and non-phrases with B provides little information on the constraints of the hierarchy.</text>
              <doc_id>160</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>In order to bring in syntactic constraints, we annotate the nodes in the decomposition forest with syntactic observations based on the automatic syntactic parse tree of the source side.</text>
              <doc_id>161</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>If a node aligns with a constituent in the parse tree, we add the syntactic category (e.g., NP) of the constituent as an emitted observation of the node, otherwise, it crosses constituent boundaries and we add a designated crossing category CR as its observation.</text>
              <doc_id>162</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>We call the resulting forest a syntactic decomposition forest.</text>
              <doc_id>163</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Figure 3 (d) shows two syntactic decomposition trees of the forest based on the parse tree in Figure 3 (b).</text>
              <doc_id>164</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>We will next describe how to learn finer-grained X and B categories based on the hierarchical syntactic constraints.</text>
              <doc_id>165</doc_id>
              <sec_id>6</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>5</index>
        <title>5 Inducing Latent Syntactic Categories</title>
        <text>If we designate a unique symbol S as the new root of the syntactic decomposition forests introduced in the previous section, it can be shown that these forests can be generated by a probabilistic contextfree grammar G = (V, &#931;, S, R, &#966;), where
&#8226; V = {S, X, B} is the set of nonterminals,
&#8226; &#931; is the set of terminals comprising treebank categories plus the CR tag (the crossing category),
7 The intermediate binarization nodes are also labeled as either X or B based on whether they exactly cover a phrase or not.
&#8226; S &#8712; V is the unique start symbol,
&#8226; R is the union of the set of production rules each rewriting a nonterminal to a sequence of nonterminals and the set of emission rules each generating a terminal from a nonterminal,
&#8226; and &#966; assigns a probability score to each rule r &#8712; R.
Such a grammar can be derived from the set of syntactic decomposition forests extracted from a source-side parsed parallel corpus, with rule probability scores estimated as the relative frequencies of the production and emission rules.
The X and B nonterminals in the grammar are coarse representations of phrase and non-phrases and do not carry any syntactic information at all. In order to introduce syntax to these nonterminals, we incrementally split 8 them into a set of latent categories {X 1 , &#183; &#183; &#183; , X n } for X and another set {B 1 , &#183; &#183; &#183; , B n } for B, and then learn a set of rule probabilities 9 &#966; on the latent categories so that the likelihood of the training forests are maximized. The motivation is to let the latent categories learn different preferences of (emitted) syntactic categories as well as structural dependencies along the hierarchy so that they can carry syntactic information. We call them latent syntactic categories. The learned X i &#8217;s represent syntactically-induced finer-grained categories of phrases and are used as the set of latent syntactic categories C described in Section 3. In related research, Matsuzaki et al. (2005) and Petrov et al. (2006) introduced latent variables to learn finergrained distinctions of treebank categories for parsing, and Huang et al. (2009) used a similar approach to learn finer-grained part-of-speech tags for tagging. Our method is in spirit similar to these approaches.
Optimization of grammar parameters to maximize the likelihood of training forests can be achieved
8 We incrementally split each nonterminal to 2, 4, 8, and finally 16 categories, with each splitting followed by several EM iterations to tune model parameters. We consider 16 an appropriate number for latent categories, not too small to differentiate between different syntactic usages and not too large for the extra computational and storage costs. 9 Each binary production rule is now associated with a 3-
dimensional matrix of probabilities, and each emission rule associated with a 1-dimensional array of probabilities.
by a variant of Expectation-Maximization (EM) algorithm. Recall that our decomposition forests are fully binarized (except the root). In the hypergraph representation (Huang and Chiang, 2005), the hyperedges of our forests all have the same format 10 &#12296;(V, W ), U&#12297;, meaning that node U expands to nodes V and W with production rule U &#8594; V W . Given a forest F with root node R, we denote e(U) the emitted syntactic category at node U and LR(U) (or PL(W ), or PR(V )) 11 the set of node pairs (V, W ) (or (U, V ), or (U, W )) such that &#12296;(V, W ), U&#12297; is a hyperedge of the forest. Now consider node U, which is either S, X, or B, in the forest. Let U x be the latent syntactic category 12 of node U. We define I(U x ) the part of the forest (includes e(U) but not U x ) inside U, and O(U x ) the other part of the forest (includes U x but not e(U)) outside U, as illustrated in Figure 3 (d). The inside-outside probabilities are defined as:
P IN (U x ) = P (I(U x )|U x )
P OUT (U x ) = P (O(U x )|S)
which can be computed recursively as:
P IN (U x ) =
P OUT (U x ) =
+
&#8721; &#8721;
(V,W )&#8712;LR(U) y,z
&#8721; &#8721;
(V,W )&#8712;PL(U) y,z
&#8721; &#8721;
(V,W )&#8712;PR(U) y,z
&#966;(U x &#8594; e(U)) &#215;&#966;(U x &#8594; V y W z ) &#215;P IN (V y )P IN (W z )
&#966;(V y &#8594; e(V )) &#215;&#966;(V y &#8594; W z U x ) &#215;P OUT (V y )P IN (W z )
&#966;(V y &#8594; e(V )) &#215;&#966;(V y &#8594; U x W z ) &#215;P OUT (V y )P IN (W z )
In the E-step, the posterior probability of the occurrence of production rule 13 U x &#8594; V y W z is computed as:
P (U x &#8594; V y W z |F ) =
&#966;(U x &#8594; e(U))
&#215;&#966;(U x &#8594; V y W z ) &#215;P OUT (U x )P IN (V y )P IN (W w ) P IN (R)
10 The hyperedge corresponding to the root node has a different format because it is unary, but it can be handled similarly. When clear from context, we use the same variable to present both a node and its label. 11 LR stands for the left and right children, PL for the parent
and left children, and PR for the parent and right children. 12 We never split the start symbol S, and denote S 0 = S. 13 The emission rules can be handled similarly.
In the M-step, the expected counts of rule U x &#8594; V y W z for all latent categories V y and W z are accumulated together and then normalized to obtain an update of the probability estimation:
&#966;(U x &#8594; V y W z ) =
#(U x &#8594; V y W z ) &#8721; &#8721; #(U x &#8594; V y W z )
(V &#8242; ,W &#8242; ) y,z
Recall that each node U labeled as X in a forest is associated with a phrase whose syntax is abstracted by a tag sequence. Once a grammar is learned, for each such node with a corresponding tag sequence ts in forest F , we compute the posterior probability that the latent category of node U being X i as:
P (X i |ts) = P OUT(U i )P IN (U i ) P IN (R)
This contributes P (X i |ts) evidence that tag sequence ts belongs to a X i category. When all of the evidences are computed and accumulated in #(X i , ts), they can then be normalized to obtain the probability that the latent category of ts is X i :
p ts (X i ) =
#(X i, ts) &#8721;
i #(X i, ts)
As described in Section 3, the distributions of latent categories are used to compute the syntactic feature vectors for the SCFG rules.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>If we designate a unique symbol S as the new root of the syntactic decomposition forests introduced in the previous section, it can be shown that these forests can be generated by a probabilistic contextfree grammar G = (V, &#931;, S, R, &#966;), where</text>
              <doc_id>166</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8226; V = {S, X, B} is the set of nonterminals,</text>
              <doc_id>167</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8226; &#931; is the set of terminals comprising treebank categories plus the CR tag (the crossing category),</text>
              <doc_id>168</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>7 The intermediate binarization nodes are also labeled as either X or B based on whether they exactly cover a phrase or not.</text>
              <doc_id>169</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8226; S &#8712; V is the unique start symbol,</text>
              <doc_id>170</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8226; R is the union of the set of production rules each rewriting a nonterminal to a sequence of nonterminals and the set of emission rules each generating a terminal from a nonterminal,</text>
              <doc_id>171</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8226; and &#966; assigns a probability score to each rule r &#8712; R.</text>
              <doc_id>172</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Such a grammar can be derived from the set of syntactic decomposition forests extracted from a source-side parsed parallel corpus, with rule probability scores estimated as the relative frequencies of the production and emission rules.</text>
              <doc_id>173</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The X and B nonterminals in the grammar are coarse representations of phrase and non-phrases and do not carry any syntactic information at all.</text>
              <doc_id>174</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>In order to introduce syntax to these nonterminals, we incrementally split 8 them into a set of latent categories {X 1 , &#183; &#183; &#183; , X n } for X and another set {B 1 , &#183; &#183; &#183; , B n } for B, and then learn a set of rule probabilities 9 &#966; on the latent categories so that the likelihood of the training forests are maximized.</text>
              <doc_id>175</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>The motivation is to let the latent categories learn different preferences of (emitted) syntactic categories as well as structural dependencies along the hierarchy so that they can carry syntactic information.</text>
              <doc_id>176</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>We call them latent syntactic categories.</text>
              <doc_id>177</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>The learned X i &#8217;s represent syntactically-induced finer-grained categories of phrases and are used as the set of latent syntactic categories C described in Section 3.</text>
              <doc_id>178</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>In related research, Matsuzaki et al. (2005) and Petrov et al. (2006) introduced latent variables to learn finergrained distinctions of treebank categories for parsing, and Huang et al. (2009) used a similar approach to learn finer-grained part-of-speech tags for tagging.</text>
              <doc_id>179</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>Our method is in spirit similar to these approaches.</text>
              <doc_id>180</doc_id>
              <sec_id>6</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Optimization of grammar parameters to maximize the likelihood of training forests can be achieved</text>
              <doc_id>181</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>8 We incrementally split each nonterminal to 2, 4, 8, and finally 16 categories, with each splitting followed by several EM iterations to tune model parameters.</text>
              <doc_id>182</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>We consider 16 an appropriate number for latent categories, not too small to differentiate between different syntactic usages and not too large for the extra computational and storage costs.</text>
              <doc_id>183</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>9 Each binary production rule is now associated with a 3-</text>
              <doc_id>184</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>dimensional matrix of probabilities, and each emission rule associated with a 1-dimensional array of probabilities.</text>
              <doc_id>185</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>by a variant of Expectation-Maximization (EM) algorithm.</text>
              <doc_id>186</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Recall that our decomposition forests are fully binarized (except the root).</text>
              <doc_id>187</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>In the hypergraph representation (Huang and Chiang, 2005), the hyperedges of our forests all have the same format 10 &#12296;(V, W ), U&#12297;, meaning that node U expands to nodes V and W with production rule U &#8594; V W .</text>
              <doc_id>188</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Given a forest F with root node R, we denote e(U) the emitted syntactic category at node U and LR(U) (or PL(W ), or PR(V )) 11 the set of node pairs (V, W ) (or (U, V ), or (U, W )) such that &#12296;(V, W ), U&#12297; is a hyperedge of the forest.</text>
              <doc_id>189</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Now consider node U, which is either S, X, or B, in the forest.</text>
              <doc_id>190</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Let U x be the latent syntactic category 12 of node U.</text>
              <doc_id>191</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>We define I(U x ) the part of the forest (includes e(U) but not U x ) inside U, and O(U x ) the other part of the forest (includes U x but not e(U)) outside U, as illustrated in Figure 3 (d).</text>
              <doc_id>192</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>The inside-outside probabilities are defined as:</text>
              <doc_id>193</doc_id>
              <sec_id>7</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>P IN (U x ) = P (I(U x )|U x )</text>
              <doc_id>194</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>P OUT (U x ) = P (O(U x )|S)</text>
              <doc_id>195</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>which can be computed recursively as:</text>
              <doc_id>196</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>P IN (U x ) =</text>
              <doc_id>197</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>P OUT (U x ) =</text>
              <doc_id>198</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>+</text>
              <doc_id>199</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8721; &#8721;</text>
              <doc_id>200</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>(V,W )&#8712;LR(U) y,z</text>
              <doc_id>201</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8721; &#8721;</text>
              <doc_id>202</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>(V,W )&#8712;PL(U) y,z</text>
              <doc_id>203</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8721; &#8721;</text>
              <doc_id>204</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>(V,W )&#8712;PR(U) y,z</text>
              <doc_id>205</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#966;(U x &#8594; e(U)) &#215;&#966;(U x &#8594; V y W z ) &#215;P IN (V y )P IN (W z )</text>
              <doc_id>206</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#966;(V y &#8594; e(V )) &#215;&#966;(V y &#8594; W z U x ) &#215;P OUT (V y )P IN (W z )</text>
              <doc_id>207</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#966;(V y &#8594; e(V )) &#215;&#966;(V y &#8594; U x W z ) &#215;P OUT (V y )P IN (W z )</text>
              <doc_id>208</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>In the E-step, the posterior probability of the occurrence of production rule 13 U x &#8594; V y W z is computed as:</text>
              <doc_id>209</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>P (U x &#8594; V y W z |F ) =</text>
              <doc_id>210</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#966;(U x &#8594; e(U))</text>
              <doc_id>211</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#215;&#966;(U x &#8594; V y W z ) &#215;P OUT (U x )P IN (V y )P IN (W w ) P IN (R)</text>
              <doc_id>212</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>10 The hyperedge corresponding to the root node has a different format because it is unary, but it can be handled similarly.</text>
              <doc_id>213</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>When clear from context, we use the same variable to present both a node and its label.</text>
              <doc_id>214</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>11 LR stands for the left and right children, PL for the parent</text>
              <doc_id>215</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>and left children, and PR for the parent and right children.</text>
              <doc_id>216</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>12 We never split the start symbol S, and denote S 0 = S.</text>
              <doc_id>217</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>13 The emission rules can be handled similarly.</text>
              <doc_id>218</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>In the M-step, the expected counts of rule U x &#8594; V y W z for all latent categories V y and W z are accumulated together and then normalized to obtain an update of the probability estimation:</text>
              <doc_id>219</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#966;(U x &#8594; V y W z ) =</text>
              <doc_id>220</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>#(U x &#8594; V y W z ) &#8721; &#8721; #(U x &#8594; V y W z )</text>
              <doc_id>221</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>(V &#8242; ,W &#8242; ) y,z</text>
              <doc_id>222</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Recall that each node U labeled as X in a forest is associated with a phrase whose syntax is abstracted by a tag sequence.</text>
              <doc_id>223</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Once a grammar is learned, for each such node with a corresponding tag sequence ts in forest F , we compute the posterior probability that the latent category of node U being X i as:</text>
              <doc_id>224</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>P (X i |ts) = P OUT(U i )P IN (U i ) P IN (R)</text>
              <doc_id>225</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>This contributes P (X i |ts) evidence that tag sequence ts belongs to a X i category.</text>
              <doc_id>226</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>When all of the evidences are computed and accumulated in #(X i , ts), they can then be normalized to obtain the probability that the latent category of ts is X i :</text>
              <doc_id>227</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>p ts (X i ) =</text>
              <doc_id>228</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>#(X i, ts) &#8721;</text>
              <doc_id>229</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>i #(X i, ts)</text>
              <doc_id>230</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>As described in Section 3, the distributions of latent categories are used to compute the syntactic feature vectors for the SCFG rules.</text>
              <doc_id>231</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>6</index>
        <title>6 Experiments</title>
        <text>We conduct experiments on two tasks, English-to- German and English-to-Chinese, both aimed for speech-to-speech translation. The training data for the English-to-German task is a filtered subset of the Europarl corpus (Koehn, 2005), containing &#8764;300k parallel bitext with &#8764;4.5M tokens on each side. The dev and test sets both contain 1k sentences with one reference for each. The training data for the Englishto-Chinese task is collected from transcription and human translation of conversations in travel domain. It consists of &#8764;500k parallel bitext with &#8764;3M tokens 14 on each side. Both dev and test sets contain &#8764;1.3k sentences, each with two references. Both
14 The Chinese sentences are automatically segmented into
words. However, BLEU scores are computed at character level for tuning and evaluation.
corpora are also preprocessed with punctuation removed and words down-cased to make them suitable for speech translation.
The baseline system is our implementation of the hierarchical phrase-based model of Chiang (2007), and it includes basic features such as rule and lexicalized rule translation probabilities, language model scores, rule counts, etc. We use 4-gram language models in both tasks, and conduct minimumerror-rate training (Och, 2003) to optimize feature weights on the dev set. Our baseline hierarchical model has 8.3M and 9.7M rules for the English-to- German and English-to-Chinese tasks, respectively.
The English side of the parallel data is parsed by our implementation of the Berkeley parser (Huang and Harper, 2009) trained on the combination of Broadcast News treebank from Ontonotes (Weischedel et al., 2008) and a speechified version of the WSJ treebank (Marcus et al., 1999) to achieve higher parsing accuracy (Huang et al., 2010). Our approach introduces a new syntactic feature and its feature weight is tuned in the same way together with the features in the baseline model. In this study, we induce 16 latent categories for both X and B nonterminals.
Our approach identifies &#8764;180k unique tag sequences for the English side of phrase pairs in both tasks. As shown by the examples in Table 2, the syntactic feature vector representation is able to identify similar and dissimilar tag sequences. For instance, it determines that the sequence of &#8220;DT JJ NN&#8221; is syntactically very similar to &#8220;DT ADJP NN&#8221; while very dissimilar to &#8220;NN CD VP&#8221;. Notice that our latent categories are learned automatically to maximize the likelihood of the training forests extracted based on alignment and are not explicitly instructed to discriminate between syntactically different tag sequences. Our approach is not guaranteed to always assign similar feature vectors to syntactically similar tag sequences. However, as the experimental results show below, the latent categories are able to capture some similarities among tag sequences that are beneficial for translation.
Table 3 and 4 report the experimental results on the English-to-German and English-to-Chinese tasks, respectively. The addition of the syntax feature achieves a statistically significant improvement (p &#8804; 0.01) of 0.6 in BLEU on the test set of the Baseline +Syntax &#8710;
Baseline +Syntax &#8710;
English-to-German task. This improvement is substantial given that only one reference is used for each test sentence. On the English-to-Chinese task, the syntax feature achieves a smaller improvement of 0.41 BLEU on the test set. One potential explanation for the smaller improvement is that the sentences on the English-to-Chinese task are much shorter, with an average of only 6 words per sentence, compared to 15 words in the English-to-German task. The hypothesis space of translating a longer sentence is much larger than that of a shorter sentence. Therefore, there is more potential gain from using syntax features to rule out unlikely derivations of longer sentences, while phrasal rules might be adequate for shorter sentences, leaving less room for syntax to help as in the case of the English-to-Chinese task.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>We conduct experiments on two tasks, English-to- German and English-to-Chinese, both aimed for speech-to-speech translation.</text>
              <doc_id>232</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>The training data for the English-to-German task is a filtered subset of the Europarl corpus (Koehn, 2005), containing &#8764;300k parallel bitext with &#8764;4.5M tokens on each side.</text>
              <doc_id>233</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>The dev and test sets both contain 1k sentences with one reference for each.</text>
              <doc_id>234</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>The training data for the Englishto-Chinese task is collected from transcription and human translation of conversations in travel domain.</text>
              <doc_id>235</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>It consists of &#8764;500k parallel bitext with &#8764;3M tokens 14 on each side.</text>
              <doc_id>236</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Both dev and test sets contain &#8764;1.3k sentences, each with two references.</text>
              <doc_id>237</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>Both</text>
              <doc_id>238</doc_id>
              <sec_id>6</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>14 The Chinese sentences are automatically segmented into</text>
              <doc_id>239</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>words.</text>
              <doc_id>240</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>However, BLEU scores are computed at character level for tuning and evaluation.</text>
              <doc_id>241</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>corpora are also preprocessed with punctuation removed and words down-cased to make them suitable for speech translation.</text>
              <doc_id>242</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The baseline system is our implementation of the hierarchical phrase-based model of Chiang (2007), and it includes basic features such as rule and lexicalized rule translation probabilities, language model scores, rule counts, etc.</text>
              <doc_id>243</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>We use 4-gram language models in both tasks, and conduct minimumerror-rate training (Och, 2003) to optimize feature weights on the dev set.</text>
              <doc_id>244</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Our baseline hierarchical model has 8.3M and 9.7M rules for the English-to- German and English-to-Chinese tasks, respectively.</text>
              <doc_id>245</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>The English side of the parallel data is parsed by our implementation of the Berkeley parser (Huang and Harper, 2009) trained on the combination of Broadcast News treebank from Ontonotes (Weischedel et al., 2008) and a speechified version of the WSJ treebank (Marcus et al., 1999) to achieve higher parsing accuracy (Huang et al., 2010).</text>
              <doc_id>246</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Our approach introduces a new syntactic feature and its feature weight is tuned in the same way together with the features in the baseline model.</text>
              <doc_id>247</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>In this study, we induce 16 latent categories for both X and B nonterminals.</text>
              <doc_id>248</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Our approach identifies &#8764;180k unique tag sequences for the English side of phrase pairs in both tasks.</text>
              <doc_id>249</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>As shown by the examples in Table 2, the syntactic feature vector representation is able to identify similar and dissimilar tag sequences.</text>
              <doc_id>250</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>For instance, it determines that the sequence of &#8220;DT JJ NN&#8221; is syntactically very similar to &#8220;DT ADJP NN&#8221; while very dissimilar to &#8220;NN CD VP&#8221;.</text>
              <doc_id>251</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Notice that our latent categories are learned automatically to maximize the likelihood of the training forests extracted based on alignment and are not explicitly instructed to discriminate between syntactically different tag sequences.</text>
              <doc_id>252</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Our approach is not guaranteed to always assign similar feature vectors to syntactically similar tag sequences.</text>
              <doc_id>253</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>However, as the experimental results show below, the latent categories are able to capture some similarities among tag sequences that are beneficial for translation.</text>
              <doc_id>254</doc_id>
              <sec_id>5</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Table 3 and 4 report the experimental results on the English-to-German and English-to-Chinese tasks, respectively.</text>
              <doc_id>255</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>The addition of the syntax feature achieves a statistically significant improvement (p &#8804; 0.01) of 0.6 in BLEU on the test set of the Baseline +Syntax &#8710;</text>
              <doc_id>256</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Baseline +Syntax &#8710;</text>
              <doc_id>257</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>English-to-German task.</text>
              <doc_id>258</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>This improvement is substantial given that only one reference is used for each test sentence.</text>
              <doc_id>259</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>On the English-to-Chinese task, the syntax feature achieves a smaller improvement of 0.41 BLEU on the test set.</text>
              <doc_id>260</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>One potential explanation for the smaller improvement is that the sentences on the English-to-Chinese task are much shorter, with an average of only 6 words per sentence, compared to 15 words in the English-to-German task.</text>
              <doc_id>261</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>The hypothesis space of translating a longer sentence is much larger than that of a shorter sentence.</text>
              <doc_id>262</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Therefore, there is more potential gain from using syntax features to rule out unlikely derivations of longer sentences, while phrasal rules might be adequate for shorter sentences, leaving less room for syntax to help as in the case of the English-to-Chinese task.</text>
              <doc_id>263</doc_id>
              <sec_id>5</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>7</index>
        <title>7 Discussions</title>
        <text>The incorporation of the syntactic feature into the hierarchical phrase-based translation system also brings in additional memory load and computational cost. In the worst case, our approach requires storing one feature vector for each tag sequence and one feature vector for each nonterminal of a SCFG rule, with the latter taking the majority of the extra memory storage. We observed that about 90% of the X nonterminals in the rules only have one tag sequence, and thus the required memory space can be significantly reduced by only storing a pointer to the feature vector of the tag sequence for these nonterminals. Our approach also requires computing one dot-product of two feature vectors for each nonterminal when a SCFG rule is applied to a source span.
DT JJ NN
VP
ADJP
This cost can be reduced, however, by caching the dot-products of the tag sequences that are frequently accessed.
There are other successful investigations to impose soft syntactic constraints to hierarchical phrase-based models by either introducing syntaxbased rule features such as the prior derivation model of Zhou et al. (2008) or by imposing constraints on translation spans at decoding time, e.g., (Marton and Resnik, 2008; Xiong et al., 2009; Xiong et al., 2010). These approaches are all orthogonal to ours and it is expected that they can be combined with our approach to achieve greater improvement.
This work is an initial effort to investigate latent syntactic categories to enhance hierarchical phrasebased translation models, and there are many directions to continue this line of research. First, while the current approach imposes soft syntactic constraints between the parse structure of the source sentence and the SCFG rules used to derive the translation, the real-valued syntactic feature vectors can also be used to impose soft constraints between SCFG rules when rule rewrite occurs. In this case, target side parse trees could also be used alone or together with the source side parse trees to induce the latent syntactic categories. Second, instead of using single parse trees during both training and decoding, our approach is likely to benefit from exploring parse forests as in (Mi and Huang, 2008). Third, in addition to the treebank categories obtained by syntactic parsing, lexical cues directly available in sentence pairs could also to explored to guide the learning of latent categories. Last but not the least, it would be interesting to investigate discriminative training approaches to learn latent categories that directly optimize on translation quality.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>The incorporation of the syntactic feature into the hierarchical phrase-based translation system also brings in additional memory load and computational cost.</text>
              <doc_id>264</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>In the worst case, our approach requires storing one feature vector for each tag sequence and one feature vector for each nonterminal of a SCFG rule, with the latter taking the majority of the extra memory storage.</text>
              <doc_id>265</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>We observed that about 90% of the X nonterminals in the rules only have one tag sequence, and thus the required memory space can be significantly reduced by only storing a pointer to the feature vector of the tag sequence for these nonterminals.</text>
              <doc_id>266</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Our approach also requires computing one dot-product of two feature vectors for each nonterminal when a SCFG rule is applied to a source span.</text>
              <doc_id>267</doc_id>
              <sec_id>3</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>DT JJ NN</text>
              <doc_id>268</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>VP</text>
              <doc_id>269</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>ADJP</text>
              <doc_id>270</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>This cost can be reduced, however, by caching the dot-products of the tag sequences that are frequently accessed.</text>
              <doc_id>271</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>There are other successful investigations to impose soft syntactic constraints to hierarchical phrase-based models by either introducing syntaxbased rule features such as the prior derivation model of Zhou et al. (2008) or by imposing constraints on translation spans at decoding time, e.g., (Marton and Resnik, 2008; Xiong et al., 2009; Xiong et al., 2010).</text>
              <doc_id>272</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>These approaches are all orthogonal to ours and it is expected that they can be combined with our approach to achieve greater improvement.</text>
              <doc_id>273</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>This work is an initial effort to investigate latent syntactic categories to enhance hierarchical phrasebased translation models, and there are many directions to continue this line of research.</text>
              <doc_id>274</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>First, while the current approach imposes soft syntactic constraints between the parse structure of the source sentence and the SCFG rules used to derive the translation, the real-valued syntactic feature vectors can also be used to impose soft constraints between SCFG rules when rule rewrite occurs.</text>
              <doc_id>275</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>In this case, target side parse trees could also be used alone or together with the source side parse trees to induce the latent syntactic categories.</text>
              <doc_id>276</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Second, instead of using single parse trees during both training and decoding, our approach is likely to benefit from exploring parse forests as in (Mi and Huang, 2008).</text>
              <doc_id>277</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Third, in addition to the treebank categories obtained by syntactic parsing, lexical cues directly available in sentence pairs could also to explored to guide the learning of latent categories.</text>
              <doc_id>278</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Last but not the least, it would be interesting to investigate discriminative training approaches to learn latent categories that directly optimize on translation quality.</text>
              <doc_id>279</doc_id>
              <sec_id>5</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>8</index>
        <title>8 Conclusion</title>
        <text>We have presented a novel approach to enhance hierarchical phrase-based machine translation systems with real-valued linguistically motivated feature vectors. Our approach maintains the advantages of hierarchical phrase-based translation systems while at the same time naturally incorporates soft syntactic constraints. Experimental results showed that this approach improves the baseline hierarchical phrase-based translation models on both English-to-German and English-to-Chinese tasks. We will continue this line of research and exploit better ways to learn syntax and apply syntactic constraints to machine translation.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>We have presented a novel approach to enhance hierarchical phrase-based machine translation systems with real-valued linguistically motivated feature vectors.</text>
              <doc_id>280</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Our approach maintains the advantages of hierarchical phrase-based translation systems while at the same time naturally incorporates soft syntactic constraints.</text>
              <doc_id>281</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Experimental results showed that this approach improves the baseline hierarchical phrase-based translation models on both English-to-German and English-to-Chinese tasks.</text>
              <doc_id>282</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>We will continue this line of research and exploit better ways to learn syntax and apply syntactic constraints to machine translation.</text>
              <doc_id>283</doc_id>
              <sec_id>3</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>9</index>
        <title>Acknowledgements</title>
        <text>This work was done when the first author was visiting IBM T. J. Watson Research Center as a research intern. We would like to thank Mary Harper for lots of insightful discussions and suggestions and the anonymous reviewers for the helpful comments.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>This work was done when the first author was visiting IBM T.</text>
              <doc_id>284</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>J. Watson Research Center as a research intern.</text>
              <doc_id>285</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>We would like to thank Mary Harper for lots of insightful discussions and suggestions and the anonymous reviewers for the helpful comments.</text>
              <doc_id>286</doc_id>
              <sec_id>2</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
    </sections>
    <tables>
      <table>
        <id>1</id>
        <source>TET</source>
        <caption>Table 1: The distribution of tag sequences for X 1 in X &#8594; &#12296;I am reading X 1 , &#183; &#183; &#183; &#12297;.</caption>
        <reference_text></reference_text>
        <page_num>3</page_num>
        <head>
          <rows>
            <row>
              <cell>NP</cell>
              <cell>0.40</cell>
            </row>
          </rows>
        </head>
        <body>
          <rows>
            <row>
              <cell>DT NN</cell>
              <cell>0.35</cell>
            </row>
            <row>
              <cell>DT NN NN</cell>
              <cell>0.25</cell>
            </row>
          </rows>
        </body>
      </table>
      <table>
        <id>2</id>
        <source>TableSeer</source>
        <caption>Table 2: Examples of similar and dissimilar tag sequences.</caption>
        <reference_text>In PAGE 8: ... Our approach identifies ?180k unique tag se- quences for the English side of phrase pairs in both tasks. As shown by the examples in  Table2 , the syn- tactic feature vector representation is able to identify similar and dissimilar tag sequences. For instance, it determines that the sequence of  DT JJ NN  is syntactically very similar to  DT ADJP NN  while very dissimilar to  NN CD VP ....</reference_text>
        <page_num>9</page_num>
        <head>
          <rows>
            <row>
              <cell>Very similar</cell>
              <cell>Not so similar</cell>
              <cell>Very dissimilar</cell>
            </row>
          </rows>
        </head>
        <body>
          <rows>
            <row>
              <cell>F (ts) ? vector vector F (tsprime)  gt</cell>
              <cell>0.9</cell>
              <cell>0.4 ? vector F (ts) ? vector F (tsprime) ? 0.6</cell>
              <cell>F (ts) ? vector vector F (tsprime)  lt</cell>
              <cell>0.1</cell>
            </row>
            <row>
              <cell>DT NN</cell>
              <cell>DT JJ JJ NML NN</cell>
              <cell>PP NP NN</cell>
            </row>
            <row>
              <cell>DT JJ JJ NN</cell>
              <cell>DT JJ CC INTJ VB</cell>
              <cell>NN CD VP</cell>
            </row>
            <row>
              <cell>DT ADJP NN</cell>
              <cell>DT NN NN JJ</cell>
              <cell>RB NP IN CD</cell>
            </row>
            <row>
              <cell>VB</cell>
              <cell>VP PP JJ NN</cell>
              <cell>JJ NN TO VP</cell>
            </row>
            <row>
              <cell>VB RB VB PP</cell>
              <cell>VB NN NN VB</cell>
              <cell>JJ WHNP DT NN</cell>
            </row>
            <row>
              <cell>VB DT DT NN</cell>
              <cell>VB RB IN JJ</cell>
              <cell>IN INTJ NP</cell>
            </row>
            <row>
              <cell>JJ</cell>
              <cell>ADJP JJ JJ CC</cell>
              <cell>ADJP IN NP JJ</cell>
            </row>
            <row>
              <cell>PDT JJ</cell>
              <cell>ADJP VB JJ JJ</cell>
              <cell>AUX RB ADJP</cell>
            </row>
            <row>
              <cell>RB JJ</cell>
              <cell>ADVP WHNP JJ</cell>
              <cell>ADJP VP</cell>
            </row>
          </rows>
        </body>
      </table>
      <table>
        <id>3</id>
        <source>TET</source>
        <caption>Table 3: BLEU scores of the English-to-German task (one reference).</caption>
        <reference_text></reference_text>
        <page_num>7</page_num>
        <head>
          <rows>
            <row>
              <cell>Dev</cell>
              <cell>16.26</cell>
              <cell>17.06</cell>
              <cell>0.80</cell>
            </row>
          </rows>
        </head>
        <body>
          <rows>
            <row>
              <cell>Test</cell>
              <cell>16.41</cell>
              <cell>17.01</cell>
              <cell>0.60</cell>
            </row>
          </rows>
        </body>
      </table>
      <table>
        <id>4</id>
        <source>TableSeer</source>
        <caption>Table 3: BLEU scores of the English-to-German task (one reference).#@#@Table 4: BLEU scores of the English-to-Chinese task (two references).</caption>
        <reference_text>In PAGE 8: ... However, as the experimental results show below, the latent categories are able to capture some similarities among tag sequences that are beneficial for translation.  Table3  and 4 report the experimental results on the English-to-German and English-to-Chinese tasks, respectively. The addition of the syntax fea- ture achieves a statistically significant improvement (p ? 0....</reference_text>
        <page_num>8</page_num>
        <head>
          <rows>
            <row>
              <cell>None</cell>
              <cell>Baseline</cell>
              <cell>+Syntax</cell>
              <cell>?</cell>
            </row>
          </rows>
        </head>
        <body>
          <rows>
            <row>
              <cell>Dev</cell>
              <cell>46.47</cell>
              <cell>47.39</cell>
              <cell>0.92</cell>
            </row>
            <row>
              <cell>Test</cell>
              <cell>45.45</cell>
              <cell>45.86</cell>
              <cell>0.41</cell>
            </row>
          </rows>
        </body>
      </table>
    </tables>
    <references>
      <reference>
        <id>0</id>
        <authors>
          <author>Peter F Brown</author>
          <author>Vincent J Della Pietra</author>
          <author>Stephen A Della Pietra</author>
          <author>Robert L Mercer</author>
        </authors>
        <title>The mathemat146 of statistical machine translation: parameter estimation. Computational Linguistics.</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>1993</date>
      </reference>
      <reference>
        <id>1</id>
        <authors>
          <author>Binh Minh Bui-Xuan</author>
          <author>Michel Habib</author>
          <author>Christophe Paul</author>
        </authors>
        <title>Revisiting T. Uno and M. Yagiura&#8217;s algorithm.</title>
        <publication>In ISAAC.</publication>
        <pages>None</pages>
        <date>2005</date>
      </reference>
      <reference>
        <id>2</id>
        <authors>
          <author>David Chiang</author>
        </authors>
        <title>Hierarchical phrase-based translation. Computational Linguistics.</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>2007</date>
      </reference>
      <reference>
        <id>3</id>
        <authors>
          <author>David Chiang</author>
        </authors>
        <title>Learning to translate with source and target syntax.</title>
        <publication>In ACL.</publication>
        <pages>None</pages>
        <date>2010</date>
      </reference>
      <reference>
        <id>4</id>
        <authors>
          <author>Michel Galley</author>
          <author>Jonathan Graehl</author>
          <author>Kevin Knight</author>
          <author>Daniel Marcu</author>
          <author>Steve DeNeefe</author>
          <author>Wei Wang</author>
          <author>Ignacio Thayer</author>
        </authors>
        <title>What&#8217;s in a translation rule.</title>
        <publication>In HLT/NAACL.</publication>
        <pages>None</pages>
        <date>2004</date>
      </reference>
      <reference>
        <id>5</id>
        <authors>
          <author>Steffen Heber</author>
          <author>Jens Stoye</author>
        </authors>
        <title>Finding all common intervals of k permutations.</title>
        <publication>In CPM.</publication>
        <pages>None</pages>
        <date>2001</date>
      </reference>
      <reference>
        <id>6</id>
        <authors>
          <author>Liang Huang</author>
          <author>David Chiang</author>
        </authors>
        <title>Better k-best parsing.</title>
        <publication>In International Workshop on Parsing Technology.</publication>
        <pages>None</pages>
        <date>2005</date>
      </reference>
      <reference>
        <id>7</id>
        <authors>
          <author>Zhongqiang Huang</author>
          <author>Mary Harper</author>
        </authors>
        <title>Selftraining PCFG grammars with latent annotations across languages. In EMNLP.</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>2009</date>
      </reference>
      <reference>
        <id>8</id>
        <authors>
          <author>Liang Huang</author>
          <author>Kevin Knight</author>
          <author>Aravind Joshi</author>
        </authors>
        <title>A syntax-directed translator with extended domain of locality.</title>
        <publication>In CHSLP.</publication>
        <pages>None</pages>
        <date>2006</date>
      </reference>
      <reference>
        <id>9</id>
        <authors>
          <author>Zhongqiang Huang</author>
          <author>Vladimir Eidelman</author>
          <author>Mary Harper</author>
        </authors>
        <title>Improving a simple bigram hmm partof-speech tagger by latent annotation and self-training.</title>
        <publication>In NAACL.</publication>
        <pages>None</pages>
        <date>2009</date>
      </reference>
      <reference>
        <id>10</id>
        <authors>
          <author>Zhongqiang Huang</author>
          <author>Mary Harper</author>
          <author>Slav Petrov</author>
        </authors>
        <title>Self-training with products of latent variable.</title>
        <publication>In EMNLP.</publication>
        <pages>None</pages>
        <date>2010</date>
      </reference>
      <reference>
        <id>11</id>
        <authors>
          <author>Philipp Koehn</author>
        </authors>
        <title>Europarl: A parallel corpus for statistical machine translation.</title>
        <publication>In MT Summit.</publication>
        <pages>None</pages>
        <date>2005</date>
      </reference>
      <reference>
        <id>12</id>
        <authors>
          <author>Yang Liu</author>
          <author>Qun Liu</author>
          <author>Shouxun Lin</author>
        </authors>
        <title>Tree-tostring alignment template for statistical machine translation.</title>
        <publication>In ACL.</publication>
        <pages>None</pages>
        <date>2006</date>
      </reference>
      <reference>
        <id>13</id>
        <authors>
          <author>Mitchell P Marcus</author>
          <author>Beatrice Santorini</author>
        </authors>
        <title>None</title>
        <publication>Treebank-3. Linguistic Data Consortium,</publication>
        <pages>None</pages>
        <date>1999</date>
      </reference>
      <reference>
        <id>14</id>
        <authors>
          <author>Yuval Marton</author>
          <author>Philip Resnik</author>
        </authors>
        <title>Soft syntactic constraints for hierarchical phrased-based translation.</title>
        <publication>In ACL.</publication>
        <pages>None</pages>
        <date>2008</date>
      </reference>
      <reference>
        <id>15</id>
        <authors>
          <author>Takuya Matsuzaki</author>
          <author>Yusuke Miyao</author>
          <author>Jun&#8217;ichi Tsujii</author>
        </authors>
        <title>Probabilistic CFG with latent annotations.</title>
        <publication>In ACL.</publication>
        <pages>None</pages>
        <date>2005</date>
      </reference>
      <reference>
        <id>16</id>
        <authors>
          <author>Haitao Mi</author>
          <author>Liang Huang</author>
        </authors>
        <title>Forest-based translation rule extraction.</title>
        <publication>In EMNLP.</publication>
        <pages>None</pages>
        <date>2008</date>
      </reference>
      <reference>
        <id>17</id>
        <authors>
          <author>Haitao Mi</author>
          <author>Liang Huang</author>
          <author>Qun Liu</author>
        </authors>
        <title>Forestbased translation.</title>
        <publication>In ACL.</publication>
        <pages>None</pages>
        <date>2008</date>
      </reference>
      <reference>
        <id>18</id>
        <authors>
          <author>Franz Josef Och</author>
          <author>Hermann Ney</author>
        </authors>
        <title>Improved statistical alignment models.</title>
        <publication>In ACL.</publication>
        <pages>None</pages>
        <date>2000</date>
      </reference>
      <reference>
        <id>19</id>
        <authors>
          <author>Franz Josef Och</author>
          <author>Hermann Ney</author>
        </authors>
        <title>The alignment template approach to statistical machine translation. Computational Linguistics.</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>2004</date>
      </reference>
      <reference>
        <id>20</id>
        <authors>
          <author>Franz Josef Och</author>
        </authors>
        <title>Minimum error rate training in statistical machine translation.</title>
        <publication>In ACL.</publication>
        <pages>None</pages>
        <date>2003</date>
      </reference>
      <reference>
        <id>21</id>
        <authors>
          <author>Slav Petrov</author>
          <author>Leon Barrett</author>
          <author>Romain Thibaux</author>
          <author>Dan Klein</author>
        </authors>
        <title>Learning accurate, compact, and interpretable tree annotation.</title>
        <publication>In ACL.</publication>
        <pages>None</pages>
        <date>2006</date>
      </reference>
      <reference>
        <id>22</id>
        <authors>
          <author>Ashish Venugopal</author>
          <author>Andreas Zollmann</author>
          <author>Noah A Smith</author>
          <author>Stephan Vogel</author>
        </authors>
        <title>Preference grammars: softening syntactic constraints to improve statistical machine translation.</title>
        <publication>In NAACL.</publication>
        <pages>None</pages>
        <date>2009</date>
      </reference>
      <reference>
        <id>23</id>
        <authors>
          <author>Ralph Weischedel</author>
          <author>Sameer Pradhan</author>
          <author>Lance Ramshaw</author>
          <author>Martha Palmer</author>
        </authors>
        <title>OntoNotes Release 2.0. Linguistic Data Consortium,</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>2008</date>
      </reference>
      <reference>
        <id>24</id>
        <authors>
          <author>Dekai Wu</author>
        </authors>
        <title>Stochastic inversion transduction grammars and bilingual parsing of parallel corpora.</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>1997</date>
      </reference>
      <reference>
        <id>25</id>
        <authors>
          <author>Deyi Xiong</author>
          <author>Min Zhang</author>
          <author>Aiti Aw</author>
          <author>Haizhou Li</author>
        </authors>
        <title>A syntax-driven bracketing model for phrase-based translation.</title>
        <publication>In ACL-IJCNLP.</publication>
        <pages>None</pages>
        <date>2009</date>
      </reference>
      <reference>
        <id>26</id>
        <authors>
          <author>Deyi Xiong</author>
          <author>Min Zhang</author>
          <author>Haizhou Li</author>
        </authors>
        <title>Learning translation boundaries for phrase-based decoding.</title>
        <publication>In NAACL-HLT.</publication>
        <pages>None</pages>
        <date>2010</date>
      </reference>
      <reference>
        <id>27</id>
        <authors>
          <author>Kenji Yamada</author>
          <author>Kevin Knight</author>
        </authors>
        <title>A syntax-based statistical translation model.</title>
        <publication>In ACL.</publication>
        <pages>None</pages>
        <date>2001</date>
      </reference>
      <reference>
        <id>28</id>
        <authors>
          <author>Hao Zhang</author>
          <author>Daniel Gildea</author>
          <author>David Chiang</author>
        </authors>
        <title>Extracting synchronous grammar rules from word-level alignments in linear time.</title>
        <publication>In COLING.</publication>
        <pages>None</pages>
        <date>2008</date>
      </reference>
      <reference>
        <id>29</id>
        <authors>
          <author>Bowen Zhou</author>
          <author>Bing Xiang</author>
          <author>Xiaodan Zhu</author>
          <author>Yuqing Gao</author>
        </authors>
        <title>Prior derivation models for formally syntax-based translation using linguistically syntactic parsing and tree kernels.</title>
        <publication>In SSST.</publication>
        <pages>None</pages>
        <date>2008</date>
      </reference>
    </references>
    <citations>
      <citation>
        <id>0</id>
        <reference_id>0</reference_id>
        <string>Brown et al., 1993</string>
        <sentence_id>8584</sentence_id>
        <char_offset>133</char_offset>
      </citation>
      <citation>
        <id>1</id>
        <reference_id>1</reference_id>
        <string>Bui-Xuan et al., 2005</string>
        <sentence_id>8660</sentence_id>
        <char_offset>92</char_offset>
      </citation>
      <citation>
        <id>2</id>
        <reference_id>2</reference_id>
        <string>Chiang (2007)</string>
        <sentence_id>8556</sentence_id>
        <char_offset>66</char_offset>
      </citation>
      <citation>
        <id>3</id>
        <reference_id>2</reference_id>
        <string>Chiang (2007)</string>
        <sentence_id>8599</sentence_id>
        <char_offset>0</char_offset>
      </citation>
      <citation>
        <id>4</id>
        <reference_id>2</reference_id>
        <string>Chiang (2007)</string>
        <sentence_id>8652</sentence_id>
        <char_offset>57</char_offset>
      </citation>
      <citation>
        <id>5</id>
        <reference_id>2</reference_id>
        <string>Chiang (2007)</string>
        <sentence_id>8789</sentence_id>
        <char_offset>84</char_offset>
      </citation>
      <citation>
        <id>6</id>
        <reference_id>2</reference_id>
        <string>Chiang, 2007</string>
        <sentence_id>8551</sentence_id>
        <char_offset>50</char_offset>
      </citation>
      <citation>
        <id>7</id>
        <reference_id>2</reference_id>
        <string>Chiang, 2007</string>
        <sentence_id>8553</sentence_id>
        <char_offset>64</char_offset>
      </citation>
      <citation>
        <id>8</id>
        <reference_id>2</reference_id>
        <string>Chiang, 2007</string>
        <sentence_id>8555</sentence_id>
        <char_offset>47</char_offset>
      </citation>
      <citation>
        <id>9</id>
        <reference_id>2</reference_id>
        <string>Chiang, 2007</string>
        <sentence_id>8578</sentence_id>
        <char_offset>39</char_offset>
      </citation>
      <citation>
        <id>10</id>
        <reference_id>3</reference_id>
        <string>Chiang (2010)</string>
        <sentence_id>8563</sentence_id>
        <char_offset>0</char_offset>
      </citation>
      <citation>
        <id>11</id>
        <reference_id>3</reference_id>
        <string>Chiang (2010)</string>
        <sentence_id>8613</sentence_id>
        <char_offset>0</char_offset>
      </citation>
      <citation>
        <id>12</id>
        <reference_id>4</reference_id>
        <string>Galley et al., 2004</string>
        <sentence_id>8551</sentence_id>
        <char_offset>64</char_offset>
      </citation>
      <citation>
        <id>13</id>
        <reference_id>4</reference_id>
        <string>Galley et al., 2004</string>
        <sentence_id>8554</sentence_id>
        <char_offset>67</char_offset>
      </citation>
      <citation>
        <id>14</id>
        <reference_id>5</reference_id>
        <string>Heber and Stoye (2001)</string>
        <sentence_id>8662</sentence_id>
        <char_offset>35</char_offset>
      </citation>
      <citation>
        <id>15</id>
        <reference_id>6</reference_id>
        <string>Huang and Chiang, 2005</string>
        <sentence_id>8734</sentence_id>
        <char_offset>34</char_offset>
      </citation>
      <citation>
        <id>16</id>
        <reference_id>7</reference_id>
        <string>Huang and Harper, 2009</string>
        <sentence_id>8792</sentence_id>
        <char_offset>94</char_offset>
      </citation>
      <citation>
        <id>17</id>
        <reference_id>8</reference_id>
        <string>Huang et al., 2006</string>
        <sentence_id>8559</sentence_id>
        <char_offset>133</char_offset>
      </citation>
      <citation>
        <id>18</id>
        <reference_id>9</reference_id>
        <string>Huang et al. (2009)</string>
        <sentence_id>8725</sentence_id>
        <char_offset>173</char_offset>
      </citation>
      <citation>
        <id>19</id>
        <reference_id>10</reference_id>
        <string>Huang et al., 2010</string>
        <sentence_id>8792</sentence_id>
        <char_offset>317</char_offset>
      </citation>
      <citation>
        <id>20</id>
        <reference_id>11</reference_id>
        <string>Koehn, 2005</string>
        <sentence_id>8779</sentence_id>
        <char_offset>94</char_offset>
      </citation>
      <citation>
        <id>21</id>
        <reference_id>12</reference_id>
        <string>Liu et al., 2006</string>
        <sentence_id>8551</sentence_id>
        <char_offset>85</char_offset>
      </citation>
      <citation>
        <id>22</id>
        <reference_id>12</reference_id>
        <string>Liu et al., 2006</string>
        <sentence_id>8554</sentence_id>
        <char_offset>88</char_offset>
      </citation>
      <citation>
        <id>23</id>
        <reference_id>12</reference_id>
        <string>Liu et al., 2006</string>
        <sentence_id>8559</sentence_id>
        <char_offset>115</char_offset>
      </citation>
      <citation>
        <id>24</id>
        <reference_id>14</reference_id>
        <string>Marton and Resnik, 2008</string>
        <sentence_id>8818</sentence_id>
        <char_offset>293</char_offset>
      </citation>
      <citation>
        <id>25</id>
        <reference_id>15</reference_id>
        <string>Matsuzaki et al. (2005)</string>
        <sentence_id>8725</sentence_id>
        <char_offset>21</char_offset>
      </citation>
      <citation>
        <id>26</id>
        <reference_id>16</reference_id>
        <string>Mi and Huang, 2008</string>
        <sentence_id>8559</sentence_id>
        <char_offset>13</char_offset>
      </citation>
      <citation>
        <id>27</id>
        <reference_id>16</reference_id>
        <string>Mi and Huang, 2008</string>
        <sentence_id>8559</sentence_id>
        <char_offset>296</char_offset>
      </citation>
      <citation>
        <id>28</id>
        <reference_id>16</reference_id>
        <string>Mi and Huang, 2008</string>
        <sentence_id>8823</sentence_id>
        <char_offset>149</char_offset>
      </citation>
      <citation>
        <id>29</id>
        <reference_id>17</reference_id>
        <string>Mi et al., 2008</string>
        <sentence_id>8559</sentence_id>
        <char_offset>246</char_offset>
      </citation>
      <citation>
        <id>30</id>
        <reference_id>18</reference_id>
        <string>Och and Ney, 2000</string>
        <sentence_id>8584</sentence_id>
        <char_offset>153</char_offset>
      </citation>
      <citation>
        <id>31</id>
        <reference_id>19</reference_id>
        <string>Och and Ney, 2004</string>
        <sentence_id>8551</sentence_id>
        <char_offset>268</char_offset>
      </citation>
      <citation>
        <id>32</id>
        <reference_id>19</reference_id>
        <string>Och and Ney, 2004</string>
        <sentence_id>8587</sentence_id>
        <char_offset>39</char_offset>
      </citation>
      <citation>
        <id>33</id>
        <reference_id>20</reference_id>
        <string>Och, 2003</string>
        <sentence_id>8790</sentence_id>
        <char_offset>85</char_offset>
      </citation>
      <citation>
        <id>34</id>
        <reference_id>21</reference_id>
        <string>Petrov et al. (2006)</string>
        <sentence_id>8725</sentence_id>
        <char_offset>49</char_offset>
      </citation>
      <citation>
        <id>35</id>
        <reference_id>22</reference_id>
        <string>Venugopal et al. (2009)</string>
        <sentence_id>8612</sentence_id>
        <char_offset>0</char_offset>
      </citation>
      <citation>
        <id>36</id>
        <reference_id>23</reference_id>
        <string>Weischedel et al., 2008</string>
        <sentence_id>8792</sentence_id>
        <char_offset>188</char_offset>
      </citation>
      <citation>
        <id>37</id>
        <reference_id>24</reference_id>
        <string>Wu, 1997</string>
        <sentence_id>8555</sentence_id>
        <char_offset>37</char_offset>
      </citation>
      <citation>
        <id>38</id>
        <reference_id>25</reference_id>
        <string>Xiong et al., 2009</string>
        <sentence_id>8818</sentence_id>
        <char_offset>318</char_offset>
      </citation>
      <citation>
        <id>39</id>
        <reference_id>26</reference_id>
        <string>Xiong et al., 2010</string>
        <sentence_id>8818</sentence_id>
        <char_offset>338</char_offset>
      </citation>
      <citation>
        <id>40</id>
        <reference_id>27</reference_id>
        <string>Yamada and Knight, 2001</string>
        <sentence_id>8554</sentence_id>
        <char_offset>42</char_offset>
      </citation>
      <citation>
        <id>41</id>
        <reference_id>28</reference_id>
        <string>Zhang et al., 2008</string>
        <sentence_id>8590</sentence_id>
        <char_offset>77</char_offset>
      </citation>
      <citation>
        <id>42</id>
        <reference_id>28</reference_id>
        <string>Zhang et al. (2008)</string>
        <sentence_id>8660</sentence_id>
        <char_offset>0</char_offset>
      </citation>
      <citation>
        <id>43</id>
        <reference_id>29</reference_id>
        <string>Zhou et al. (2008)</string>
        <sentence_id>8818</sentence_id>
        <char_offset>201</char_offset>
      </citation>
    </citations>
  </content>
</document>
