<PAPER>
  <FILENO/>
  <TITLE>Tree-based Hybrid Machine Translation</TITLE>
  <AUTHORS/>
  <ABSTRACT>
    <A-S ID="S-48501">I present an automatic post-editing approach that combines translation systems which produce syntactic trees as output.</A-S>
    <A-S ID="S-48502">The nodes in the generation tree and targetside SCFG tree are aligned and form the basis for computing structural similarity.</A-S>
    <A-S ID="S-48503">Structural similarity computation aligns subtrees and based on this alignment, subtrees are substituted to create more accurate translations.</A-S>
    <A-S ID="S-48504">Two different techniques have been implemented to compute structural similarity: leaves and tree-edit distance.</A-S>
    <A-S ID="S-48505">I report on the translation quality of a machine translation (MT) system where both techniques are implemented.</A-S>
    <A-S ID="S-48506">The approach shows significant improvement over the baseline for MT systems with limited training data and structural improvement for MT systems trained on Europarl.</A-S>
  </ABSTRACT>
  <BODY>
    <DIV DEPTH="0">
      <HEADER>1 Introduction</HEADER>
      <P>
        <S ID="S-48507">Statistical MT (SMT) and rule-based MT (RBMT) have complimentary strengths and combining their output can improve translation quality.</S>
        <S ID="S-48508">The underlying models in SMT lack linguistic sophistication when compared to RBMT systems and there is a trend towards incorporating more linguistic knowledge by creating hybrid systems that can exploit the linguistic knowledge contained in hand-crafted rules and the knowledge extracted from large amounts of text.</S>
        <S ID="S-48509">Hierarchical phrases (<REF ID="R-04" RPTR="4">Chiang, 2005</REF>) are encoded in a tree structure just as linguistic trees.</S>
        <S ID="S-48510">Most RBMT systems also encode the analysis of a sentence in a tree.</S>
        <S ID="S-48511">The rules generating hierarchical trees are inferred from unlabeled corpora and RBMT systems use hand-crafted rules based in linguistic knowledge.</S>
        <S ID="S-48512">While the trees are generated differently, alignments between nodes and subtrees in the generation phase can be computed.</S>
        <S ID="S-48513">Based on the computed alignments, substitution can be performed between the trees.</S>
      </P>
      <P>
        <S ID="S-48514">The automatic post-editing approach proposed in this paper is based on structural similarity.</S>
        <S ID="S-48515">The tree structures are aligned and subtree substitution based on the similarity of subtrees performed.</S>
        <S ID="S-48516">This knowledge-poor approach is compatible with the surface-near nature of SMT systems, does not require other information than what is available in the output, and ensures that the approach is generic so it can, in principle, be applied to any language pair.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>2 Hybrid Machine Translation</HEADER>
      <P>
        <S ID="S-48563">Hybrid machine translation (HMT) is a paradigm that seeks to combine the strengths of SMT and RBMT.</S>
        <S ID="S-48564">The different approaches have complementary strengths and weaknesses (<REF ID="R-18" RPTR="20">Thurmair, 2009</REF>) which have led to the emergence of HMT as a subfield in machine translation research.</S>
      </P>
      <P>
        <S ID="S-48565">The strength of SMT is robustness - i.e. it will always produce an output - and fluency due to the use of language models.</S>
        <S ID="S-48566">A weakness of SMT is the lack of explicit linguistic knowledge, which make translation phenomena requiring such information, e.g. long-distance dependencies, difficult to handle.</S>
        <S ID="S-48567">RBMT systems translate more accurately in cases without parse failure, since they can take more information into account e.g. morphological, syntactic or semantic information, where SMT only uses surface forms.</S>
        <S ID="S-48568">RBMT often suffer from lack of robustness when parsing fails and 77</S>
      </P>
      <P>
        <S ID="S-48569">Jeg [jeg] 1S NOM @SUBJ #1-&gt;2 arbejder [arbejde] &lt;mv&gt; V PR AKT @FS-STA #2-&gt;0 hjemme [hjemme] &lt;aloc&gt; ADV LOC @&lt;ADVL #3-&gt;2 .</S>
        <S ID="S-48570">[.</S>
        <S ID="S-48571">] PU @PU #4-&gt;0</S>
      </P>
      <P>
        <S ID="S-48572">in lexical selection in transfer.</S>
        <S ID="S-48573">RBMT systems are also very costly to build, and maintenance and development can be very complex e.g. due to the interdependency of rules.</S>
      </P>
      <P>
        <S ID="S-48574">The post-editing approach attempts to incorporate the linguistic knowledge encoded in targetside dependency trees into hierarchical trees produced by an SMT system.</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>2.1 Related work</HEADER>
        <P>
          <S ID="S-48517">System combinations by coupling MT systems serially or in parallel have been attempted before e.g. via hypothesis selection (<REF ID="R-07" RPTR="7">Hildebrand and Vogel, 2008</REF>), by combining translation hypotheses locally using POS tags (<REF ID="R-06" RPTR="6">Federmann et al., 2010</REF>) or by statistical post-editing (SPE) (<REF ID="R-15" RPTR="16">Simard et al., 2007</REF>).</S>
          <S ID="S-48518">In hypothesis selection approaches, a number of MT systems produce translations for an n- best list and use a re-ranking module to rescore the translations.</S>
          <S ID="S-48519">Using this approach, the best improvements are achieved with a large number of systems running in parallel and this is not feasible in a practical application, mostly due to the computational resources required by the component systems.</S>
          <S ID="S-48520">The translations will also not be better than the one produced by the best component system.</S>
          <S ID="S-48521">Tighter integration of rule-based and statistical approaches have also been proposed: Adding probabilities to parse trees, pre-translation word reordering, enriching the phrase table with output phrases from a rule-based system (Eisele et al., Figure 2: Disambiguated CG representation for I work at home.</S>
          <S ID="S-48522">Dependency annotation is indicated by the #-character.</S>
        </P>
        <P>
          <S ID="S-48523">2008), creating training data from RBMT systems etc.</S>
          <S ID="S-48524">The factored translation models also present a way to integrate rule-based parsing systems.</S>
        </P>
        <P>
          <S ID="S-48525">The automatic post-editing approach proposed here does not exactly fit the classification of parallel coupling approaches in <REF ID="R-18" RPTR="19">Thurmair (2009)</REF>.</S>
          <S ID="S-48526">Other coupling architectures with post-editing work on words or phrases and generate confusion networks or add more information to identify substitution candidates, while the units focused on here are graphs and no additional information is added to the MT output.</S>
          <S ID="S-48527">This approach does select a skeleton upon which transformations are conducted as in <REF ID="R-13" RPTR="13">Rosti et al. (2007)</REF> and requires the RBMT system to generate a target side language analysis which must be available to the post-editing systems, but does not require a new syntactic analysis of noisy MT output.</S>
          <S ID="S-48528">The architecture of the hybrid system used in this paper is parallel coupling with post-editing.</S>
          <S ID="S-48529">A diagram of the implemented systems can be seen in Figure 1.</S>
          <S ID="S-48530">The dark grey boxes represent pre-existing modules and open source software and the light grey boxes represent the additional modules developed to implement the post-editing approach.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>2.2 RBMT Component</HEADER>
        <P>
          <S ID="S-48531">The Danish to English translation engine in GramTrans (<REF ID="R-01" RPTR="1">Bick, 2007</REF>) is called through an API.</S>
          <S ID="S-48532">The output is a constraint grammar (CG) analysis on the target language side after all transfer and target side transformation rules have been applied.</S>
          <S ID="S-48533">Example output is shown in Figure 2.</S>
          <S ID="S-48534">In the analysis, dependency information is provided and they form the basis for creating the tree used for structural similarity computation.</S>
          <S ID="S-48535">Part-of-speech tags, source and target surface structure, sentence position and dependency information are extracted from the CG analysis.</S>
        </P>
        <P>
          <S ID="S-48536">GramTrans is created to be robust and produce as many dependency markings as possible to be used in later translation stages.</S>
          <S ID="S-48537">Errors in the assignment of functional tags propagate to the dependency level and can result in markings that will produce a dependency tree and a number of 78</S>
        </P>
        <P>
          <S ID="S-48538">unconnected subgraphs with circularities.</S>
          <S ID="S-48539">This presents a problem if the dependency markings are the basis for creating a dependency tree because it is not straight-forward to reattach a subgraph correctly, when the grammatical tags cannot be relied upon.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>2.3 SMT Component</HEADER>
        <P>
          <S ID="S-48540">A CKY+ algorithm for chart decoding is implemented in Moses (<REF ID="R-09" RPTR="9">Koehn et al., 2007</REF>) for treebased models and is used as the SMT component system in this paper.</S>
        </P>
        <P>
          <S ID="S-48541">Hierarchical phrases are phrases that can contain subphrases, i.e. a hierarchical phrase contains non-terminal symbols.</S>
          <S ID="S-48542">An example rule from Danish to English:</S>
        </P>
        <P>
          <S ID="S-48543">X 1 i &#248;vrigt X 2 &#8722;&#8594; moreover, X 1 X 2</S>
        </P>
        <P>
          <S ID="S-48544">X n is a nonterminal and the subscript identifies how the nonterminals are aligned.</S>
          <S ID="S-48545">The hierarchical phrases are learned from bitext with unannotated data and are formally productions from a synchronous context-free grammar (SCFG) and can be viewed as a move towards syntax-based SMT (<REF ID="R-04" RPTR="5">Chiang, 2005</REF>).</S>
          <S ID="S-48546">Since hierarchical phrases are not linguistic, Chiang makes a distinction between linguistically syntax-based MT and formally syntax-based MT where hierarchical models fall in the latter category because the structures they are defined over are not linguistically informed, i.e. unannotated bitexts.</S>
        </P>
        <P>
          <S ID="S-48547">A hierarchical model is based on a SCFG and the elementary structures are rewrite rules:</S>
        </P>
        <P>
          <S ID="S-48548">X &#8722;&#8594; &#12296;&#947;, &#945;, &#8764;&#12297;</S>
        </P>
        <P>
          <S ID="S-48549">As above, X is a nonterminal, &#947; and &#945; are both strings of terminals and nonterminals and &#8764; is a 1-to-1 correspondence between nonterminals in &#947; and &#945;.</S>
          <S ID="S-48550">As in shown previously, the convention is to use subscripts to represent &#8764;.</S>
        </P>
        <P>
          <S ID="S-48551">To maintain the advantage of the phrase-based approach, glue rules are added to the rules that are otherwise learned from raw data:</S>
        </P>
        <P>
          <S ID="S-48552">S &#8722;&#8594; &#12296;S 1 X 2 , S 1 X 2 &#12297;</S>
        </P>
        <P>
          <S ID="S-48553">S &#8722;&#8594; &#12296;X 1 , X 1 &#12297;</S>
        </P>
        <P>
          <S ID="S-48554">Only these rewrite rules contain the nonterminal S.</S>
          <S ID="S-48555">These rules are added to give the model</S>
        </P>
        <P>
          <S ID="S-48556">the option of combining partial hypotheses serially and they make the hierarchical model as robust as the traditional phrase-based approaches.</S>
        </P>
        <P>
          <S ID="S-48557">The Moses chart decoder was modified to output trace information from which the n-best hierarchical trees can be reconstructed.</S>
          <S ID="S-48558">The trace information contains the derivations which produce the translation hypotheses.</S>
          <S ID="S-48559">The sentence&#8211;aligned Danish-English part of Europarl (<REF ID="R-10" RPTR="10">Koehn, 2005</REF>) was used for training, and to tune parameters with MERT, the test set from the NAACL WMT 2006 was used (<REF ID="R-08" RPTR="8">Koehn and Monz, 2006</REF>).</S>
          <S ID="S-48560">GIZA++ aligns hierarchical phrases which were extracted by Moses to train a translation model and a language model was trained with SRILM (<REF ID="R-17" RPTR="18">Stolcke, 2002</REF>).</S>
          <S ID="S-48561">Moses was trained using the Experimental Management System (EMS) (<REF ID="R-11" RPTR="11">Koehn, 2010</REF>) and the configuration followed the standard guidelines in the syntax tutorial.</S>
          <S ID="S-48562">1 To train SRILM, the English side of Europarl was used.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>3 Matching Approach</HEADER>
      <P>
        <S ID="S-48658">The post-editing approach relies on structures output by the component systems.</S>
        <S ID="S-48659">It is necessary to find similar structures to perform subtree substitution.</S>
        <S ID="S-48660">Matching structures is a problem in several application areas such as semantic web, schema and ontology integration, query mediation etc. Structures include database schemas, directories, diagrams and graphs.</S>
        <S ID="S-48661"><REF ID="R-14" RPTR="15">Shvaiko and Euzenat (2005)</REF> provide a comprehensive survey of matching techniques.</S>
        <S ID="S-48662">The matching operation determines an alignment between two structures and an alignment is a set of matching elements.</S>
        <S ID="S-48663">A matching element is a quintuple: &#12296;id, e, e &#8242; , n, R&#12297;:</S>
      </P>
      <P>
        <S ID="S-48664">id Unique id.</S>
      </P>
      <P>
        <S ID="S-48665">e, e &#8242; Elements from different structures.</S>
      </P>
      <P>
        <S ID="S-48666">n Confidence measure.</S>
        <S ID="S-48667">1 http://www.statmt.org/moses/?n=Moses.</S>
      </P>
      <P>
        <S ID="S-48668">SyntaxTutorial</S>
      </P>
      <P>
        <S ID="S-48669">S</S>
      </P>
      <P>
        <S ID="S-48670">sat S X</S>
      </P>
      <P>
        <S ID="S-48671">the the</S>
      </P>
      <P>
        <S ID="S-48672">X</S>
      </P>
      <P>
        <S ID="S-48673">cat</S>
      </P>
      <P>
        <S ID="S-48674">R The relation holding between the elements.</S>
      </P>
      <P>
        <S ID="S-48675">The resources that can be used in the matching process are shown in Figure 3. o and o &#8242; are the structures to be matched, A is an optional existing alignment, r is external resources, p is parameters, weights and thresholds and A &#8242; is the set of matching elements created by the process.</S>
        <S ID="S-48676">In this paper, only matching elements with an equivalence relation (=) are used.</S>
      </P>
      <P>
        <S ID="S-48677">The returned alignment can be a new alignment or a refinement of A. o will be a dependency tree and o &#8242; the hierachical trees from the SMT component system.</S>
        <S ID="S-48678">To compute the initial alignment A between hierarchical and dependency trees, the source to target language phrase alignment output by the component systems is used.</S>
        <S ID="S-48679">So the initial alignment between leaf nodes in target-side trees are computed over the alignment to the source language.</S>
      </P>
      <P>
        <S ID="S-48680">An important decision regarding this hybrid approach is how to compute the alignment and the size of the substituted subtrees.</S>
        <S ID="S-48681">Irrespective of which technique is chosen to compute structural similarity, the resulting alignment should be refined to contain matching elements between internal nodes as shown in Figure 4.</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>3.1 Alignment Challenges</HEADER>
        <P>
          <S ID="S-48575">The change made to the chart decoder to output the n-best trace information is simple and does not output the alignment information.</S>
          <S ID="S-48576">Currently, the tree extraction module computes an alignment between the source and target language phrases.</S>
          <S ID="S-48577">The segmentation of words into phrases done by Moses does not always correspond to the word-based segmentation required by the CG parser; phrases recognised by the CG parser rarely correspond to phrases in Moses and the hierarchical phrase alignment is not easy to handle.</S>
        </P>
        <P>
          <S ID="S-48578">Aligning hierarchical phrases like (a) in Figure 5 is not complicated.</S>
          <S ID="S-48579">The ordering is identical and the Danish word offentligg&#248;res is aligned to will be published.</S>
          <S ID="S-48580">The numbers 1-3 refer to the alignment of non-terminal nodes based on phrase positions.</S>
        </P>
        <P>
          <S ID="S-48581">It is more complicated to align (b) in Figure 5.</S>
          <S ID="S-48582">There are two methods of handling this type of alignment appropriate for the component systems.</S>
          <S ID="S-48583">Because there are an equal number of tokens in the English phrase and Danish phrase, aligning the tokens 1-1 monotonically would be a solution that, in this case, results in a correct alignment.</S>
        </P>
        <P>
          <S ID="S-48584">Another approach relies on weak word reordering between Danish and English and would align findes with there are.</S>
          <S ID="S-48585">This reduces the alignment problem to aligning vi der with we.</S>
          <S ID="S-48586">In this case, the alignment is noisy, but usable for creating matching elements.</S>
          <S ID="S-48587">Both approaches are implemented in the hybrid system and the first approach supercedes the second due to the advantage of correlating with the CG approach.</S>
        </P>
        <P>
          <S ID="S-48588">An initial element-level alignment between nodes in a dependency tree and a hierarchical tree is computed over the source language and creates a set of matching elements containing aligned nodes.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.2 Alignment Refinement</HEADER>
        <P>
          <S ID="S-48589">Between a dependency and an hierarchical tree, an element-level alignment needs to be refined to 80</S>
        </P>
        <P>
          <S ID="S-48590">(a) offentligg&#248;res X : X -&gt; will be published X : 1-3</S>
        </P>
        <P>
          <S ID="S-48591">(b) vi X der X findes : X -&gt; X, we X there are : 1-3 3-0</S>
        </P>
        <P>
          <S ID="S-48592">a structure-level alignment similar to the one in Figure 4.</S>
          <S ID="S-48593">Not all matching elements in an initial alignment should be refined e.g. if both nodes in a matching element are leaf nodes, no refinement is needed.</S>
          <S ID="S-48594">Criteria for selecting initial matching elements for refinement are needed.</S>
        </P>
        <P>
          <S ID="S-48595">In the RBMT output, there are no indications of where the parser encountered problems.</S>
          <S ID="S-48596">If a surface form is an out-of-vocabulary (OOV) word, the morphological analyser is used to assign a lexical category based on the word form, hypothesise additional tags based on the analysis and proceed with parsing.</S>
          <S ID="S-48597">In the SMT output, an OOV marker is appended to a surface form to indicate that the word has not been translated.</S>
          <S ID="S-48598">The marker gives an indication of where enriching a hierarchical tree with RBMT output can result in improvement of translation quality.</S>
        </P>
        <P>
          <S ID="S-48599">Based on these observations, hierarchical trees are chosen to function as skeletons.</S>
          <S ID="S-48600">Substituting dependency subtrees into a hierarchical tree is more straightforward than using dependency trees as skeletons.</S>
          <S ID="S-48601">It was not possible to identify head-dependent relations based solely on the information contained in hierarchical subtrees while removing subtrees from hierarchical trees and inserting dependency subtrees does not destroy linguistic information in the tree and dependency subtrees can easily be transformed into a hierarchical-style subtree.</S>
        </P>
        <P>
          <S ID="S-48602">Leaves Based on the OOV marker, a matching technique based on leaf nodes is implemented to refine matching elements and based on this alignment, substitute hierarchical subtrees with dependency subtrees.</S>
        </P>
        <P>
          <S ID="S-48603">The dependency subtree is identified by collecting all descendants of a node.</S>
          <S ID="S-48604">The descendants are handled as leaf nodes because both leaf and nonterminal nodes contain surface forms in a dependecy tree.</S>
        </P>
        <P>
          <S ID="S-48605">The dependency trees provided by GramTrans are not always projective.</S>
          <S ID="S-48606">Subtrees may not represent a continuous surface structure and a continuous subtree must be isolated before an alignment between subtrees can be found because the hierarchical trees resemble phrase structure trees and discontinuous phrases are handled using glue rules.</S>
        </P>
        <P>
          <S ID="S-48607">To identify the corresponding subtree in the hierarchical tree, the matching elements that contain the nodes in the dependency subtree are collected and a path from each leaf node to the root node is computed.</S>
          <S ID="S-48608">The intersection of nodes is retrieved and the root node of the subtree identified as the lowest node present in all paths.</S>
          <S ID="S-48609">It is not always possible to find a common root node besides the root node of the entire tree.</S>
          <S ID="S-48610">To prevent the loss of a high amount of structural information, the root node cannot be replaced or deleted.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.3 Substitution based on an edit script</HEADER>
        <P>
          <S ID="S-48611">An algorithm for computing structural similarity is the Tree Edit Distance (TED) algorithm, which computes how many operations are necessary for transforming one tree into another tree.</S>
          <S ID="S-48612">Following Zhang and Shasha (1989) and <REF ID="R-02" RPTR="2">Bille (2005)</REF>, the operations are defined on nodes and the trees are ordered, labelled trees.</S>
          <S ID="S-48613">There are 3 different edit operations:</S>
        </P>
        <P>
          <S ID="S-48614">rename Change the label of a node in a tree.</S>
        </P>
        <P>
          <S ID="S-48615">delete Remove a node n from a tree.</S>
          <S ID="S-48616">Insert the children of n as children of the parent of n so the sequence of children are preserved.</S>
          <S ID="S-48617">The deleted node may not be the root node.</S>
        </P>
        <P>
          <S ID="S-48618">insert Insert a node as the child of a node n in a tree.</S>
          <S ID="S-48619">A subsequence of children of n are inserted as children of the new node so the sequence of children are preserved.</S>
          <S ID="S-48620">An insertion is the inverse operation of a deletion.</S>
        </P>
        <P>
          <S ID="S-48621">A cost function is defined for each operation.</S>
          <S ID="S-48622">The goal is to find the sequence of edit operations that turns a tree T 1 into another tree T 2 with minimum cost.</S>
          <S ID="S-48623">The sequence of edit operations is called an edit script and the cost of the optimal edit script is the tree edit distance.</S>
        </P>
        <P>
          <S ID="S-48624">The cost functions should return a distance metric and satisfy the following conditions:</S>
        </P>
        <P>
          <S ID="S-48625">1. &#947;(i &#8594; j) &#8805; 0 and &#947;(i &#8594; i) = 0 81</S>
        </P>
        <P>
          <S ID="S-48626">2. &#947;(i &#8594; j) = &#947;(j &#8594; i)</S>
        </P>
        <P>
          <S ID="S-48627">3. &#947;(i &#8594; k) &#8804; &#947;(i &#8594; j) + &#947;(j &#8594; k)</S>
        </P>
        <P>
          <S ID="S-48628">&#947; is the cost of an edit operation.</S>
          <S ID="S-48629">The edit distance mapping is a representation of an edit script.</S>
          <S ID="S-48630">A rename operation is represented as (i 1 &#8594; j 2 ) where the subscript denotes that the nodes i and j belong to different trees.</S>
          <S ID="S-48631">(i 1 &#8594; &#603;) represents a deletion and (&#603; &#8594; j 2 ) an insertion.</S>
        </P>
        <P>
          <S ID="S-48632">The cost of an edit distance mapping is given by:</S>
        </P>
        <P>
          <S ID="S-48633">&#947;(M) = &#8721; &#947;(i &#8594; j)+ &#8721; &#947;(i &#8594; &#603;)+ &#8721; &#947;(&#603; &#8594; j)</S>
        </P>
        <P>
          <S ID="S-48634">i&#8712;T 1 j&#8712;T 2 (i,j)&#8712;M</S>
        </P>
        <P>
          <S ID="S-48635">j &#8712; T 2 means j is in the set of nodes in T 2 .</S>
        </P>
        <P>
          <S ID="S-48636">It is important to note that the trees are ordered trees.</S>
          <S ID="S-48637">The unordered version of the tree edit distance problem is NP-hard, while polynomial algorithms based on dynamic programming exist for ordered trees.</S>
        </P>
        <P>
          <S ID="S-48638">The algorithm does not require an input alignment or external resources.</S>
          <S ID="S-48639">The cost functions for deletion, insertion and renaming must be defined on the information present in the nodes and a unique id must be assigned to the nodes.</S>
          <S ID="S-48640">This id is assigned by traversing the tree depth-first and assigning an integer as id.</S>
          <S ID="S-48641">The algorithm visits each node in the trees in post order and determines based on the cost assigned by the cost functions, which edit operation should be performed.</S>
        </P>
        <P>
          <S ID="S-48642">To generate matching elements that align dependency nodes to nonterminal hierarchical nodes, cost functions for edit operations are modified to assign a lower cost to rename operations where one of the nodes is a hierarchical nonterminal node.</S>
          <S ID="S-48643">If two nodes have the same target and source phrase, a rename operation does not incur any cost and neither does the renaming of untranslated phrases.</S>
          <S ID="S-48644">This ensures that matching elements from the initial alignment that does not require refinement are not altered.</S>
          <S ID="S-48645">Also, if the source is the same and the difference in sentence position is no more than five, the renaming cost is reduced.</S>
          <S ID="S-48646">Experiments showed that a window of five words was necessary to account for differences in sentence position and prevent alignment to nodes later in the sentence with the same source phrase.</S>
        </P>
        <P>
          <S ID="S-48647">This technique is independent of the OOV marker and creates a structure-level alignment.</S>
          <S ID="S-48648">The substitutions performed can be of very high quality but some untranslated words might not be handled.</S>
          <S ID="S-48649">If the system finds any OOV words in the hierachical tree after substitution, a rename operation is carried out on the node.</S>
        </P>
        <P>
          <S ID="S-48650">The extracted matching elements are noisy because they rely on the noisy source to target language alignment and the RBMT engine can also produce an inaccurate translation making the substitution counter-productive.</S>
          <S ID="S-48651">Further limitations on the cost functions become too restrictive and produce too few matching elements.</S>
          <S ID="S-48652">To avoid some of the noise, all permutations of applying substitutions based on the edit script are generated, re-ranked and the highest scoring hypothesis chosen as the translation.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.4 Generation</HEADER>
        <P>
          <S ID="S-48653">To ensure that the surface string generated from the newly created tree will have the correct word ordering, the dependency subtree is transformed before being inserted into the hierarchical tree.</S>
          <S ID="S-48654">To create the insertion tree, the dependency nodes are inserted as leaf nodes of a dummy node.</S>
          <S ID="S-48655">The dummy node is inserted before the root node of the aligned hierarchical subtree and the information on the root node copied to the new node.</S>
          <S ID="S-48656">Subsequently, the hierarchical nodes are removed from the tree.</S>
          <S ID="S-48657">If both nodes in a matching element are leaf nodes, the hierarchical node is relabeled with information from the dependency node.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>4 Experiments</HEADER>
      <P>
        <S ID="S-48729">The experiments have been conducted between Danish and English.</S>
        <S ID="S-48730">The language model trained with EMS is used to re-rank translation alternatives.</S>
        <S ID="S-48731">BLEU (<REF ID="R-12" RPTR="12">Papineni et al., 2002</REF>), TER (<REF ID="R-16" RPTR="17">Snover et al., 2006</REF>) and METEOR (<REF ID="R-00" RPTR="0">Banerjee and Lavie, 2005</REF>) scores will be reported.</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>4.1 Experimental Setup</HEADER>
        <P>
          <S ID="S-48682">Two sets of five experiments have been conducted.</S>
          <S ID="S-48683">The first set of experiments use the initial 100,000 lines from Europarl for training Moses and the second set of experiments use the full Europarl corpus of ca.</S>
          <S ID="S-48684">1.8 mio sentences.</S>
          <S ID="S-48685">The SMT baseline is the hierarchical version of Moses.</S>
        </P>
        <P>
          <S ID="S-48686">TED Skeleton Selection The impact of choosing the translation hypothesis with a minimal edit 82</S>
        </P>
        <P>
          <S ID="S-48687">distance to the dependency tree from the rulebased system is investigated.</S>
          <S ID="S-48688">In one setting, the cost functions adhere to the constrictions of computing a distance metric.</S>
          <S ID="S-48689">Two settings test the impact of biasing the insertion and deletion cost functions to assign a lower cost to inserting/deleting nonterminals, i.e. turning the dependency tree into the hierarchical tree and vice versa.</S>
        </P>
        <P>
          <S ID="S-48690">TED is computed for 20 translation hypotheses and the best performing setting reported.</S>
        </P>
        <P>
          <S ID="S-48691">Leaves An experiment using the leaves technique has been conducted.</S>
          <S ID="S-48692">The experiment is performed using the best hypothesis from Moses and also using TED to chose the most structurally similar skeleton.</S>
          <S ID="S-48693">The best setting will be reported.</S>
        </P>
        <P>
          <S ID="S-48694">Lexical substitution To be able to compare a more naive approach, subtree substitution based on the initial element-level alignment between leaf nodes is used.</S>
          <S ID="S-48695">In this approach, a subtree is one node.</S>
          <S ID="S-48696">The technique is identical to using the RBMT lexicon to lookup untranslated words and inserting them in the translation.</S>
        </P>
        <P>
          <S ID="S-48697">TED-R An experiment where the mappings that represent a rename operation, which are produced during TED computation, are extracted and used as matching elements is conducted.</S>
          <S ID="S-48698">Mapping elements containing only punctuation or the root node of either tree are discarded.</S>
          <S ID="S-48699">All combinations of substitutions based on the extracted matching elements are performed and the highest ranking hypothesis according to a language model is chosen as the final translation.</S>
          <S ID="S-48700">The extracted matching elements may not incorporate all the untranslated nodes.</S>
          <S ID="S-48701">All untranslated nodes are subsequently translated using lexical substitution as mentioned above.</S>
          <S ID="S-48702">The subtrees inserted into the hierarchical tree will undergo the same transformation as the subtrees inserted using the leaves technique.</S>
        </P>
        <P>
          <S ID="S-48703">This experiment is evaluated using both the 1- best hierarchical tree as skeleton and choosing the skeleton using TED.</S>
          <S ID="S-48704">All three settings are tested and the best performing experiment reported.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>4.2 Evaluation</HEADER>
        <P>
          <S ID="S-48705">The results of the automatic evaluation can be seen in Table 1.</S>
          <S ID="S-48706">Skeleton indicates that TED was used to pick the hierarchical tree.</S>
          <S ID="S-48707">The best evaluations are in bold.</S>
        </P>
        <P>
          <S ID="S-48708">100k The RBMT baseline is outperformed by all hybrid configurations, though it does have a higher METEOR score than the SMT baseline and skeleton selection.</S>
          <S ID="S-48709">Lexical substitution and TED-R obtains an increase of ca.</S>
          <S ID="S-48710">2.5 BLEU, 4 TER and 4 METEOR points over the best baseline scores.</S>
          <S ID="S-48711">The leaves technique decreases the metrics except for METEOR and the skeleton selection only shows an insignificant improvement.</S>
        </P>
        <P>
          <S ID="S-48712">Europarl Only lexical substitution improve all metrics over the baseline.</S>
          <S ID="S-48713">Using the leaves technique again results in a decrease in BLEU and TER, but improves METEOR.</S>
          <S ID="S-48714">The impact of skeleton selection is similar to previous experiments, but the use of skeleton selection in TED-R has become larger.</S>
        </P>
        <P>
          <S ID="S-48715">Manual Evaluation The evaluators rank 20 sentences randomly extracted from the test set on a scale from 1-5 with 5 being the best and it is possible to assign the same score to multiple translation alternatives.</S>
          <S ID="S-48716">This evaluation was inspired by the sentence ranking evaluation in <REF ID="R-03" RPTR="3">Callison-Burch et al. (2007)</REF>.</S>
          <S ID="S-48717">The five sentences to be evaluated will come from the RBMT and SMT baselines, lexical substitution, leaves technique and TED- R skeleton and the evaluators are 5 Danes who have studied translation with English as second language and 3 native English speakers.</S>
        </P>
        <P>
          <S ID="S-48718">The baseline systems make up 85% of the lowest ranking.</S>
          <S ID="S-48719">The distribution between systems is more even for the second lowest ranking with the baselines only accounting for 52.6%.</S>
          <S ID="S-48720">In the middle ranking, the top scorer is lexical substitution 83</S>
        </P>
        <P>
          <S ID="S-48721">System 1 2 3 4 5 Avg.</S>
          <S ID="S-48722">rank</S>
        </P>
        <P>
          <S ID="S-48723">with a small margin to the RBMT baseline and the leaves technique.</S>
          <S ID="S-48724">The many assignments of rank 3 could indicate that many of the translations produced can be used for gisting, i.e. get an impression of what information the source text conveys, but not enough to give a complete understanding, but can also be a result of being the middle value and chosen when the evaluators are in doubt.</S>
          <S ID="S-48725">Lexical substitution is also the top scorer in the second-best ranking, followed closely by the other hybrid configurations and the hybrid systems account for 80.3% of the second-best rankings.</S>
          <S ID="S-48726">TED-R recieves more top rankings than the other systems combined (55.3%).</S>
          <S ID="S-48727">The RBMT baseline achieves second-most top-rankings.</S>
          <S ID="S-48728">This can be attributed to the cases where the rules did not encounter unknown words and created very accurate translations, as is the hallmark of RBMT.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>5 Discussion</HEADER>
      <P>
        <S ID="S-48732">It is not surprising that lexical substitution achieves a significant increase in all metrics.</S>
        <S ID="S-48733">The approach only translates untranslated words using the RBMT lexicon.</S>
        <S ID="S-48734">This can improve the translation or, because of noisy matching elements, introduce wrong words but the penalty incurred for untranslated words and wrongly translated words is the same if the number of tokens is similar.</S>
        <S ID="S-48735">Further, lexical substitution does not rely on structural similarity and can avoid the potential sources of errors encountered at a later processing stage.</S>
      </P>
      <P>
        <S ID="S-48736">Skeleton selection has little impact on the metrics and distinct derivations can result in the same surface structure, giving the same scores, but it is evident that finding the most similar tree improves substitution.</S>
      </P>
      <P>
        <S ID="S-48737">The improvements observed in the 100k experiments are not evident in the metrics when the full Europarl data is used.</S>
        <S ID="S-48738">The more powerful SMT system is able to handle more translations but manual evaluation reveals a distribution where the majority of rankings for the baseline systems SMT ( COM ( 1999 ) 493 - C5-0320 baseline / 1999 - 1999 / 2208 ( COS ) ) Leaves ( came ( 1999 ) 493 - C5-0320/1999-1999/2208 ( COM COS ) ) - C5-0320 / 1999 - 1999 / 2208 ( TED-R ( COM ( 1999 ) 493 -</S>
      </P>
      <P>
        <S ID="S-48739">C5-0320/1999-1999/2208 / 1999 - 1999 / 2208 ( COS ) )</S>
      </P>
      <P>
        <S ID="S-48740">are in the lower half and rankings for the hybrid systems tend more towards the mid-to-upper rankings, with TED-R having more distribution around the second-best and highest score.</S>
        <S ID="S-48741">This indicates that the approach creates more accurate translations.</S>
      </P>
      <P>
        <S ID="S-48742">The leaves technique consistently underperforms lexical substitution, but manual evaluation shows a high correlation between the two methods and their average ranks are similar.</S>
        <S ID="S-48743">TED-R is ranked higher than the leaves technique in the metrics and manual evaluation also ranks TED- R higher than lexical substitution.</S>
        <S ID="S-48744">This suggests that the extra surface structure removed is not present in the reference translation and that TED- R is a better implementation of the post-editing approach.</S>
        <S ID="S-48745">Subtree substitution, whether using leaves or TED, does not handle parentheses, hyphens and numbers well.</S>
        <S ID="S-48746">The structure severely degrades when performing substitution near these environments.</S>
        <S ID="S-48747">The example in Table 3 shows the errors made by the substitution algorithm.</S>
        <S ID="S-48748">An entire subphrase is duplicated using the leaves technique which introduces an opening parenthesis with no closing counterpart and includes the erroneous translation came, while TED-R duplicates / 1999 - 1999 / 2208.</S>
      </P>
      <P>
        <S ID="S-48749">The reason for these wayward substitutions can be found in the dependency tree.</S>
        <S ID="S-48750">The matching parentheses are not part of the same subtree and this is the root cause of the problem.</S>
        <S ID="S-48751">The leaves technique is very sensitive to these errors and there is no easy way to prevent spurious parentheses from being introduced.</S>
        <S ID="S-48752">Re-ranking in TED- R could filter these hypotheses out, but because the re-ranking module cannot model this dependency, the sentences with these errors are not always discarded.</S>
        <S ID="S-48753">In the manual evaluation campaign, the sentence from Table 3 was included in the sample sentences.</S>
        <S ID="S-48754">It would seem that the many evaluators did not view this error as impor- 84</S>
      </P>
      <P>
        <S ID="S-48755">tant or it was ignored.</S>
        <S ID="S-48756">It would be impossible to find the referenced Council decision based on the translations and dates or monetary amounts might change drastically, which would not be acceptable if the translated text should be ready for publishing after translation.</S>
        <S ID="S-48757">For gisting, where the user knows that the translation is not perfect, this may constitute less of a problem.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>6 Future work</HEADER>
      <P>
        <S ID="S-48769">The initial alignment is based on the source to target language alignment.</S>
        <S ID="S-48770">In the RBMT module, it is mostly word-based while in Moses, the alignment must be recomputed due to the simplicity of the modification and that the Moses chart decoder cannot output word alignment.</S>
        <S ID="S-48771">The modelling only handles alignment crossing one nonterminal and reduces alignment problems to these cases by assuming a weak reordering.</S>
      </P>
      <P>
        <S ID="S-48772">Future work should include extracting the word alignment from the SMT system to improve source to target language alignment.</S>
        <S ID="S-48773">The MT decoder Joshua can output complete derivations including word-based alignment which would eliminate the need to recompute source to target language alignment which currently produces noisy matching elements.</S>
        <S ID="S-48774">Experiments using a different RBMT engine should also be conducted.</S>
        <S ID="S-48775">The RBMT module does not always produce one complete tree structure for a sentence and the reattachment algorithm handles this by adding any additional graphs to the root node of the tree structure.</S>
        <S ID="S-48776">A RBMT engine that produces complete derivations is likely to improve the translation quality.</S>
        <S ID="S-48777">This will require different tree extraction modules for Joshua and the RBMT engine, but otherwise the system can be reused as is.</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>6.1 Languages and formalisms</HEADER>
        <P>
          <S ID="S-48758">The chosen languages are closely related Germanic languages.</S>
          <S ID="S-48759">While the results seem promising, the applicability of the approach should be tested on a more distant language pair, e.g. Chinese-English or Russian-English if you wish to preserve the possibility of using METEOR for evaluation, but any distant pair for which an RBMT system exists can be used &#8212; provided a tree output is available.</S>
        </P>
        <P>
          <S ID="S-48760">The implementation substitutes dependency subtrees into a hierarchical CFG-style tree.</S>
          <S ID="S-48761">A second test of the hybridisation approach is to combine systems where the structures are not as diverse.</S>
          <S ID="S-48762">Hierarchical systems are derived from a SCFG so a RBMT system based on a CFG formalism such as LUCY, could be used to test the generality of the hybridisation approach.</S>
        </P>
        <P>
          <S ID="S-48763">As the TED-R approach does not rely on markers for OOV words, an implementation where hierarchical subtrees are inserted into the RBMT output should also be conducted.</S>
          <S ID="S-48764">The problem of inserting CFG-style subtrees into a dependency tree and generating the correct surface structure must be resolved or a different RBMT system which produce CFG-style trees implemented.</S>
        </P>
        <P>
          <S ID="S-48765">The implementation of the leaves technique relies on the diversity of the tree structures, i.e. that there are element-level similarities between hierarchical leaf nodes and both terminal and nonterminal dependency nodes and that the subtree rooted in a dependency node can be aligned to a hierarchical subtree.</S>
          <S ID="S-48766">The refinement method would have to be altered.</S>
          <S ID="S-48767">The relations and children techniques (<REF ID="R-14" RPTR="14">Shvaiko and Euzenat, 2005</REF>) are good candidates for similar tree structures.</S>
        </P>
        <P>
          <S ID="S-48768">A change of formalism would not require alterations of the tree edit distance approach, as long as the structures are in fact tree structures.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>7 Conclusion</HEADER>
      <P>
        <S ID="S-48778">The post-editing approach proposed in this paper combines the strengths of statistical and rulebased machine translation and improve translation quality, especially for the least accurate translations.</S>
        <S ID="S-48779">The structural and knowledge-poor approach is novel and has not been attempted before.</S>
        <S ID="S-48780">It exploits structural output to create hybrid translations and uses the linguistic knowledge encoded in structure and on nodes to improve the translation candidates of hierarchical phrase-based MT systems.</S>
        <S ID="S-48781">Automatic evaluation shows a significant increase over the baselines when training data is limited and also improvement in TER and ME- TEOR for lexical substitution and TED-R with a SMT system trained on the Europarl corpus.</S>
        <S ID="S-48782">Manual evaluation on test data shows that hybrid translations were generally ranked higher, indicating that the hybrid approach produces more accurate translations.</S>
      </P>
    </DIV>
  </BODY>
  <ACKNOWLEDGMENTS/>
  <REFERENCES>
    <REFERENCE ID="0">
      <RAUTHOR>S Banerjee</RAUTHOR>
      <REFTITLE>METEOR: An automatic metric for MT evaluation with improved correlation with human judgments. Intrinsic and Extrinsic Evaluation Measures for Machine Translation and/or Summarization,</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="1">
      <RAUTHOR>E Bick</RAUTHOR>
      <REFTITLE>Dan2eng: Wide-coverage danishenglish machine translation.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="2">
      <RAUTHOR>P Bille</RAUTHOR>
      <REFTITLE>A survey on tree edit distance and related problems. Theoretical computer science,</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="3">
      <RAUTHOR>C Callison-Burch</RAUTHOR>
      <REFTITLE>(Meta-) evaluation of machine translation.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="4">
      <RAUTHOR>D Chiang</RAUTHOR>
      <REFTITLE>A hierarchical phrase-based model for statistical machine translation.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="5">
      <RAUTHOR>A Eisele</RAUTHOR>
      <REFTITLE>Hybrid machine translation architectures within and beyond the EuroMatrix project.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="6">
      <RAUTHOR>C Federmann</RAUTHOR>
      <REFTITLE>Further experiments with shallow hybrid mt systems.</REFTITLE>
      <DATE>2010</DATE>
    </REFERENCE>
    <REFERENCE ID="7">
      <RAUTHOR>A S Hildebrand</RAUTHOR>
      <REFTITLE>Combination of machine translation systems via hypothesis selection from combined n-best lists.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="8">
      <RAUTHOR>P Koehn</RAUTHOR>
      <REFTITLE>Manual and automatic evaluation of machine translation between european languages.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="9">
      <RAUTHOR>P Koehn</RAUTHOR>
      <REFTITLE>Moses: Open source toolkit for statistical machine translation.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="10">
      <RAUTHOR>P Koehn</RAUTHOR>
      <REFTITLE>Europarl: A parallel corpus for statistical machine translation.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="11">
      <RAUTHOR>P Koehn</RAUTHOR>
      <REFTITLE>An experimental management system.</REFTITLE>
      <DATE>2010</DATE>
    </REFERENCE>
    <REFERENCE ID="12">
      <RAUTHOR>K Papineni</RAUTHOR>
      <REFTITLE>BLEU: a method for automatic evaluation of machine translation.</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="13">
      <RAUTHOR>A V I Rosti</RAUTHOR>
      <REFTITLE>Combining outputs from multiple machine translation systems.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="14">
      <RAUTHOR>P Shvaiko</RAUTHOR>
      <REFTITLE>A survey of schemabased matching approaches.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="15">
      <RAUTHOR>M Simard</RAUTHOR>
      <REFTITLE>Rule-based translation with statistical phrase-based post-editing.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="16">
      <RAUTHOR>M Snover</RAUTHOR>
      <REFTITLE>A study of translation edit rate with targeted human annotation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="17">
      <RAUTHOR>A Stolcke</RAUTHOR>
      <REFTITLE>SRILM - an extensible language modeling toolkit.</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="18">
      <RAUTHOR>Gregor Thurmair</RAUTHOR>
      <REFTITLE>Comparing different architectures of Hybrid Machine Translation systems.</REFTITLE>
      <DATE>2009</DATE>
    </REFERENCE>
  </REFERENCES>
</PAPER>
