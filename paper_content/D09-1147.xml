<document>
  <filename>D09-1147</filename>
  <authors>
    <author>Adam Pauls</author>
    <author>John DeNero</author>
  </authors>
  <title>Consensus Training for Consensus Decoding in Machine Translation</title>
  <content>
    <sections>
      <section>
        <index>0</index>
        <title>Abstract</title>
        <text>We propose a novel objective function for discriminatively tuning log-linear machine translation models. Our objective explicitly optimizes the BLEU score of expected n-gram counts, the same quantities that arise in forestbased consensus and minimum Bayes risk decoding methods. Our continuous objective can be optimized using simple gradient ascent. However, computing critical quantities in the gradient necessitates a novel dynamic program, which we also present here. Assuming BLEU as an evaluation measure, our objective function has two principle advantages over standard max BLEU tuning. First, it specifically optimizes model weights for downstream consensus decoding procedures. An unexpected second benefit is that it reduces overfitting, which can improve test set BLEU scores when using standard Viterbi decoding.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>We propose a novel objective function for discriminatively tuning log-linear machine translation models.</text>
              <doc_id>0</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Our objective explicitly optimizes the BLEU score of expected n-gram counts, the same quantities that arise in forestbased consensus and minimum Bayes risk decoding methods.</text>
              <doc_id>1</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Our continuous objective can be optimized using simple gradient ascent.</text>
              <doc_id>2</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>However, computing critical quantities in the gradient necessitates a novel dynamic program, which we also present here.</text>
              <doc_id>3</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>Assuming BLEU as an evaluation measure, our objective function has two principle advantages over standard max BLEU tuning.</text>
              <doc_id>4</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>First, it specifically optimizes model weights for downstream consensus decoding procedures.</text>
              <doc_id>5</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>An unexpected second benefit is that it reduces overfitting, which can improve test set BLEU scores when using standard Viterbi decoding.</text>
              <doc_id>6</doc_id>
              <sec_id>6</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>1</index>
        <title>1 Introduction</title>
        <text>Increasing evidence suggests that machine translation decoders should not search for a single top scoring Viterbi derivation, but should instead choose a translation that is sensitive to the model&#8217;s entire predictive distribution. Several recent consensus decoding methods leverage compact representations of this distribution by choosing translations according to n-gram posteriors and expected counts (Tromble et al., 2008; DeNero et al., 2009; Li et al., 2009; Kumar et al., 2009). This change in decoding objective suggests a complementary change in tuning objective, to one that optimizes expected n-gram counts directly. The ubiquitous minimum error rate training (MERT) approach optimizes Viterbi predictions, but does not explicitly boost the aggregated posterior probability of desirable n-grams (Och, 2003). We therefore propose an alternative objective function for parameter tuning, which we call consensus BLEU or CoBLEU, that is designed to maximize the expected counts of the n-grams that appear in reference translations. To maintain consistency across the translation pipeline, we formulate CoBLEU to share the functional form of BLEU used for evaluation. As a result, CoBLEU optimizes exactly the quantities that drive efficient consensus decoding techniques and precisely mirrors the objective used for fast consensus decoding in DeNero et al. (2009). CoBLEU is a continuous and (mostly) differentiable function that we optimize using gradient ascent. We show that this function and its gradient are efficiently computable over packed forests of translations generated by machine translation systems. The gradient includes expectations of products of features and n-gram counts, a quantity that has not appeared in previous work. We present a new dynamic program which allows the efficient computation of these quantities over translation forests. The resulting gradient ascent procedure does not require any k-best approximations. Optimizing over translation forests gives similar stability benefits to recent work on lattice-based minimum error rate training (Macherey et al., 2008) and large-margin training (Chiang et al., 2008). We developed CoBLEU primarily to complement consensus decoding, which it does; it produces higher BLEU scores than coupling MERT with consensus decoding. However, we found an additional empirical benefit: CoBLEU is less prone to overfitting than MERT, even when using Viterbi decoding. In experiments, models trained to maximize tuning set BLEU using MERT consistently degraded in performance from tuning to test set, while CoBLEU-trained models generalized more robustly. As a result, we found that optimizing CoBLEU improved test set performance reliably using consensus decoding and occasionally using Viterbi decoding.
(a) Tuning set sentence and translation
(a) Hypotheses ranked by !TM = !LM = 1
Sentence f: Reference r:
H1) Once on a rhyme
H2) Once upon a rhyme
H3) Once upon a time
Il &#233;tait une rime Once upon a rhyme
TM LM Pr
-3 -7 0.67
-5 -6 0.24
-9 -3 0.09
(b) Computing Consensus Bigram Precision
E &#952; [c(&#8220;Once upon&#8221;,d)|f] = 0.24 + 0.09 = 0.33
E &#952; [c(&#8220;upon a&#8221;,d)|f] = 0.24 + 0.09 = 0.33
E &#952; [c(&#8220;a rhyme&#8221;,d)|f] = 0.67 + 0.24 = 0.91 &#8721;
E &#952; [c(g, d)|f] = 3[0.67 + 0.24 + 0.09] &#8721;
g min{E &#952;[c(g, d)|f],c(g, r)}
&#8721;
g E &#952;[c(g, d)|f]
g
=
0.33 + 0.33 + 0.91 3</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>Increasing evidence suggests that machine translation decoders should not search for a single top scoring Viterbi derivation, but should instead choose a translation that is sensitive to the model&#8217;s entire predictive distribution.</text>
              <doc_id>7</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Several recent consensus decoding methods leverage compact representations of this distribution by choosing translations according to n-gram posteriors and expected counts (Tromble et al., 2008; DeNero et al., 2009; Li et al., 2009; Kumar et al., 2009).</text>
              <doc_id>8</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>This change in decoding objective suggests a complementary change in tuning objective, to one that optimizes expected n-gram counts directly.</text>
              <doc_id>9</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>The ubiquitous minimum error rate training (MERT) approach optimizes Viterbi predictions, but does not explicitly boost the aggregated posterior probability of desirable n-grams (Och, 2003).</text>
              <doc_id>10</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>We therefore propose an alternative objective function for parameter tuning, which we call consensus BLEU or CoBLEU, that is designed to maximize the expected counts of the n-grams that appear in reference translations.</text>
              <doc_id>11</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>To maintain consistency across the translation pipeline, we formulate CoBLEU to share the functional form of BLEU used for evaluation.</text>
              <doc_id>12</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>As a result, CoBLEU optimizes exactly the quantities that drive efficient consensus decoding techniques and precisely mirrors the objective used for fast consensus decoding in DeNero et al. (2009).</text>
              <doc_id>13</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>CoBLEU is a continuous and (mostly) differentiable function that we optimize using gradient ascent.</text>
              <doc_id>14</doc_id>
              <sec_id>7</sec_id>
            </sentence>
            <sentence>
              <text>We show that this function and its gradient are efficiently computable over packed forests of translations generated by machine translation systems.</text>
              <doc_id>15</doc_id>
              <sec_id>8</sec_id>
            </sentence>
            <sentence>
              <text>The gradient includes expectations of products of features and n-gram counts, a quantity that has not appeared in previous work.</text>
              <doc_id>16</doc_id>
              <sec_id>9</sec_id>
            </sentence>
            <sentence>
              <text>We present a new dynamic program which allows the efficient computation of these quantities over translation forests.</text>
              <doc_id>17</doc_id>
              <sec_id>10</sec_id>
            </sentence>
            <sentence>
              <text>The resulting gradient ascent procedure does not require any k-best approximations.</text>
              <doc_id>18</doc_id>
              <sec_id>11</sec_id>
            </sentence>
            <sentence>
              <text>Optimizing over translation forests gives similar stability benefits to recent work on lattice-based minimum error rate training (Macherey et al., 2008) and large-margin training (Chiang et al., 2008).</text>
              <doc_id>19</doc_id>
              <sec_id>12</sec_id>
            </sentence>
            <sentence>
              <text>We developed CoBLEU primarily to complement consensus decoding, which it does; it produces higher BLEU scores than coupling MERT with consensus decoding.</text>
              <doc_id>20</doc_id>
              <sec_id>13</sec_id>
            </sentence>
            <sentence>
              <text>However, we found an additional empirical benefit: CoBLEU is less prone to overfitting than MERT, even when using Viterbi decoding.</text>
              <doc_id>21</doc_id>
              <sec_id>14</sec_id>
            </sentence>
            <sentence>
              <text>In experiments, models trained to maximize tuning set BLEU using MERT consistently degraded in performance from tuning to test set, while CoBLEU-trained models generalized more robustly.</text>
              <doc_id>22</doc_id>
              <sec_id>15</sec_id>
            </sentence>
            <sentence>
              <text>As a result, we found that optimizing CoBLEU improved test set performance reliably using consensus decoding and occasionally using Viterbi decoding.</text>
              <doc_id>23</doc_id>
              <sec_id>16</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>(a) Tuning set sentence and translation</text>
              <doc_id>24</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>(a) Hypotheses ranked by !TM = !LM = 1</text>
              <doc_id>25</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Sentence f: Reference r:</text>
              <doc_id>26</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>H1) Once on a rhyme</text>
              <doc_id>27</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>H2) Once upon a rhyme</text>
              <doc_id>28</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>H3) Once upon a time</text>
              <doc_id>29</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Il &#233;tait une rime Once upon a rhyme</text>
              <doc_id>30</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>TM LM Pr</text>
              <doc_id>31</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>-3 -7 0.67</text>
              <doc_id>32</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>-5 -6 0.24</text>
              <doc_id>33</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>-9 -3 0.09</text>
              <doc_id>34</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>(b) Computing Consensus Bigram Precision</text>
              <doc_id>35</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>E &#952; [c(&#8220;Once upon&#8221;,d)|f] = 0.24 + 0.09 = 0.33</text>
              <doc_id>36</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>E &#952; [c(&#8220;upon a&#8221;,d)|f] = 0.24 + 0.09 = 0.33</text>
              <doc_id>37</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>E &#952; [c(&#8220;a rhyme&#8221;,d)|f] = 0.67 + 0.24 = 0.91 &#8721;</text>
              <doc_id>38</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>E &#952; [c(g, d)|f] = 3[0.67 + 0.24 + 0.09] &#8721;</text>
              <doc_id>39</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>g min{E &#952;[c(g, d)|f],c(g, r)}</text>
              <doc_id>40</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#8721;</text>
              <doc_id>41</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>g E &#952;[c(g, d)|f]</text>
              <doc_id>42</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>g</text>
              <doc_id>43</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>=</text>
              <doc_id>44</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>0.33 + 0.33 + 0.91 3</text>
              <doc_id>45</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>2</index>
        <title>2 Consensus Objective Functions</title>
        <text>Our proposed objective function maximizes n- gram precision by adapting the BLEU evaluation metric as a tuning objective (Papineni et al., 2002). To simplify exposition, we begin by adapting a simpler metric: bigram precision.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>Our proposed objective function maximizes n- gram precision by adapting the BLEU evaluation metric as a tuning objective (Papineni et al., 2002).</text>
              <doc_id>46</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>To simplify exposition, we begin by adapting a simpler metric: bigram precision.</text>
              <doc_id>47</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections>
          <subsection>
            <index>0</index>
            <title>2.1 Bigram Precision Tuning</title>
            <text>Let the tuning corpus consist of source sentences
sentence. Let e i be a translation of f i , and let E = e 1 . . . e m be a corpus of translations, one for each source sentence. A simple evaluation score for E is its bigram precision BP(R, E):
where g 2 iterates over the set of bigrams in the target language, and c(g 2 , e) is the count of bigram g 2 in translation e. As in BLEU, we &#8220;clip&#8221; the bigram counts of e in the numerator using counts of bigrams in the reference sentence. Modern machine translation systems are typically tuned to maximize the evaluation score of Viterbi derivations 1 under a log-linear model with parameters &#952;. Let d &#8727; &#952; (f i) = arg max d P &#952; (d|f i ) be the highest scoring derivation d of f i . For a system employing Viterbi decoding and evaluated by bigram precision, we would want to select &#952; to maximize
end, we can evaluate an entire posterior distribution over derivations H2 by computing the same clipped precision for expected bigram counts using CoBP(R,
is the expected count of bigram g 2 in all derivations d of f i . We define the precise parametric form of P &#952; (d|f i ) in Section Parameter: 3. Figure 1 shows proposed translations for a single sentence along with
the bigram expectations needed to compute CoBP. Equation 1 constitutes an objective function for tuning the parameters of a machine translation model. Figure 2 contrasts the properties of CoBP and MaxBP as tuning objectives, using the simple example from Figure 1. Consensus bigram precision is an instance of a general recipe for converting n-gram based evaluation metrics into consensus objective functions for model tuning. For the remainder of this paper, we focus on consensus BLEU. However, the techniques herein, including the optimization approach of Section 3, are applicable to many differentiable functions of expected n-gram counts. 1 By derivation, we mean a translation of a foreign sentence along with any latent structure assumed by the model. Each derivation corresponds to a particular English translation, but many derivations may yield the same translation.
solid line) of model scores. When varying the single parameter &#952; LM , it entirely disregards the correct translation H 2 because H 2 never attains a maximal model score. (b) A plot of both objectives shows their differing characteristics. The horizontal segmented line at the top of the plot indicates the range over which consensus decoding would select each hypothesis, while the segmented line at the bottom indicates the same for Viterbi decoding. MaxBP is only sensitive to the single point of discontinuity between H 1 and H 3 , and disregards H 2 entirely. CoBP peaks when the distribution most heavily favors H 2 while suppressing H 1 . Though H 2 never has a maximal model score, if &#952; LM is in the indicated range, consensus decoding would select H 2 , the desired translation.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>Let the tuning corpus consist of source sentences</text>
                  <doc_id>48</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>sentence.</text>
                  <doc_id>49</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Let e i be a translation of f i , and let E = e 1 .</text>
                  <doc_id>50</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>.</text>
                  <doc_id>51</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>.</text>
                  <doc_id>52</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
                <sentence>
                  <text>e m be a corpus of translations, one for each source sentence.</text>
                  <doc_id>53</doc_id>
                  <sec_id>4</sec_id>
                </sentence>
                <sentence>
                  <text>A simple evaluation score for E is its bigram precision BP(R, E):</text>
                  <doc_id>54</doc_id>
                  <sec_id>5</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>where g 2 iterates over the set of bigrams in the target language, and c(g 2 , e) is the count of bigram g 2 in translation e. As in BLEU, we &#8220;clip&#8221; the bigram counts of e in the numerator using counts of bigrams in the reference sentence.</text>
                  <doc_id>55</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Modern machine translation systems are typically tuned to maximize the evaluation score of Viterbi derivations 1 under a log-linear model with parameters &#952;. Let d &#8727; &#952; (f i) = arg max d P &#952; (d|f i ) be the highest scoring derivation d of f i .</text>
                  <doc_id>56</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>For a system employing Viterbi decoding and evaluated by bigram precision, we would want to select &#952; to maximize</text>
                  <doc_id>57</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>end, we can evaluate an entire posterior distribution over derivations H2 by computing the same clipped precision for expected bigram counts using CoBP(R,</text>
                  <doc_id>58</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>is the expected count of bigram g 2 in all derivations d of f i .</text>
                  <doc_id>59</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>We define the precise parametric form of P &#952; (d|f i ) in Section Parameter: 3.</text>
                  <doc_id>60</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>Figure 1 shows proposed translations for a single sentence along with</text>
                  <doc_id>61</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>the bigram expectations needed to compute CoBP.</text>
                  <doc_id>62</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Equation 1 constitutes an objective function for tuning the parameters of a machine translation model.</text>
                  <doc_id>63</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>Figure 2 contrasts the properties of CoBP and MaxBP as tuning objectives, using the simple example from Figure 1.</text>
                  <doc_id>64</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>Consensus bigram precision is an instance of a general recipe for converting n-gram based evaluation metrics into consensus objective functions for model tuning.</text>
                  <doc_id>65</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
                <sentence>
                  <text>For the remainder of this paper, we focus on consensus BLEU.</text>
                  <doc_id>66</doc_id>
                  <sec_id>4</sec_id>
                </sentence>
                <sentence>
                  <text>However, the techniques herein, including the optimization approach of Section 3, are applicable to many differentiable functions of expected n-gram counts.</text>
                  <doc_id>67</doc_id>
                  <sec_id>5</sec_id>
                </sentence>
                <sentence>
                  <text>1 By derivation, we mean a translation of a foreign sentence along with any latent structure assumed by the model.</text>
                  <doc_id>68</doc_id>
                  <sec_id>6</sec_id>
                </sentence>
                <sentence>
                  <text>Each derivation corresponds to a particular English translation, but many derivations may yield the same translation.</text>
                  <doc_id>69</doc_id>
                  <sec_id>7</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>solid line) of model scores.</text>
                  <doc_id>70</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>When varying the single parameter &#952; LM , it entirely disregards the correct translation H 2 because H 2 never attains a maximal model score.</text>
                  <doc_id>71</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>(b) A plot of both objectives shows their differing characteristics.</text>
                  <doc_id>72</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>The horizontal segmented line at the top of the plot indicates the range over which consensus decoding would select each hypothesis, while the segmented line at the bottom indicates the same for Viterbi decoding.</text>
                  <doc_id>73</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
                <sentence>
                  <text>MaxBP is only sensitive to the single point of discontinuity between H 1 and H 3 , and disregards H 2 entirely.</text>
                  <doc_id>74</doc_id>
                  <sec_id>4</sec_id>
                </sentence>
                <sentence>
                  <text>CoBP peaks when the distribution most heavily favors H 2 while suppressing H 1 .</text>
                  <doc_id>75</doc_id>
                  <sec_id>5</sec_id>
                </sentence>
                <sentence>
                  <text>Though H 2 never has a maximal model score, if &#952; LM is in the indicated range, consensus decoding would select H 2 , the desired translation.</text>
                  <doc_id>76</doc_id>
                  <sec_id>6</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>1</index>
            <title>2.2 CoBLEU</title>
            <text>ln BLEU(R, E) = 1 &#8722; &#8721; m &#8721;
i=1 g 1
c(g 1 , e i )
+ 1 4 4&#8721;
ln
n=1
&#8721; m
i=1
&#8721;
g n
min{c(g n , e i ), c(g n , r i )} &#8721; m
i=1
&#8721;
g n
c(g n , e i )
Above, |R| denotes the number of words in the reference corpus. The notation (&#183;) &#8722; is shorthand for min(&#183;, 0). In the inner sums, g n iterates over all n-grams of order n. In order to adapt BLEU to be a consensus tuning objective, we follow the recipe of Section 2.1: we replace n-gram counts from a candidate translation with expected n-gram counts under the model. ( ) |R| CoBLEU(R, F, &#952;)= 1&#8722; &#8721; m
i=1&#8721; g 1
E &#952; [c(g 1 , d)|f i ]
+ 1 4 4&#8721;
ln
n=1
&#8721; m
i=1
&#8721;
g n
min{E &#952; [c(g n , d)|f i ], c(g n , r i )} &#8721; m
i=1
&#8721;
g n
E &#952; [c(g n , d)|f i ]
The brevity penalty term in BLEU is calculated using the expected length of the corpus, which
2 Throughout this paper, we use only a single reference,
but our objective readily extends to multiple references.
&#8722;
&#8722;
equals the sum of all expected unigram counts. We call this objective function consensus BLEU, or CoBLEU for short.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>ln BLEU(R, E) = 1 &#8722; &#8721; m &#8721;</text>
                  <doc_id>77</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>i=1 g 1</text>
                  <doc_id>78</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>c(g 1 , e i )</text>
                  <doc_id>79</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>+ 1 4 4&#8721;</text>
                  <doc_id>80</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>ln</text>
                  <doc_id>81</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>n=1</text>
                  <doc_id>82</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8721; m</text>
                  <doc_id>83</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>i=1</text>
                  <doc_id>84</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8721;</text>
                  <doc_id>85</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>g n</text>
                  <doc_id>86</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>min{c(g n , e i ), c(g n , r i )} &#8721; m</text>
                  <doc_id>87</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>i=1</text>
                  <doc_id>88</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8721;</text>
                  <doc_id>89</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>g n</text>
                  <doc_id>90</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>c(g n , e i )</text>
                  <doc_id>91</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Above, |R| denotes the number of words in the reference corpus.</text>
                  <doc_id>92</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>The notation (&#183;) &#8722; is shorthand for min(&#183;, 0).</text>
                  <doc_id>93</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>In the inner sums, g n iterates over all n-grams of order n.</text>
                  <doc_id>94</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>In order to adapt BLEU to be a consensus tuning objective, we follow the recipe of Section 2.1: we replace n-gram counts from a candidate translation with expected n-gram counts under the model.</text>
                  <doc_id>95</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
                <sentence>
                  <text>( ) |R| CoBLEU(R, F, &#952;)= 1&#8722; &#8721; m</text>
                  <doc_id>96</doc_id>
                  <sec_id>4</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>i=1&#8721; g 1</text>
                  <doc_id>97</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>E &#952; [c(g 1 , d)|f i ]</text>
                  <doc_id>98</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>+ 1 4 4&#8721;</text>
                  <doc_id>99</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>ln</text>
                  <doc_id>100</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>n=1</text>
                  <doc_id>101</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8721; m</text>
                  <doc_id>102</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>i=1</text>
                  <doc_id>103</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8721;</text>
                  <doc_id>104</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>g n</text>
                  <doc_id>105</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>min{E &#952; [c(g n , d)|f i ], c(g n , r i )} &#8721; m</text>
                  <doc_id>106</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>i=1</text>
                  <doc_id>107</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8721;</text>
                  <doc_id>108</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>g n</text>
                  <doc_id>109</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>E &#952; [c(g n , d)|f i ]</text>
                  <doc_id>110</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>The brevity penalty term in BLEU is calculated using the expected length of the corpus, which</text>
                  <doc_id>111</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>2 Throughout this paper, we use only a single reference,</text>
                  <doc_id>112</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>but our objective readily extends to multiple references.</text>
                  <doc_id>113</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8722;</text>
                  <doc_id>114</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8722;</text>
                  <doc_id>115</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>equals the sum of all expected unigram counts.</text>
                  <doc_id>116</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>We call this objective function consensus BLEU, or CoBLEU for short.</text>
                  <doc_id>117</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
        </subsections>
      </section>
      <section>
        <index>3</index>
        <title>3 Optimizing CoBLEU</title>
        <text>Unlike the more common MaxBLEU tuning objective optimized by MERT, CoBLEU is continuous. For distributions P &#952; (d|f i ) that factor over synchronous grammar rules and n-grams, we show below that it is also analytically differentiable, permitting a straightforward gradient ascent optimization procedure. 3 In order to perform gradient ascent, we require methods for efficiently computing the gradient of the objective function for a given parameter setting &#952;. Once we have the gradient, we can perform an update at iteration t of the form
&#952; (t+1) &#8592; &#952; (t) + &#951; t &#8711; &#952; CoBLEU(R, F, &#952; (t) )
where &#951; t is an adaptive step size. 4
3 Technically, CoBLEU is non-differentiable at some
points because of clipping. At these points, we must compute a sub-gradient, and so our optimization is formally subgradient ascent. See the Appendix for details. 4 After each successful step, we grow the step size by a
constant factor. Whenever the objective does not decrease after a step, we shrink the step size by a constant factor and try again until a decrease is attained.
l 2 (h) =2
u=OnceSrhyme
tail(h)
head(h) c(&#8220;Once upon&#8221;, h) = 1 c(&#8220;upon a&#8221;, h) = 1
v1=OnceRBOnce v2=uponINupon v3=aNPrhyme
In this section, we develop an analytical expression for the gradient of CoBLEU, then discuss how to efficiently compute the value of the objective function and gradient.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>Unlike the more common MaxBLEU tuning objective optimized by MERT, CoBLEU is continuous.</text>
              <doc_id>118</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>For distributions P &#952; (d|f i ) that factor over synchronous grammar rules and n-grams, we show below that it is also analytically differentiable, permitting a straightforward gradient ascent optimization procedure.</text>
              <doc_id>119</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>3 In order to perform gradient ascent, we require methods for efficiently computing the gradient of the objective function for a given parameter setting &#952;.</text>
              <doc_id>120</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Once we have the gradient, we can perform an update at iteration t of the form</text>
              <doc_id>121</doc_id>
              <sec_id>3</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>&#952; (t+1) &#8592; &#952; (t) + &#951; t &#8711; &#952; CoBLEU(R, F, &#952; (t) )</text>
              <doc_id>122</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>where &#951; t is an adaptive step size.</text>
              <doc_id>123</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>4</text>
              <doc_id>124</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>3 Technically, CoBLEU is non-differentiable at some</text>
              <doc_id>125</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>points because of clipping.</text>
              <doc_id>126</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>At these points, we must compute a sub-gradient, and so our optimization is formally subgradient ascent.</text>
              <doc_id>127</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>See the Appendix for details.</text>
              <doc_id>128</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>4 After each successful step, we grow the step size by a</text>
              <doc_id>129</doc_id>
              <sec_id>3</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>constant factor.</text>
              <doc_id>130</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Whenever the objective does not decrease after a step, we shrink the step size by a constant factor and try again until a decrease is attained.</text>
              <doc_id>131</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>l 2 (h) =2</text>
              <doc_id>132</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>u=OnceSrhyme</text>
              <doc_id>133</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>tail(h)</text>
              <doc_id>134</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>head(h) c(&#8220;Once upon&#8221;, h) = 1 c(&#8220;upon a&#8221;, h) = 1</text>
              <doc_id>135</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>v1=OnceRBOnce v2=uponINupon v3=aNPrhyme</text>
              <doc_id>136</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>In this section, we develop an analytical expression for the gradient of CoBLEU, then discuss how to efficiently compute the value of the objective function and gradient.</text>
              <doc_id>137</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections>
          <subsection>
            <index>0</index>
            <title>3.1 Translation Model Form</title>
            <text>We first assume the general hypergraph setting of Huang and Chiang (2007), namely, that derivations under our translation model form a hypergraph. This framework allows us to speak about both phrase-based and syntax-based translation in a unified framework.
We define a probability distribution over derivations d via &#952; as:
with
P &#952; (d|f i ) = w(d) Z(f i )
Z(f i ) = &#8721; d &#8242; w(d &#8242; )
where w(d) = exp(&#952; &#8868; &#934;(d, f i )) is the weight of a derivation and &#934;(d, f i ) is a featurized representation of the derivation d of f i . We further assume that these features decompose over hyperedges in the hypergraph, like the one in Figure 3. That is, &#934;(d, f i ) = &#8721; h&#8712;d &#934;(h, f i).
In this setting, we can analytically compute the gradient of CoBLEU. We provide a sketch of the derivation of this gradient in the Appendix. In computing this gradient, we must calculate the following expectations:
E &#952; [c(&#966; k , d)|f i ] (2)
E &#952; [l n (d)|f i ] (3)
E &#952; [c(&#966; k , d) &#183; l n (d)|f i ] (4)
where l n (d) = &#8721; g n c(g n , d) is the sum of all n- grams on derivation d (its &#8220;length&#8221;). The first expectation is an expected count of the kth feature &#966; k over all derivations of f i . The second is an expected length, the total expected count of all n- grams in derivations of f i . We call the final expectation an expected product of counts. We now present the computation of each of these expectations in turn.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>We first assume the general hypergraph setting of Huang and Chiang (2007), namely, that derivations under our translation model form a hypergraph.</text>
                  <doc_id>138</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>This framework allows us to speak about both phrase-based and syntax-based translation in a unified framework.</text>
                  <doc_id>139</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>We define a probability distribution over derivations d via &#952; as:</text>
                  <doc_id>140</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>with</text>
                  <doc_id>141</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>P &#952; (d|f i ) = w(d) Z(f i )</text>
                  <doc_id>142</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Z(f i ) = &#8721; d &#8242; w(d &#8242; )</text>
                  <doc_id>143</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>where w(d) = exp(&#952; &#8868; &#934;(d, f i )) is the weight of a derivation and &#934;(d, f i ) is a featurized representation of the derivation d of f i .</text>
                  <doc_id>144</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>We further assume that these features decompose over hyperedges in the hypergraph, like the one in Figure 3.</text>
                  <doc_id>145</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>That is, &#934;(d, f i ) = &#8721; h&#8712;d &#934;(h, f i).</text>
                  <doc_id>146</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>In this setting, we can analytically compute the gradient of CoBLEU.</text>
                  <doc_id>147</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>We provide a sketch of the derivation of this gradient in the Appendix.</text>
                  <doc_id>148</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>In computing this gradient, we must calculate the following expectations:</text>
                  <doc_id>149</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>E &#952; [c(&#966; k , d)|f i ] (2)</text>
                  <doc_id>150</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>E &#952; [l n (d)|f i ] (3)</text>
                  <doc_id>151</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>E &#952; [c(&#966; k , d) &#183; l n (d)|f i ] (4)</text>
                  <doc_id>152</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>where l n (d) = &#8721; g n c(g n , d) is the sum of all n- grams on derivation d (its &#8220;length&#8221;).</text>
                  <doc_id>153</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>The first expectation is an expected count of the kth feature &#966; k over all derivations of f i .</text>
                  <doc_id>154</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>The second is an expected length, the total expected count of all n- grams in derivations of f i .</text>
                  <doc_id>155</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>We call the final expectation an expected product of counts.</text>
                  <doc_id>156</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
                <sentence>
                  <text>We now present the computation of each of these expectations in turn.</text>
                  <doc_id>157</doc_id>
                  <sec_id>4</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>1</index>
            <title>3.2 Computing Feature Expectations</title>
            <text>The expected feature counts E &#952; [c(&#966; k , d)|f i ] can be written as
E &#952; [c(&#966; k , d)|f i ] = &#8721; d
= &#8721; h
P &#952; (d|f i )c(&#966; k , d)
P &#952; (h|f i )c(&#966; k , h)
We can justify the second step since feature counts are local to hyperedges, i.e. c(&#966; k , d) = &#8721; h&#8712;d c(&#966; k, h). The posterior probability P &#952; (h|f i ) can be efficiently computed with inside-outside scores. Let I(u) and O(u) be the standard inside and outside scores for a node u in the forest. 5
P &#952; (h|f i ) = 1 Z(f) w(h) O(head(h)) &#8719;
v&#8712;tail(h)
I(v)
where w(h) is the weight of hyperedge h, given by exp(&#952; &#8868; &#934;(h)), and Z(f) = I(root) is the inside score of the root of the forest. Computing these inside-outside quantities takes time linear in the number of hyperedges in the forest.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>The expected feature counts E &#952; [c(&#966; k , d)|f i ] can be written as</text>
                  <doc_id>158</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>E &#952; [c(&#966; k , d)|f i ] = &#8721; d</text>
                  <doc_id>159</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>= &#8721; h</text>
                  <doc_id>160</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>P &#952; (d|f i )c(&#966; k , d)</text>
                  <doc_id>161</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>P &#952; (h|f i )c(&#966; k , h)</text>
                  <doc_id>162</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>We can justify the second step since feature counts are local to hyperedges, i.e. c(&#966; k , d) = &#8721; h&#8712;d c(&#966; k, h).</text>
                  <doc_id>163</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>The posterior probability P &#952; (h|f i ) can be efficiently computed with inside-outside scores.</text>
                  <doc_id>164</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>Let I(u) and O(u) be the standard inside and outside scores for a node u in the forest.</text>
                  <doc_id>165</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>5</text>
                  <doc_id>166</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>P &#952; (h|f i ) = 1 Z(f) w(h) O(head(h)) &#8719;</text>
                  <doc_id>167</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>v&#8712;tail(h)</text>
                  <doc_id>168</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>I(v)</text>
                  <doc_id>169</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>where w(h) is the weight of hyperedge h, given by exp(&#952; &#8868; &#934;(h)), and Z(f) = I(root) is the inside score of the root of the forest.</text>
                  <doc_id>170</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Computing these inside-outside quantities takes time linear in the number of hyperedges in the forest.</text>
                  <doc_id>171</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>2</index>
            <title>3.3 Computing n-gram Expectations</title>
            <text>We can compute the expectations of any specific n-grams, or of total n-gram counts l, in the same way as feature expectations, provided that targetside n-grams are also localized to hyperedges (e.g. consider l to be a feature of a hyperedge whose value is the number of n-grams on h). If the nodes in our forests are annotated with target-side
5 Appendix Figure 7 gives recursions for I(u) and O(u).
boundary words as in Figure 3, then this will be the case. Note that this is the same approach used by decoders which integrate a target language model (e.g. Chiang (2007)). Other work has computed n-gram expectations in the same way (DeNero et al., 2009; Li et al., 2009).</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>We can compute the expectations of any specific n-grams, or of total n-gram counts l, in the same way as feature expectations, provided that targetside n-grams are also localized to hyperedges (e.g. consider l to be a feature of a hyperedge whose value is the number of n-grams on h).</text>
                  <doc_id>172</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>If the nodes in our forests are annotated with target-side</text>
                  <doc_id>173</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>5 Appendix Figure 7 gives recursions for I(u) and O(u).</text>
                  <doc_id>174</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>boundary words as in Figure 3, then this will be the case.</text>
                  <doc_id>175</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Note that this is the same approach used by decoders which integrate a target language model (e.g. Chiang (2007)).</text>
                  <doc_id>176</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>Other work has computed n-gram expectations in the same way (DeNero et al., 2009; Li et al., 2009).</text>
                  <doc_id>177</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>3</index>
            <title>3.4 Computing Expectations of Products of Counts</title>
            <text>While the previous two expectations can be computed using techniques known in the literature, the expected product of counts E &#952; [c(&#966; k , d) &#183; l n (d)|f i ] is a novel quantity. Fortunately, an efficient dynamic program exists for computing this expectation as well. We present this dynamic program here as one of the contributions of this paper, though we omit a full derivation due to space restrictions.
To see why this expectation cannot be computed in the same way as the expected feature or n-gram counts, we expand the definition of the expectation above to get &#8721;
P &#952; (d|f i ) [c(&#966; k , d)l n (d)]
d
Unlike feature and n-gram counts, the product of counts in brackets above does not decompose over hyperedges, at least not in an obvious way. We can, however, still decompose the feature counts c(&#966; k , d) over hyperedges. After this decomposition and a little re-arranging, we get
= &#8721; c(&#966; k , h) &#8721; P &#952; (d|f i )l n (d)
h d:h&#8712;d
=
=
1 Z(f i )
1 Z(f i ) [ ] &#8721; &#8721;
c(&#966; k , h) w(d)l n (d)
h d:h&#8712;d
&#8721; c(&#966; k , h)&#710;D n &#952; (h|f i )
h
The quantity &#710;D n &#952; (h|f i ) = &#8721; d:h&#8712;d w(d)l n(d) is the sum of the weight-length products of all derivations d containing hyperedge h. In the same way that P &#952; (h|f i ) can be efficiently computed from inside and outside probabilities, this quantity &#710;D n &#952; (h|f i ) can be efficiently computed with two new inside and outside quantities, which we call &#206; n (u) and &#212;n(u). We provide recursions for these quantities in Figure 4. Like the standard inside and outside computations, these recursions run in time linear in the number of hyperedges in the forest.
While a full exposition of the algorithm is not possible in the available space, we give some brief intuition behind this dynamic program. We first define &#206; n (u):
&#206; n (u) = &#8721; d u w(d u )l n (d)
where d u is a derivation rooted at node u. This is a sum of weight-length products similar to &#710;D. To give a recurrence for &#206;, we rewrite it:
&#206; n (u) = &#8721; &#8721; [w(d u )l n (h)]
d u h&#8712;d u
Here, we have broken up the total value of l n (d) across hyperedges in d. The bracketed quantity is a score of a marked derivation pair (d, h) where the edge h is some specific element of d. The score of a marked derivation includes the weight of the derivation and the factor l n (h) for the marked hyperedge.
This sum over marked derivations gives the inside recurrence in Figure 4 by the following decomposition. For &#206; n (u) to sum over all marked derivation pairs rooted at u, we must consider two cases. First, the marked hyperedge could be at the root, in which case we must choose child derivations from regular inside scores and multiply in the local l n , giving the first summand of &#206; n (u). Alternatively, the marked hyperedge is in exactly one of the children; for each possibility we recursively choose a marked derivation for one child, while the other children choose regular derivations. The second summand of &#206; n (u) compactly expresses a sum over instances of this case. &#212; n (u) decomposes similarly: the marked hyperedge could be local (first summand), under a sibling (second summand), or higher in the tree (third summand).
Once we have these new inside-outside quantities, we can compute &#710;D as in Figure 5. This combination states that marked derivations containing h are either marked at h, below h, or above h.
As a final detail, computing the gradient &#8711;Cn clip (&#952;) (see the Appendix) involves a clipped version of the expected product of counts, for which a clipped &#710;D is required. This quantity can be computed with the same dynamic program with a slight modification. In Figure 4, we show the difference as a choice point when computing l n (h).</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>While the previous two expectations can be computed using techniques known in the literature, the expected product of counts E &#952; [c(&#966; k , d) &#183; l n (d)|f i ] is a novel quantity.</text>
                  <doc_id>178</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Fortunately, an efficient dynamic program exists for computing this expectation as well.</text>
                  <doc_id>179</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>We present this dynamic program here as one of the contributions of this paper, though we omit a full derivation due to space restrictions.</text>
                  <doc_id>180</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>To see why this expectation cannot be computed in the same way as the expected feature or n-gram counts, we expand the definition of the expectation above to get &#8721;</text>
                  <doc_id>181</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>P &#952; (d|f i ) [c(&#966; k , d)l n (d)]</text>
                  <doc_id>182</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>d</text>
                  <doc_id>183</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Unlike feature and n-gram counts, the product of counts in brackets above does not decompose over hyperedges, at least not in an obvious way.</text>
                  <doc_id>184</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>We can, however, still decompose the feature counts c(&#966; k , d) over hyperedges.</text>
                  <doc_id>185</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>After this decomposition and a little re-arranging, we get</text>
                  <doc_id>186</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>= &#8721; c(&#966; k , h) &#8721; P &#952; (d|f i )l n (d)</text>
                  <doc_id>187</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>h d:h&#8712;d</text>
                  <doc_id>188</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>=</text>
                  <doc_id>189</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>=</text>
                  <doc_id>190</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>1 Z(f i )</text>
                  <doc_id>191</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>1 Z(f i ) [ ] &#8721; &#8721;</text>
                  <doc_id>192</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>c(&#966; k , h) w(d)l n (d)</text>
                  <doc_id>193</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>h d:h&#8712;d</text>
                  <doc_id>194</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#8721; c(&#966; k , h)&#710;D n &#952; (h|f i )</text>
                  <doc_id>195</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>h</text>
                  <doc_id>196</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>The quantity &#710;D n &#952; (h|f i ) = &#8721; d:h&#8712;d w(d)l n(d) is the sum of the weight-length products of all derivations d containing hyperedge h.</text>
                  <doc_id>197</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>In the same way that P &#952; (h|f i ) can be efficiently computed from inside and outside probabilities, this quantity &#710;D n &#952; (h|f i ) can be efficiently computed with two new inside and outside quantities, which we call &#206; n (u) and &#212;n(u).</text>
                  <doc_id>198</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>We provide recursions for these quantities in Figure 4.</text>
                  <doc_id>199</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>Like the standard inside and outside computations, these recursions run in time linear in the number of hyperedges in the forest.</text>
                  <doc_id>200</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>While a full exposition of the algorithm is not possible in the available space, we give some brief intuition behind this dynamic program.</text>
                  <doc_id>201</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>We first define &#206; n (u):</text>
                  <doc_id>202</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#206; n (u) = &#8721; d u w(d u )l n (d)</text>
                  <doc_id>203</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>where d u is a derivation rooted at node u.</text>
                  <doc_id>204</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>This is a sum of weight-length products similar to &#710;D.</text>
                  <doc_id>205</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>To give a recurrence for &#206;, we rewrite it:</text>
                  <doc_id>206</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#206; n (u) = &#8721; &#8721; [w(d u )l n (h)]</text>
                  <doc_id>207</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>d u h&#8712;d u</text>
                  <doc_id>208</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Here, we have broken up the total value of l n (d) across hyperedges in d.</text>
                  <doc_id>209</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>The bracketed quantity is a score of a marked derivation pair (d, h) where the edge h is some specific element of d.</text>
                  <doc_id>210</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>The score of a marked derivation includes the weight of the derivation and the factor l n (h) for the marked hyperedge.</text>
                  <doc_id>211</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>This sum over marked derivations gives the inside recurrence in Figure 4 by the following decomposition.</text>
                  <doc_id>212</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>For &#206; n (u) to sum over all marked derivation pairs rooted at u, we must consider two cases.</text>
                  <doc_id>213</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>First, the marked hyperedge could be at the root, in which case we must choose child derivations from regular inside scores and multiply in the local l n , giving the first summand of &#206; n (u).</text>
                  <doc_id>214</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>Alternatively, the marked hyperedge is in exactly one of the children; for each possibility we recursively choose a marked derivation for one child, while the other children choose regular derivations.</text>
                  <doc_id>215</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
                <sentence>
                  <text>The second summand of &#206; n (u) compactly expresses a sum over instances of this case.</text>
                  <doc_id>216</doc_id>
                  <sec_id>4</sec_id>
                </sentence>
                <sentence>
                  <text>&#212; n (u) decomposes similarly: the marked hyperedge could be local (first summand), under a sibling (second summand), or higher in the tree (third summand).</text>
                  <doc_id>217</doc_id>
                  <sec_id>5</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Once we have these new inside-outside quantities, we can compute &#710;D as in Figure 5.</text>
                  <doc_id>218</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>This combination states that marked derivations containing h are either marked at h, below h, or above h.</text>
                  <doc_id>219</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>As a final detail, computing the gradient &#8711;Cn clip (&#952;) (see the Appendix) involves a clipped version of the expected product of counts, for which a clipped &#710;D is required.</text>
                  <doc_id>220</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>This quantity can be computed with the same dynamic program with a slight modification.</text>
                  <doc_id>221</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>In Figure 4, we show the difference as a choice point when computing l n (h).</text>
                  <doc_id>222</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>4</index>
            <title>3.5 Implementation Details</title>
            <text>As stated, the runtime of computing the required expectations for the objective and gradient is linear in the number of hyperedges in the forest. The
&#206; n (u) = &#8721;
h&#8712;IN(u)
&#9121;
w(h) &#9123;l n (h) &#8719;
v&#8712;tail(h)
I(v) + &#8721;
v&#8712;tail(h)
&#206; n (v) &#8719; w&#8800;v
&#9124;
I(w) &#9126;
&#212; n (u) = &#8721; w(h) &#9122; &#9123; l n(h) O(head(h)) &#8719; I(v) + O(head(h)) &#8721; &#206; n (v) &#8719; I(w) + &#212;n(head(h)) &#8719; I(w) &#9125; &#9126;
h&#8712;OUT(u)
&#9121;
v&#8712;tail(h) v&#8800;u v&#8712;tail(h)
v&#8800;u w&#8712;tail(h)
w&#8800;v w&#8800;u
{ &#8721;
gn
l n (h) = c(g n, h) computing unclipped counts &#8721;
g n
c(g n , h)1 [E &#952; [c(g n , d)] &#8804; c(g n , r i )] computing clipped counts
w&#8712;tail(h) w&#8800;u
&#9124;
&#9121; w(h) &#9122; &#9123; l n(h)O(head(h)) &#8719;
v&#8712;tail(h)
&#710;D n &#952; (h|f i ) =
I(v) + O(head(h)) &#8721;
v&#8712;tail(h)
&#206; n (v) &#8719;
v&#8712;tail(h) w&#8800;v
I(w) + &#212;n(head(h)) &#8719;
w&#8712;tail(h)
&#9124; I(w) &#9125; &#9126;
number of hyperedges is very large, however, because we must track n-gram contexts in the nodes, just as we would in an integrated language model decoder. These contexts are required both to correctly compute the model score of derivations and to compute clipped n-gram counts. To speed our computations, we use the cube pruning method of Huang and Chiang (2007) with a fixed beam size.
For regularization, we added an L 2 penalty on the size of &#952; to the CoBLEU objective, a simple addition for gradient ascent. We did not find that our performance varied very much for moderate levels of regularization.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>As stated, the runtime of computing the required expectations for the objective and gradient is linear in the number of hyperedges in the forest.</text>
                  <doc_id>223</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>The</text>
                  <doc_id>224</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#206; n (u) = &#8721;</text>
                  <doc_id>225</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>h&#8712;IN(u)</text>
                  <doc_id>226</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#9121;</text>
                  <doc_id>227</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>w(h) &#9123;l n (h) &#8719;</text>
                  <doc_id>228</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>v&#8712;tail(h)</text>
                  <doc_id>229</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>I(v) + &#8721;</text>
                  <doc_id>230</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>v&#8712;tail(h)</text>
                  <doc_id>231</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#206; n (v) &#8719; w&#8800;v</text>
                  <doc_id>232</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#9124;</text>
                  <doc_id>233</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>I(w) &#9126;</text>
                  <doc_id>234</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#212; n (u) = &#8721; w(h) &#9122; &#9123; l n(h) O(head(h)) &#8719; I(v) + O(head(h)) &#8721; &#206; n (v) &#8719; I(w) + &#212;n(head(h)) &#8719; I(w) &#9125; &#9126;</text>
                  <doc_id>235</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>h&#8712;OUT(u)</text>
                  <doc_id>236</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#9121;</text>
                  <doc_id>237</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>v&#8712;tail(h) v&#8800;u v&#8712;tail(h)</text>
                  <doc_id>238</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>v&#8800;u w&#8712;tail(h)</text>
                  <doc_id>239</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>w&#8800;v w&#8800;u</text>
                  <doc_id>240</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>{ &#8721;</text>
                  <doc_id>241</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>gn</text>
                  <doc_id>242</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>l n (h) = c(g n, h) computing unclipped counts &#8721;</text>
                  <doc_id>243</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>g n</text>
                  <doc_id>244</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>c(g n , h)1 [E &#952; [c(g n , d)] &#8804; c(g n , r i )] computing clipped counts</text>
                  <doc_id>245</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>w&#8712;tail(h) w&#8800;u</text>
                  <doc_id>246</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#9124;</text>
                  <doc_id>247</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#9121; w(h) &#9122; &#9123; l n(h)O(head(h)) &#8719;</text>
                  <doc_id>248</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>v&#8712;tail(h)</text>
                  <doc_id>249</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#710;D n &#952; (h|f i ) =</text>
                  <doc_id>250</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>I(v) + O(head(h)) &#8721;</text>
                  <doc_id>251</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>v&#8712;tail(h)</text>
                  <doc_id>252</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#206; n (v) &#8719;</text>
                  <doc_id>253</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>v&#8712;tail(h) w&#8800;v</text>
                  <doc_id>254</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>I(w) + &#212;n(head(h)) &#8719;</text>
                  <doc_id>255</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>w&#8712;tail(h)</text>
                  <doc_id>256</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>&#9124; I(w) &#9125; &#9126;</text>
                  <doc_id>257</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>number of hyperedges is very large, however, because we must track n-gram contexts in the nodes, just as we would in an integrated language model decoder.</text>
                  <doc_id>258</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>These contexts are required both to correctly compute the model score of derivations and to compute clipped n-gram counts.</text>
                  <doc_id>259</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>To speed our computations, we use the cube pruning method of Huang and Chiang (2007) with a fixed beam size.</text>
                  <doc_id>260</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>For regularization, we added an L 2 penalty on the size of &#952; to the CoBLEU objective, a simple addition for gradient ascent.</text>
                  <doc_id>261</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>We did not find that our performance varied very much for moderate levels of regularization.</text>
                  <doc_id>262</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>5</index>
            <title>3.6 Related Work</title>
            <text>The calculation of expected counts can be formulated using the expectation semiring framework of Eisner (2002), though that work does not show how to compute expected products of counts which are needed for our gradient calculations. Concurrently with this work, Li and Eisner (2009) have generalized Eisner (2002) to compute expected products of counts on translation forests. The training algorithm of Kakade et al. (2002) makes use of a dynamic program similar to ours, though specialized to the case of sequence models.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>The calculation of expected counts can be formulated using the expectation semiring framework of Eisner (2002), though that work does not show how to compute expected products of counts which are needed for our gradient calculations.</text>
                  <doc_id>263</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Concurrently with this work, Li and Eisner (2009) have generalized Eisner (2002) to compute expected products of counts on translation forests.</text>
                  <doc_id>264</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>The training algorithm of Kakade et al. (2002) makes use of a dynamic program similar to ours, though specialized to the case of sequence models.</text>
                  <doc_id>265</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
        </subsections>
      </section>
      <section>
        <index>4</index>
        <title>4 Consensus Decoding</title>
        <text>Once model parameters &#952; are learned, we must select an appropriate decoding objective. Several new decoding approaches have been proposed recently that leverage some notion of consensus over the many weighted derivations in a translation forest. In this paper, we adopt the fast consensus decoding procedure of DeNero et al. (2009), which directly complements CoBLEU tuning. For a source sentence f, we first build a translation forest, then compute the expected count of each n-gram in the translation of f under the model. We extract a k-best list from the forest, then select the translation that yields the highest BLEU score relative to the forest&#8217;s expected n-gram counts. Specifically, let BLEU(e; r) compute the similarity of a sentence e to a reference r based on the n-gram counts of each. When training with CoBLEU, we replace e with expected counts and maximize &#952;. In consensus decoding, we replace r with expected counts and maximize e.
Several other efficient consensus decoding pro-
Fraction of Value at Convergence
0.0 0.2 0.4 0.6 0.8 1.0
cedures would similarly benefit from a tuning procedure that aggregates over derivations. For instance, Blunsom and Osborne (2008) select the translation sentence with highest posterior probability under the model, summing over derivations. Li et al. (2009) propose a variational approximation maximizing sentence probability that decomposes over n-grams. Tromble et al. (2008) minimize risk under a loss function based on the linear Taylor approximation to BLEU, which decomposes over n-gram posterior probabilities.
2 4 6 8 10
Iterations
CoBLEU MERT</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>Once model parameters &#952; are learned, we must select an appropriate decoding objective.</text>
              <doc_id>266</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>Several new decoding approaches have been proposed recently that leverage some notion of consensus over the many weighted derivations in a translation forest.</text>
              <doc_id>267</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>In this paper, we adopt the fast consensus decoding procedure of DeNero et al. (2009), which directly complements CoBLEU tuning.</text>
              <doc_id>268</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>For a source sentence f, we first build a translation forest, then compute the expected count of each n-gram in the translation of f under the model.</text>
              <doc_id>269</doc_id>
              <sec_id>3</sec_id>
            </sentence>
            <sentence>
              <text>We extract a k-best list from the forest, then select the translation that yields the highest BLEU score relative to the forest&#8217;s expected n-gram counts.</text>
              <doc_id>270</doc_id>
              <sec_id>4</sec_id>
            </sentence>
            <sentence>
              <text>Specifically, let BLEU(e; r) compute the similarity of a sentence e to a reference r based on the n-gram counts of each.</text>
              <doc_id>271</doc_id>
              <sec_id>5</sec_id>
            </sentence>
            <sentence>
              <text>When training with CoBLEU, we replace e with expected counts and maximize &#952;.</text>
              <doc_id>272</doc_id>
              <sec_id>6</sec_id>
            </sentence>
            <sentence>
              <text>In consensus decoding, we replace r with expected counts and maximize e.</text>
              <doc_id>273</doc_id>
              <sec_id>7</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Several other efficient consensus decoding pro-</text>
              <doc_id>274</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Fraction of Value at Convergence</text>
              <doc_id>275</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>0.0 0.2 0.4 0.6 0.8 1.0</text>
              <doc_id>276</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>cedures would similarly benefit from a tuning procedure that aggregates over derivations.</text>
              <doc_id>277</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>For instance, Blunsom and Osborne (2008) select the translation sentence with highest posterior probability under the model, summing over derivations.</text>
              <doc_id>278</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>Li et al. (2009) propose a variational approximation maximizing sentence probability that decomposes over n-grams.</text>
              <doc_id>279</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>Tromble et al. (2008) minimize risk under a loss function based on the linear Taylor approximation to BLEU, which decomposes over n-gram posterior probabilities.</text>
              <doc_id>280</doc_id>
              <sec_id>3</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>2 4 6 8 10</text>
              <doc_id>281</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Iterations</text>
              <doc_id>282</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>CoBLEU MERT</text>
              <doc_id>283</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
      <section>
        <index>5</index>
        <title>5 Experiments</title>
        <text>We compared CoBLEU training with an implementation of minimum error rate training on two language pairs.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>We compared CoBLEU training with an implementation of minimum error rate training on two language pairs.</text>
              <doc_id>284</doc_id>
              <sec_id>0</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections>
          <subsection>
            <index>0</index>
            <title>5.1 Model</title>
            <text>Our optimization procedure is in principle tractable for any syntactic translation system. For simplicity, we evaluate the objective using an Inversion Transduction Grammar (ITG) (Wu, 1997) that emits phrases as terminal productions, as in (Cherry and Lin, 2007). Phrasal ITG models have been shown to perform comparably to the state-ofthe art phrase-based system Moses (Koehn et al., 2007) when using the same phrase table (Petrov et al., 2008).
We extract a phrase table using the Moses pipeline, based on Model 4 word alignments generated from GIZA++ (Och and Ney, 2003). Our final ITG grammar includes the five standard Moses features, an n-gram language model, a length feature that counts the number of target words, a feature that counts the number of monotonic ITG rewrites, and a feature that counts the number of inverted ITG rewrites.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>Our optimization procedure is in principle tractable for any syntactic translation system.</text>
                  <doc_id>285</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>For simplicity, we evaluate the objective using an Inversion Transduction Grammar (ITG) (Wu, 1997) that emits phrases as terminal productions, as in (Cherry and Lin, 2007).</text>
                  <doc_id>286</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>Phrasal ITG models have been shown to perform comparably to the state-ofthe art phrase-based system Moses (Koehn et al., 2007) when using the same phrase table (Petrov et al., 2008).</text>
                  <doc_id>287</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>We extract a phrase table using the Moses pipeline, based on Model 4 word alignments generated from GIZA++ (Och and Ney, 2003).</text>
                  <doc_id>288</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Our final ITG grammar includes the five standard Moses features, an n-gram language model, a length feature that counts the number of target words, a feature that counts the number of monotonic ITG rewrites, and a feature that counts the number of inverted ITG rewrites.</text>
                  <doc_id>289</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>1</index>
            <title>5.2 Data</title>
            <text>We extracted phrase tables from the Spanish- English and French-English sections of the Europarl corpus, which include approximately 8.5 million words of bitext for each of the language pairs (Koehn, 2002). We used a trigram language model trained on the entire corpus of English parliamentary proceedings provided with the Europarl distribution and generated according to the ACL 2008 SMT shared task specifications. 6 For tuning, we used all sentences from the 2007 SMT shared task up to length 25 (880 sentences
6 See http://www.statmt.org/wmt08 for details.
for Spanish and 923 for French), and we tested on the subset of the first 1000 development set sentences which had length at most 25 words (447 sentences for Spanish and 512 for French).</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>We extracted phrase tables from the Spanish- English and French-English sections of the Europarl corpus, which include approximately 8.5 million words of bitext for each of the language pairs (Koehn, 2002).</text>
                  <doc_id>290</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>We used a trigram language model trained on the entire corpus of English parliamentary proceedings provided with the Europarl distribution and generated according to the ACL 2008 SMT shared task specifications.</text>
                  <doc_id>291</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>6 For tuning, we used all sentences from the 2007 SMT shared task up to length 25 (880 sentences</text>
                  <doc_id>292</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>6 See http://www.statmt.org/wmt08 for details.</text>
                  <doc_id>293</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>for Spanish and 923 for French), and we tested on the subset of the first 1000 development set sentences which had length at most 25 words (447 sentences for Spanish and 512 for French).</text>
                  <doc_id>294</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>2</index>
            <title>5.3 Tuning Optimization</title>
            <text>We compared two techniques for tuning the nine log-linear model parameters of our ITG grammar. We maximized CoBLEU using gradient ascent, as described above. As a baseline, we maximized BLEU of the Viterbi translation derivations using minimum error rate training. To improve optimization stability, MERT used a cumulative k-best list that included all translations generated during the tuning process.
One of the benefits of CoBLEU training is that we compute expectations efficiently over an entire forest of translations. This has substantial stability benefits over methods based on k-best lists. In Figure 6, we show the progress of CoBLEU as compared to MERT. Both models are initialized from 0 and use the same features. This plot exhibits a known issue with MERT training: because new k-best lists are generated at each iteration, the objective function can change drastically between iterations. In contrast, CoBLEU converges
Consensus Decoding
smoothly to its final objective because the forests do not change substantially between iterations, despite the pruning needed to track n-grams. Similar stability benefits have been observed for latticebased MERT (Macherey et al., 2008).</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>We compared two techniques for tuning the nine log-linear model parameters of our ITG grammar.</text>
                  <doc_id>295</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>We maximized CoBLEU using gradient ascent, as described above.</text>
                  <doc_id>296</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>As a baseline, we maximized BLEU of the Viterbi translation derivations using minimum error rate training.</text>
                  <doc_id>297</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>To improve optimization stability, MERT used a cumulative k-best list that included all translations generated during the tuning process.</text>
                  <doc_id>298</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>One of the benefits of CoBLEU training is that we compute expectations efficiently over an entire forest of translations.</text>
                  <doc_id>299</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>This has substantial stability benefits over methods based on k-best lists.</text>
                  <doc_id>300</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>In Figure 6, we show the progress of CoBLEU as compared to MERT.</text>
                  <doc_id>301</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>Both models are initialized from 0 and use the same features.</text>
                  <doc_id>302</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
                <sentence>
                  <text>This plot exhibits a known issue with MERT training: because new k-best lists are generated at each iteration, the objective function can change drastically between iterations.</text>
                  <doc_id>303</doc_id>
                  <sec_id>4</sec_id>
                </sentence>
                <sentence>
                  <text>In contrast, CoBLEU converges</text>
                  <doc_id>304</doc_id>
                  <sec_id>5</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Consensus Decoding</text>
                  <doc_id>305</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>smoothly to its final objective because the forests do not change substantially between iterations, despite the pruning needed to track n-grams.</text>
                  <doc_id>306</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Similar stability benefits have been observed for latticebased MERT (Macherey et al., 2008).</text>
                  <doc_id>307</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
          <subsection>
            <index>3</index>
            <title>5.4 Results</title>
            <text>We performed experiments from both French and Spanish into English under three conditions. In the first two, we initialized both MERT and CoBLEU training uniformly with zero weights and trained until convergence. In the third condition, we initialized CoBLEU with the final parameters from MERT training, denoted MERT&#8594;CoBLEU in the results tables. We evaluated each of these conditions on both the tuning and test sets using the consensus decoding method of DeNero et al. (2009). The results appear in Table 1. In Spanish-English, CoBLEU slightly outperformed MERT under the same initialization, while the opposite pattern appears for French-English. The best test set performance in both language pairs was the third condition, in which CoBLEU training was initialized with MERT. This condition also gave the highest CoBLEU objective value. This pattern indicates that CoBLEU is a useful objective for translation with consensus decoding, but that the gradient ascent optimization is getting stuck in local maxima during tuning. This issue can likely be addressed with annealing, as described in (Smith and Eisner, 2006).
Interestingly, the brevity penatly results in French indicate that, even though CoBLEU did Viterbi Decoding
not outperform MERT in a statistically significant way, CoBLEU tends to find shorter sentences with higher n-gram precision than MERT.
Table 1 displays a second benefit of CoBLEU training: compared to MERT training, CoBLEU performance degrades less from tuning to test set. In Spanish, initializing with MERT-trained weights and then training with CoBLEU actually decreases BLEU on the tuning set by 0.8 points. However, this drop in tuning performance comes with a corresponding increase of 0.6 on the test set, relative to MERT training. We see the same pattern in French, albeit to a smaller degree.
While CoBLEU ought to outperform MERT using consensus decoding, we expected that MERT would give better performance under Viterbi decoding. Surprisingly, we found that CoBLEU training actually outperformed MERT in Spanish- English and performed equally well in French- English. Table 2 shows the results. In these experiments, we again see that CoBLEU overfit the training set to a lesser degree than MERT, as evidenced by a smaller drop in performance from tuning to test set. In fact, test set performance actually improved for Spanish-English CoBLEU training while dropping by 2.3 BLEU for MERT.</text>
            <paragraphs>
              <paragraph>
                <sentence>
                  <text>We performed experiments from both French and Spanish into English under three conditions.</text>
                  <doc_id>308</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>In the first two, we initialized both MERT and CoBLEU training uniformly with zero weights and trained until convergence.</text>
                  <doc_id>309</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>In the third condition, we initialized CoBLEU with the final parameters from MERT training, denoted MERT&#8594;CoBLEU in the results tables.</text>
                  <doc_id>310</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>We evaluated each of these conditions on both the tuning and test sets using the consensus decoding method of DeNero et al. (2009).</text>
                  <doc_id>311</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
                <sentence>
                  <text>The results appear in Table 1.</text>
                  <doc_id>312</doc_id>
                  <sec_id>4</sec_id>
                </sentence>
                <sentence>
                  <text>In Spanish-English, CoBLEU slightly outperformed MERT under the same initialization, while the opposite pattern appears for French-English.</text>
                  <doc_id>313</doc_id>
                  <sec_id>5</sec_id>
                </sentence>
                <sentence>
                  <text>The best test set performance in both language pairs was the third condition, in which CoBLEU training was initialized with MERT.</text>
                  <doc_id>314</doc_id>
                  <sec_id>6</sec_id>
                </sentence>
                <sentence>
                  <text>This condition also gave the highest CoBLEU objective value.</text>
                  <doc_id>315</doc_id>
                  <sec_id>7</sec_id>
                </sentence>
                <sentence>
                  <text>This pattern indicates that CoBLEU is a useful objective for translation with consensus decoding, but that the gradient ascent optimization is getting stuck in local maxima during tuning.</text>
                  <doc_id>316</doc_id>
                  <sec_id>8</sec_id>
                </sentence>
                <sentence>
                  <text>This issue can likely be addressed with annealing, as described in (Smith and Eisner, 2006).</text>
                  <doc_id>317</doc_id>
                  <sec_id>9</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Interestingly, the brevity penatly results in French indicate that, even though CoBLEU did Viterbi Decoding</text>
                  <doc_id>318</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>not outperform MERT in a statistically significant way, CoBLEU tends to find shorter sentences with higher n-gram precision than MERT.</text>
                  <doc_id>319</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>Table 1 displays a second benefit of CoBLEU training: compared to MERT training, CoBLEU performance degrades less from tuning to test set.</text>
                  <doc_id>320</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>In Spanish, initializing with MERT-trained weights and then training with CoBLEU actually decreases BLEU on the tuning set by 0.8 points.</text>
                  <doc_id>321</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>However, this drop in tuning performance comes with a corresponding increase of 0.6 on the test set, relative to MERT training.</text>
                  <doc_id>322</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>We see the same pattern in French, albeit to a smaller degree.</text>
                  <doc_id>323</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
              </paragraph>
              <paragraph>
                <sentence>
                  <text>While CoBLEU ought to outperform MERT using consensus decoding, we expected that MERT would give better performance under Viterbi decoding.</text>
                  <doc_id>324</doc_id>
                  <sec_id>0</sec_id>
                </sentence>
                <sentence>
                  <text>Surprisingly, we found that CoBLEU training actually outperformed MERT in Spanish- English and performed equally well in French- English.</text>
                  <doc_id>325</doc_id>
                  <sec_id>1</sec_id>
                </sentence>
                <sentence>
                  <text>Table 2 shows the results.</text>
                  <doc_id>326</doc_id>
                  <sec_id>2</sec_id>
                </sentence>
                <sentence>
                  <text>In these experiments, we again see that CoBLEU overfit the training set to a lesser degree than MERT, as evidenced by a smaller drop in performance from tuning to test set.</text>
                  <doc_id>327</doc_id>
                  <sec_id>3</sec_id>
                </sentence>
                <sentence>
                  <text>In fact, test set performance actually improved for Spanish-English CoBLEU training while dropping by 2.3 BLEU for MERT.</text>
                  <doc_id>328</doc_id>
                  <sec_id>4</sec_id>
                </sentence>
              </paragraph>
            </paragraphs>
          </subsection>
        </subsections>
      </section>
      <section>
        <index>6</index>
        <title>6 Conclusion</title>
        <text>CoBLEU takes a fundamental quantity used in consensus decoding, expected n-grams, and trains to optimize a function of those expectations. While CoBLEU can therefore be expected to increase test set BLEU under consensus decoding, it is more surprising that it seems to better regularize learning even for the Viterbi decoding condition. It is also worth emphasizing that the CoBLEU approach is applicable to functions of expected n- gram counts other than BLEU. 1425 Appendix: The Gradient of CoBLEU We would like to compute the gradient of
of all n-grams or order n in all translations of the source corpus F , while Cn clip (&#952;) represents the sum of the same expected counts, but clipped with reference counts c(g n , r i ). With this notation, we can write our objective function CoBLEU(R, F, &#952;) in three terms:
incoming and outgoing hyperedges of u, respectively. We initialize with I(u) = 1 for all terminal forest nodes u and O(root) = 1 for the root node. These quantities are referenced in Figure 4. and the gradient &#8711;Cn
n (&#952;)E &#952; [c(&#966; k , d) + f i ] where 1 denotes an indicator function. At the top level, the gradient of the first term (the brevity
Formally, we must compute a sub-gradient at these points. In practice, we can choose between the gradients calculated assuming the indicator function is 0 or 1; we always choose the latter.</text>
        <paragraphs>
          <paragraph>
            <sentence>
              <text>CoBLEU takes a fundamental quantity used in consensus decoding, expected n-grams, and trains to optimize a function of those expectations.</text>
              <doc_id>329</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>While CoBLEU can therefore be expected to increase test set BLEU under consensus decoding, it is more surprising that it seems to better regularize learning even for the Viterbi decoding condition.</text>
              <doc_id>330</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>It is also worth emphasizing that the CoBLEU approach is applicable to functions of expected n- gram counts other than BLEU.</text>
              <doc_id>331</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>1425 Appendix: The Gradient of CoBLEU We would like to compute the gradient of</text>
              <doc_id>332</doc_id>
              <sec_id>3</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>of all n-grams or order n in all translations of the source corpus F , while Cn clip (&#952;) represents the sum of the same expected counts, but clipped with reference counts c(g n , r i ).</text>
              <doc_id>333</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>With this notation, we can write our objective function CoBLEU(R, F, &#952;) in three terms:</text>
              <doc_id>334</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>incoming and outgoing hyperedges of u, respectively.</text>
              <doc_id>335</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>We initialize with I(u) = 1 for all terminal forest nodes u and O(root) = 1 for the root node.</text>
              <doc_id>336</doc_id>
              <sec_id>1</sec_id>
            </sentence>
            <sentence>
              <text>These quantities are referenced in Figure 4.</text>
              <doc_id>337</doc_id>
              <sec_id>2</sec_id>
            </sentence>
            <sentence>
              <text>and the gradient &#8711;Cn</text>
              <doc_id>338</doc_id>
              <sec_id>3</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>n (&#952;)E &#952; [c(&#966; k , d) + f i ] where 1 denotes an indicator function.</text>
              <doc_id>339</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>At the top level, the gradient of the first term (the brevity</text>
              <doc_id>340</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
          <paragraph>
            <sentence>
              <text>Formally, we must compute a sub-gradient at these points.</text>
              <doc_id>341</doc_id>
              <sec_id>0</sec_id>
            </sentence>
            <sentence>
              <text>In practice, we can choose between the gradients calculated assuming the indicator function is 0 or 1; we always choose the latter.</text>
              <doc_id>342</doc_id>
              <sec_id>1</sec_id>
            </sentence>
          </paragraph>
        </paragraphs>
        <subsections/>
      </section>
    </sections>
    <tables>
      <table>
        <id>1</id>
        <source>TableSeer</source>
        <caption>Table 1: Performance measured by BLEU using a consensus decoding method over translation forests shows an improvement over MERT when using CoBLEU training. The first two conditions were initialized by 0 vectors. The third condition was initialized by the final parameters of MERT training. Br. indicates the brevity penalty on the test set. The * indicates differences which are not statistically significant.</caption>
        <reference_text>In PAGE 8: ... not outperform MERT in a statistically significant way, CoBLEU tends to find shorter sentences with higher n-gram precision than MERT.  Table1  displays a second benefit of CoBLEU training: compared to MERT training, CoBLEU performance degrades less from tuning to test set. In Spanish, initializing with MERT-trained weights and then training with CoBLEU actually decreases BLEU on the tuning set by 0....</reference_text>
        <page_num>8</page_num>
        <head>
          <rows>
            <row>
              <cell>Spanish</cell>
            </row>
          </rows>
        </head>
        <body>
          <rows>
            <row>
              <cell></cell>
              <cell>Tune</cell>
              <cell>Test</cell>
              <cell>&#8710;</cell>
              <cell>Br.</cell>
            </row>
            <row>
              <cell>MERT</cell>
              <cell>32.5</cell>
              <cell>30.2</cell>
              <cell>-2.3</cell>
              <cell>0.992</cell>
            </row>
            <row>
              <cell>CoBLEU</cell>
              <cell>31.4</cell>
              <cell>30.4</cell>
              <cell>-1.0</cell>
              <cell>0.992</cell>
            </row>
            <row>
              <cell>MERT&#8594;CoBLEU</cell>
              <cell>31.7</cell>
              <cell>30.8</cell>
              <cell>-0.9</cell>
              <cell>0.992</cell>
            </row>
            <row>
              <cell>French</cell>
            </row>
            <row>
              <cell></cell>
              <cell>Tune</cell>
              <cell>Test</cell>
              <cell>&#8710;</cell>
              <cell>Br.</cell>
            </row>
            <row>
              <cell>MERT</cell>
              <cell>32.5</cell>
              <cell>31.1*</cell>
              <cell>-1.4</cell>
              <cell>0.972</cell>
            </row>
            <row>
              <cell>CoBLEU</cell>
              <cell>31.9</cell>
              <cell>30.9</cell>
              <cell>-1.0</cell>
              <cell>0.954</cell>
            </row>
            <row>
              <cell>MERT&#8594;CoBLEU</cell>
              <cell>32.4</cell>
              <cell>31.2*</cell>
              <cell>-0.8</cell>
              <cell>0.953</cell>
            </row>
          </rows>
        </body>
      </table>
      <table>
        <id>2</id>
        <source>TableSeer</source>
        <caption>Table 2: Performance measured by BLEU using Viterbi decoding indicates that CoBLEU is less prone to overfitting than MERT.</caption>
        <reference_text>In PAGE 8: ... Surprisingly, we found that CoBLEU training actually outperformed MERT in Spanish- English and performed equally well in French- English.  Table2  shows the results. In these ex- periments, we again see that CoBLEU overfit the training set to a lesser degree than MERT, as evi- denced by a smaller drop in performance from tun- ing to test set....</reference_text>
        <page_num>8</page_num>
        <head>
          <rows>
            <row>
              <cell></cell>
              <cell></cell>
              <cell>Spanish</cell>
              <cell></cell>
            </row>
          </rows>
        </head>
        <body>
          <rows>
            <row>
              <cell></cell>
              <cell>Tune</cell>
              <cell>Test</cell>
              <cell>&#8710;</cell>
            </row>
            <row>
              <cell>MERT</cell>
              <cell>32.5</cell>
              <cell>30.2</cell>
              <cell>-2.3</cell>
            </row>
            <row>
              <cell>MERT&#8594;CoBLEU</cell>
              <cell>30.5</cell>
              <cell>30.9</cell>
              <cell>+0.4</cell>
            </row>
            <row>
              <cell></cell>
              <cell></cell>
              <cell>French</cell>
              <cell></cell>
            </row>
            <row>
              <cell></cell>
              <cell>Tune</cell>
              <cell>Test</cell>
              <cell>&#8710;</cell>
            </row>
            <row>
              <cell>MERT</cell>
              <cell>32.0</cell>
              <cell>31.0</cell>
              <cell>-1.0</cell>
            </row>
            <row>
              <cell>MERT&#8594;CoBLEU</cell>
              <cell>31.7</cell>
              <cell>30.9</cell>
              <cell>-0.8</cell>
            </row>
          </rows>
        </body>
      </table>
    </tables>
    <references>
      <reference>
        <id>0</id>
        <authors>
          <author>Phil Blunsom</author>
          <author>Miles Osborne</author>
        </authors>
        <title>Probabilistic inference for machine translation.</title>
        <publication>In Proceedings of the Conference on Emprical Methods for Natural Language Processing.</publication>
        <pages>None</pages>
        <date>2008</date>
      </reference>
      <reference>
        <id>1</id>
        <authors>
          <author>Colin Cherry</author>
          <author>Dekang Lin</author>
        </authors>
        <title>Inversion transduction grammar for joint phrasal translation modeling.</title>
        <publication>In The Annual Conference of the North American Chapter of the Association for Computational Linguistics Workshop on Syntax and Structure in Statistical Translation.</publication>
        <pages>None</pages>
        <date>2007</date>
      </reference>
      <reference>
        <id>2</id>
        <authors>
          <author>David Chiang</author>
          <author>Yuval Marton</author>
          <author>Philip Resnik</author>
        </authors>
        <title>Online large-margin training of syntactic and structural translation features.</title>
        <publication>In The Conference on Empirical Methods in Natural Language Processing.</publication>
        <pages>None</pages>
        <date>2008</date>
      </reference>
      <reference>
        <id>3</id>
        <authors>
          <author>David Chiang</author>
        </authors>
        <title>Hierarchical phrase-based translation. Computational Linguistics.</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>2007</date>
      </reference>
      <reference>
        <id>4</id>
        <authors>
          <author>John DeNero</author>
          <author>David Chiang</author>
          <author>Kevin Knight</author>
        </authors>
        <title>Fast consensus decoding over translation forests.</title>
        <publication>In The Annual Conference of the Association for Computational Linguistics.</publication>
        <pages>None</pages>
        <date>2009</date>
      </reference>
      <reference>
        <id>5</id>
        <authors>
          <author>Jason Eisner</author>
        </authors>
        <title>Parameter estimation for probabilistic finite-state transducers.</title>
        <publication>In Proceedings of the 40th Annual Meeting on Association for Computational Linguistics.</publication>
        <pages>None</pages>
        <date>2002</date>
      </reference>
      <reference>
        <id>6</id>
        <authors>
          <author>Liang Huang</author>
          <author>David Chiang</author>
        </authors>
        <title>Forest rescoring: Faster decoding with integrated language models.</title>
        <publication>In The Annual Conference of the Association for Computational Linguistics.</publication>
        <pages>None</pages>
        <date>2007</date>
      </reference>
      <reference>
        <id>7</id>
        <authors>
          <author>Sham Kakade</author>
          <author>Yee Whye Teh</author>
          <author>Sam T Roweis</author>
        </authors>
        <title>An alternate objective function for markovian fields.</title>
        <publication>In Proceedings of ICML.</publication>
        <pages>None</pages>
        <date>2002</date>
      </reference>
      <reference>
        <id>8</id>
        <authors>
          <author>Philipp Koehn</author>
          <author>Hieu Hoang</author>
          <author>Alexandra Birch</author>
          <author>Chris Callison-Burch</author>
          <author>Marcello Federico</author>
          <author>Nicola Bertoldi</author>
          <author>Brooke Cowan</author>
          <author>Wade Shen</author>
        </authors>
        <title>Moses: Open source toolkit for statistical machine translation.</title>
        <publication>In The Annual Conference of the Association for Computational Linguistics.</publication>
        <pages>None</pages>
        <date>2007</date>
      </reference>
      <reference>
        <id>9</id>
        <authors>
          <author>Philipp Koehn</author>
        </authors>
        <title>Europarl: A multilingual corpus for evaluation of machine translation.</title>
        <publication>None</publication>
        <pages>None</pages>
        <date>2002</date>
      </reference>
      <reference>
        <id>10</id>
        <authors>
          <author>Shankar Kumar</author>
          <author>Wolfgang Macherey</author>
          <author>Chris Dyer</author>
          <author>Franz Och</author>
        </authors>
        <title>Efficient minimum error rate training and minimum Bayes-risk decoding for translation hypergraphs and lattices.</title>
        <publication>In The Annual Conference of the Association for Computational Linguistics.</publication>
        <pages>None</pages>
        <date>2009</date>
      </reference>
      <reference>
        <id>11</id>
        <authors>
          <author>Zhifei Li</author>
          <author>Jason Eisner</author>
        </authors>
        <title>First- and secondorder expectation semirings with applications to minimum-risk training on translation forests.</title>
        <publication>In Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing.</publication>
        <pages>None</pages>
        <date>2009</date>
      </reference>
      <reference>
        <id>12</id>
        <authors>
          <author>Zhifei Li</author>
          <author>Jason Eisner</author>
          <author>Sanjeev Khudanpur</author>
        </authors>
        <title>Variational decoding for statistical machine translation.</title>
        <publication>In The Annual Conference of the Association for Computational Linguistics.</publication>
        <pages>None</pages>
        <date>2009</date>
      </reference>
      <reference>
        <id>13</id>
        <authors>
          <author>W Macherey</author>
          <author>F Och</author>
          <author>I Thayer</author>
          <author>J Uszkoreit</author>
        </authors>
        <title>Lattice-based minimum error rate training for statistical machine translation. In</title>
        <publication>In Proceedings of Empirical Methods in Natural Language Processing.</publication>
        <pages>None</pages>
        <date>2008</date>
      </reference>
      <reference>
        <id>14</id>
        <authors>
          <author>Franz Josef Och</author>
          <author>Hermann Ney</author>
        </authors>
        <title>A systematic comparison of various statistical alignment models.</title>
        <publication>None</publication>
        <pages>29--19</pages>
        <date>2003</date>
      </reference>
      <reference>
        <id>15</id>
        <authors>
          <author>Franz Josef Och</author>
        </authors>
        <title>Minimum error rate training in statistical machine translation.</title>
        <publication>In Proceedings of the 41st Annual Meeting on Association for Computational Linguistics (ACL),</publication>
        <pages>160--167</pages>
        <date>2003</date>
      </reference>
      <reference>
        <id>16</id>
        <authors>
          <author>Kishore Papineni</author>
          <author>Salim Roukos</author>
          <author>Todd Ward</author>
          <author>WeiJing Zhu</author>
        </authors>
        <title>BLEU: A method for automatic evaluation of machine translation.</title>
        <publication>In The Annual Conference of the Association for Computational Linguistics.</publication>
        <pages>None</pages>
        <date>2002</date>
      </reference>
      <reference>
        <id>17</id>
        <authors>
          <author>Slav Petrov</author>
          <author>Aria Haghighi</author>
          <author>Dan Klein</author>
        </authors>
        <title>Coarse-to-fine syntactic machine translation using language projections.</title>
        <publication>In Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing,</publication>
        <pages>108--116</pages>
        <date>2008</date>
      </reference>
      <reference>
        <id>18</id>
        <authors>
          <author>David Smith</author>
          <author>Jason Eisner</author>
        </authors>
        <title>Minimum risk annealing for training log-linear models. In</title>
        <publication>In Proceedings of the Association for Computational Linguistics.</publication>
        <pages>None</pages>
        <date>2006</date>
      </reference>
      <reference>
        <id>19</id>
        <authors>
          <author>Roy Tromble</author>
          <author>Shankar Kumar</author>
          <author>Franz Och</author>
          <author>Wolfgang Macherey</author>
        </authors>
        <title>Lattice minimum Bayes-risk decoding for statistical machine translation.</title>
        <publication>In The Conference on Empirical Methods in Natural Language Processing.</publication>
        <pages>None</pages>
        <date>2008</date>
      </reference>
    </references>
    <citations>
      <citation>
        <id>0</id>
        <reference_id>0</reference_id>
        <string>Blunsom and Osborne (2008)</string>
        <sentence_id>8391</sentence_id>
        <char_offset>14</char_offset>
      </citation>
      <citation>
        <id>1</id>
        <reference_id>1</reference_id>
        <string>Cherry and Lin, 2007</string>
        <sentence_id>8398</sentence_id>
        <char_offset>150</char_offset>
      </citation>
      <citation>
        <id>2</id>
        <reference_id>2</reference_id>
        <string>Chiang et al., 2008</string>
        <sentence_id>8132</sentence_id>
        <char_offset>180</char_offset>
      </citation>
      <citation>
        <id>3</id>
        <reference_id>3</reference_id>
        <string>Chiang (2007)</string>
        <sentence_id>8231</sentence_id>
        <char_offset>60</char_offset>
      </citation>
      <citation>
        <id>4</id>
        <reference_id>3</reference_id>
        <string>Chiang (2007)</string>
        <sentence_id>8269</sentence_id>
        <char_offset>99</char_offset>
      </citation>
      <citation>
        <id>5</id>
        <reference_id>3</reference_id>
        <string>Chiang (2007)</string>
        <sentence_id>8353</sentence_id>
        <char_offset>71</char_offset>
      </citation>
      <citation>
        <id>6</id>
        <reference_id>4</reference_id>
        <string>DeNero et al., 2009</string>
        <sentence_id>8121</sentence_id>
        <char_offset>195</char_offset>
      </citation>
      <citation>
        <id>7</id>
        <reference_id>4</reference_id>
        <string>DeNero et al., 2009</string>
        <sentence_id>8270</sentence_id>
        <char_offset>61</char_offset>
      </citation>
      <citation>
        <id>8</id>
        <reference_id>4</reference_id>
        <string>DeNero et al. (2009)</string>
        <sentence_id>8126</sentence_id>
        <char_offset>176</char_offset>
      </citation>
      <citation>
        <id>9</id>
        <reference_id>4</reference_id>
        <string>DeNero et al. (2009)</string>
        <sentence_id>8381</sentence_id>
        <char_offset>65</char_offset>
      </citation>
      <citation>
        <id>10</id>
        <reference_id>4</reference_id>
        <string>DeNero et al. (2009)</string>
        <sentence_id>8423</sentence_id>
        <char_offset>110</char_offset>
      </citation>
      <citation>
        <id>11</id>
        <reference_id>5</reference_id>
        <string>Eisner (2002)</string>
        <sentence_id>8356</sentence_id>
        <char_offset>97</char_offset>
      </citation>
      <citation>
        <id>12</id>
        <reference_id>5</reference_id>
        <string>Eisner (2002)</string>
        <sentence_id>8357</sentence_id>
        <char_offset>67</char_offset>
      </citation>
      <citation>
        <id>13</id>
        <reference_id>6</reference_id>
        <string>Huang and Chiang (2007)</string>
        <sentence_id>8231</sentence_id>
        <char_offset>50</char_offset>
      </citation>
      <citation>
        <id>14</id>
        <reference_id>6</reference_id>
        <string>Huang and Chiang (2007)</string>
        <sentence_id>8353</sentence_id>
        <char_offset>61</char_offset>
      </citation>
      <citation>
        <id>15</id>
        <reference_id>7</reference_id>
        <string>Kakade et al. (2002)</string>
        <sentence_id>8358</sentence_id>
        <char_offset>26</char_offset>
      </citation>
      <citation>
        <id>16</id>
        <reference_id>8</reference_id>
        <string>Koehn et al., 2007</string>
        <sentence_id>8399</sentence_id>
        <char_offset>107</char_offset>
      </citation>
      <citation>
        <id>17</id>
        <reference_id>9</reference_id>
        <string>Koehn, 2002</string>
        <sentence_id>8402</sentence_id>
        <char_offset>193</char_offset>
      </citation>
      <citation>
        <id>18</id>
        <reference_id>10</reference_id>
        <string>Kumar et al., 2009</string>
        <sentence_id>8121</sentence_id>
        <char_offset>233</char_offset>
      </citation>
      <citation>
        <id>19</id>
        <reference_id>11</reference_id>
        <string>Li and Eisner (2009)</string>
        <sentence_id>8357</sentence_id>
        <char_offset>29</char_offset>
      </citation>
      <citation>
        <id>20</id>
        <reference_id>12</reference_id>
        <string>Li et al. (2009)</string>
        <sentence_id>8392</sentence_id>
        <char_offset>0</char_offset>
      </citation>
      <citation>
        <id>21</id>
        <reference_id>12</reference_id>
        <string>Li et al., 2009</string>
        <sentence_id>8121</sentence_id>
        <char_offset>216</char_offset>
      </citation>
      <citation>
        <id>22</id>
        <reference_id>12</reference_id>
        <string>Li et al., 2009</string>
        <sentence_id>8270</sentence_id>
        <char_offset>82</char_offset>
      </citation>
      <citation>
        <id>23</id>
        <reference_id>13</reference_id>
        <string>Macherey et al., 2008</string>
        <sentence_id>8132</sentence_id>
        <char_offset>130</char_offset>
      </citation>
      <citation>
        <id>24</id>
        <reference_id>13</reference_id>
        <string>Macherey et al., 2008</string>
        <sentence_id>8419</sentence_id>
        <char_offset>69</char_offset>
      </citation>
      <citation>
        <id>25</id>
        <reference_id>14</reference_id>
        <string>Och and Ney, 2003</string>
        <sentence_id>8400</sentence_id>
        <char_offset>108</char_offset>
      </citation>
      <citation>
        <id>26</id>
        <reference_id>15</reference_id>
        <string>Och, 2003</string>
        <sentence_id>8123</sentence_id>
        <char_offset>179</char_offset>
      </citation>
      <citation>
        <id>27</id>
        <reference_id>16</reference_id>
        <string>Papineni et al., 2002</string>
        <sentence_id>8229</sentence_id>
        <char_offset>122</char_offset>
      </citation>
      <citation>
        <id>28</id>
        <reference_id>17</reference_id>
        <string>Petrov et al., 2008</string>
        <sentence_id>8399</sentence_id>
        <char_offset>161</char_offset>
      </citation>
      <citation>
        <id>29</id>
        <reference_id>18</reference_id>
        <string>Smith and Eisner, 2006</string>
        <sentence_id>8429</sentence_id>
        <char_offset>68</char_offset>
      </citation>
      <citation>
        <id>30</id>
        <reference_id>19</reference_id>
        <string>Tromble et al. (2008)</string>
        <sentence_id>8393</sentence_id>
        <char_offset>0</char_offset>
      </citation>
      <citation>
        <id>31</id>
        <reference_id>19</reference_id>
        <string>Tromble et al., 2008</string>
        <sentence_id>8121</sentence_id>
        <char_offset>173</char_offset>
      </citation>
    </citations>
  </content>
</document>
