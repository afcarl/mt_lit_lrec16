<PAPER>
  <FILENO/>
  <TITLE>Hierarchical Phrase-Based Translation with Weighted Finite State Transducers</TITLE>
  <AUTHORS/>
  <ABSTRACT>
    <A-S ID="S-3509">This paper describes a lattice-based decoder for hierarchical phrase-based translation.</A-S>
    <A-S ID="S-3510">The decoder is implemented with standard WFST operations as an alternative to the well-known cube pruning procedure.</A-S>
    <A-S ID="S-3511">We find that the use of WFSTs rather than k-best lists requires less pruning in translation search, resulting in fewer search errors, direct generation of translation lattices in the target language, better parameter optimization, and improved translation performance when rescoring with long-span language models and MBR decoding.</A-S>
    <A-S ID="S-3512">We report translation experiments for the Arabic-to-English and Chinese-to-English NIST translation tasks and contrast the WFSTbased hierarchical decoder with hierarchical translation under cube pruning.</A-S>
  </ABSTRACT>
  <BODY>
    <DIV DEPTH="0">
      <HEADER>1 Introduction</HEADER>
      <P>
        <S ID="S-3529">Hierarchical phrase-based translation generates translation hypotheses via the application of hierarchical rules in CYK parsing (<REF ID="R-09" RPTR="16">Chiang, 2005</REF>).</S>
        <S ID="S-3530">Cube pruning is used to apply language models at each cell of the CYK grid as part of the search for a k-best list of translation candidates (<REF ID="R-09" RPTR="17">Chiang, 2005</REF>; <REF ID="R-10" RPTR="22">Chiang, 2007</REF>).</S>
        <S ID="S-3531">While this approach is very effective and has been shown to produce very good quality translation, the reliance on k-best lists is a limitation.</S>
        <S ID="S-3532">We take an alternative approach and describe a lattice-based hierarchical decoder implemented with Weighted Finite State Transducers (WFSTs).</S>
        <S ID="S-3533">In every CYK cell we build a single, minimal word lattice containing all possible translations of the source sentence span covered by that cell.</S>
        <S ID="S-3534">When derivations contain non-terminals, we use pointers to lowerlevel lattices for memory efficiency.</S>
        <S ID="S-3535">The pointers are only expanded to the actual translations if pruning is required during search; expansion is otherwise only carried out at the upper-most cell, after the full CYK grid has been traversed.</S>
      </P>
      <P>
        <S ID="S-3536">We describe how this decoder can be easily implemented with WFSTs.</S>
        <S ID="S-3537">For this we employ the OpenFST libraries (<REF ID="R-01" RPTR="1">Allauzen et al., 2007</REF>).</S>
        <S ID="S-3538">Using standard FST operations such as composition, epsilon removal, determinization, minimization and shortest-path, we find this search procedure to be simpler to implement than cube pruning.</S>
        <S ID="S-3539">The main modeling advantages are a significant reduction in search errors, a simpler implementation, direct generation of target language word lattices, and better integration with other statistical MT procedures.</S>
        <S ID="S-3540">We report translation results in Arabic-to-English and Chinese-to-English translation and contrast the performance of lattice-based and cube pruning hierarchical decoding.</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>1.1 Related Work</HEADER>
        <P>
          <S ID="S-3513">Hierarchical phrase-based translation has emerged as one of the dominant current approaches to statistical machine translation.</S>
          <S ID="S-3514">Hiero translation systems incorporate many of the strengths of phrase-based translation systems, such as feature-based translation and strong target language models, while also allowing flexible translation and movement based on hierarchical rules extracted from aligned parallel text.</S>
          <S ID="S-3515">We summarize some extensions to the basic approach to put our work in context.</S>
        </P>
        <P>
          <S ID="S-3516">Human Language Technologies: The 2009 Annual Conference of the North American Chapter of the ACL, pages 433&#8211;441, Boulder, Colorado, June 2009. c&#9675;2009 Association for Computational Linguistics</S>
        </P>
        <P>
          <S ID="S-3517">Hiero Search Refinements <REF ID="R-13" RPTR="25">Huang and Chiang (2007)</REF><REF ID="R-10" RPTR="18">Chiang (2007)</REF> offer several refinements to cube pruning to improve translation speed.</S>
          <S ID="S-3518"><REF ID="R-30" RPTR="40">Venugopal et al. (2007)</REF> introduce a Hiero variant with relaxed constraints for hypothesis recombination during parsing; speed and results are comparable to those of cube pruning, as described by <REF ID="R-10" RPTR="19">Chiang (2007)</REF>.</S>
          <S ID="S-3519"><REF ID="R-17" RPTR="28">Li and Khudanpur (2008)</REF> report significant improvements in translation speed by taking unseen n-grams into account within cube pruning to minimize language model requests.</S>
          <S ID="S-3520"><REF ID="R-11" RPTR="23">Dyer et al. (2008)</REF> extend the translation of source sentences to translation of input lattices following <REF ID="R-08" RPTR="12">Chappelier et al. (1999)</REF>.</S>
        </P>
        <P>
          <S ID="S-3521">Extensions to Hiero Several authors describe extensions to Hiero, to incorporate additional syntactic information (<REF ID="R-32" RPTR="42">Zollmann and Venugopal, 2006</REF>; <REF ID="R-31" RPTR="41">Zhang and Gildea, 2006</REF>; <REF ID="R-26" RPTR="36">Shen et al., 2008</REF>; <REF ID="R-19" RPTR="30">Marton and Resnik, 2008</REF>), or to combine it with discriminative latent models (<REF ID="R-04" RPTR="8">Blunsom et al., 2008</REF>).</S>
        </P>
        <P>
          <S ID="S-3522">Analysis and Contrastive Experiments Zollman et al. (2008) compare phrase-based, hierarchical and syntax-augmented decoders for translation of Arabic, Chinese, and Urdu into English.</S>
          <S ID="S-3523"><REF ID="R-18" RPTR="29">Lopez (2008)</REF> explores whether lexical reordering or the phrase discontiguity inherent in hierarchical rules explains improvements over phrase-based systems.</S>
          <S ID="S-3524">Hierarchical translation has also been used to great effect in combination with other translation architectures, e.g. (<REF ID="R-27" RPTR="37">Sim et al., 2007</REF>; <REF ID="R-25" RPTR="35">Rosti et al., 2007</REF>).</S>
        </P>
        <P>
          <S ID="S-3525">WFSTs for Translation There is extensive work in using Weighted Finite State Transducer for machine translation (<REF ID="R-02" RPTR="6">Bangalore and Riccardi, 2001</REF>; <REF ID="R-06" RPTR="10">Casacuberta, 2001</REF>; <REF ID="R-16" RPTR="27">Kumar and Byrne, 2005</REF>; <REF ID="R-20" RPTR="31">Mathias and Byrne, 2006</REF>; <REF ID="R-12" RPTR="24">Graehl et al., 2008</REF>).</S>
        </P>
        <P>
          <S ID="S-3526">To our knowledge, this paper presents the first description of hierarchical phrase-based translation in terms of lattices rather than k-best lists.</S>
          <S ID="S-3527">The next section describes hierarchical phrase-based translation with WFSTs, including the lattice construction over the CYK grid and pruning strategies.</S>
          <S ID="S-3528">Section 3 reports translation experiments for Arabic-to- English and Chinese-to-English, and Section 4 concludes.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>2 Hierarchical Translation with WFSTs</HEADER>
      <P>
        <S ID="S-3640">The translation system is based on a variant of the CYK algorithm closely related to CYK+ (<REF ID="R-07" RPTR="11">Chappelier and Rajman, 1998</REF>).</S>
        <S ID="S-3641">Parsing follows the description of <REF ID="R-09" RPTR="13">Chiang (2005</REF>; 2007), maintaining backpointers and employing hypothesis recombination without pruning.</S>
        <S ID="S-3642">The underlying model is a synchronous context-free grammar consisting of a set R = {R r } of rules R r : N &#8594; &#12296;&#947; r ,&#945; r &#12297; / p r , with &#8216;glue&#8217; rules, S &#8594; &#12296;X,X&#12297; and S &#8594; &#12296;S X,S X&#12297;.</S>
        <S ID="S-3643">If a rule has probability p r , it is transformed to a cost c r ; here we use the tropical semiring, so c r = &#8722; log p r .</S>
        <S ID="S-3644">N denotes a non-terminal; in this paper, N can be either S, X, or V (see section 3.2).</S>
        <S ID="S-3645">T denotes the terminals (words), and the grammar builds parses based on strings &#947;, &#945; &#8712; {{S, X, V } &#8746; T} + .</S>
        <S ID="S-3646">Each cell in the CYK grid is specified by a non-terminal symbol and position in the CYK grid: (N, x, y), which spans sx x+y&#8722;1 on the source sentence.</S>
      </P>
      <P>
        <S ID="S-3647">In effect, the source language sentence is parsed using a context-free grammar with rules N &#8594; &#947;.</S>
        <S ID="S-3648">The generation of translations is a second step that follows parsing.</S>
        <S ID="S-3649">For this second step, we describe a method to construct word lattices with all possible translations that can be produced by the hierarchical rules.</S>
        <S ID="S-3650">Construction proceeds by traversing the CYK grid along the backpointers established in parsing.</S>
        <S ID="S-3651">In each cell (N, x, y) in the CYK grid, we build a target language word lattice L(N, x, y).</S>
        <S ID="S-3652">This lattice contains every translation of sx x+y&#8722;1 from every derivation headed by N.</S>
        <S ID="S-3653">These lattices also contain the translation scores on their arc weights.</S>
      </P>
      <P>
        <S ID="S-3654">The ultimate objective is the word lattice L(S, 1, J) which corresponds to all the analyses that cover the source sentence s J 1 .</S>
        <S ID="S-3655">Once this is built, we can apply a target language model to L(S, 1, J) to obtain the final target language translation lattice (<REF ID="R-00" RPTR="0">Allauzen et al., 2003</REF>).</S>
      </P>
      <P>
        <S ID="S-3656">We use the approach of Mohri (2002) in applying WFSTs to statistical NLP.</S>
        <S ID="S-3657">This fits well with the use of the OpenFST toolkit (<REF ID="R-01" RPTR="2">Allauzen et al., 2007</REF>) to implement our decoder.</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>2.1 Lattice Construction Over the CYK Grid</HEADER>
        <P>
          <S ID="S-3541">In each cell (N, x, y), the set of rule indices used by the parser is denoted R(N, x, y), i.e. for r &#8712; R(N, x, y), N &#8594; &#12296;&#947; r ,&#945; r &#12297; was used in at least one derivation involving that cell.</S>
        </P>
        <P>
          <S ID="S-3542">For each rule R r , r &#8712; R(N, x, y), we build a lattice L(N, x, y, r).</S>
          <S ID="S-3543">This lattice is derived from the target side of the rule &#945; r by concatenating lattices</S>
        </P>
        <P>
          <S ID="S-3544">R 1 : X &#8594; &#12296;s 1 s 2 s 3,t 1 t 2&#12297; R 2 : X &#8594; &#12296;s 1 s 2,t 7 t 8&#12297; R 3 : X &#8594; &#12296;s 3,t 9&#12297; R 4 : S &#8594; &#12296;X,X&#12297; R 5 : S &#8594; &#12296;S X,S X&#12297;</S>
        </P>
        <P>
          <S ID="S-3545">L(S, 1, 3) = L(S, 1, 3, 4) &#8853; L(S, 1, 3, 5) L(S, 1, 3, 4) = L(X, 1, 3) = L(X, 1, 3, 1) = = A(t 1) &#8855; A(t 2)</S>
        </P>
        <P>
          <S ID="S-3546">L(S, 1, 3, 5) = L(S, 1, 2) &#8855; L(X, 3, 1) L(S, 1, 2) = L(S, 1, 2, 4) = L(X, 1, 2) = = L(X, 1, 2, 2) = A(t 7) &#8855; A(t 8)</S>
        </P>
        <P>
          <S ID="S-3547">L(X, 3, 1) = L(X, 3, 1, 3) = A(t 9) L(S, 1, 3, 5) = A(t 7) &#8855; A(t 8) &#8855; A(t 9)</S>
        </P>
        <P>
          <S ID="S-3548">L(S, 1, 3) = (A(t 1) &#8855; A(t 2)) &#8853; (A(t 7) &#8855; A(t 8) &#8855; A(t 9))</S>
        </P>
        <P>
          <S ID="S-3549">corresponding to the elements of &#945; r = &#945; r 1 ...&#945;r |&#945; r | .</S>
          <S ID="S-3550">If an &#945; r i is a terminal, creating its lattice is straightforward.</S>
          <S ID="S-3551">If &#945; r i is a non-terminal, it refers to a cell (N &#8242; , x &#8242; , y &#8242; ) lower in the grid identified by the backpointer BP (N, x, y, r, i); in this case, the lattice used is L(N &#8242; , x &#8242; , y &#8242; ).</S>
          <S ID="S-3552">Taken together,</S>
        </P>
        <P>
          <S ID="S-3553">L(N, x, y, r) = &#8855;</S>
        </P>
        <P>
          <S ID="S-3554">i=1..|&#945; r |</S>
        </P>
        <P>
          <S ID="S-3555">L(N, x, y, r, i) (1)</S>
        </P>
        <P>
          <S ID="S-3556">{ A(&#945;</S>
        </P>
        <P>
          <S ID="S-3557">L(N, x, y, r, i) = i ) if &#945; i &#8712; T L(N &#8242; , x &#8242; , y &#8242; ) else (2) where A(t), t &#8712; T returns a single-arc acceptor which accepts only the symbol t.</S>
          <S ID="S-3558">The lattice L(N, x, y) is then built as the union of lattices corresponding to the rules in R(N, x, y):</S>
        </P>
        <P>
          <S ID="S-3559">L(N, x, y) = &#8853;</S>
        </P>
        <P>
          <S ID="S-3560">r&#8712;R(N,x,y)</S>
        </P>
        <P>
          <S ID="S-3561">L(N, x, y, r) (3)</S>
        </P>
        <P>
          <S ID="S-3562">Lattice union and concatenation are performed using the &#8853; and &#8855; WFST operations respectively, as described by Allauzen et al.(2007).</S>
          <S ID="S-3563">If a rule R r has a cost c r , it is applied to the exit state of the lattice L(N, x, y, r) prior to the operation of Equation 3.</S>
        </P>
        <P>
          <S ID="S-3564">2.1.1 An Example of Phrase-based Translation</S>
        </P>
        <P>
          <S ID="S-3565">Figure 1 illustrates this process for a three word source sentence s 1 s 2 s 3 under monotone phrasebased translation.</S>
          <S ID="S-3566">The left-hand side shows the state of the CYK grid after parsing using the rules R 1 to R 5 .</S>
          <S ID="S-3567">These include 3 rules with only terminals (R 1 , R 2 , R 3 ) and the glue rules (R 4 , R 5 ).</S>
          <S ID="S-3568">Arrows represent backpointers to lower-level cells.</S>
          <S ID="S-3569">We are interested in the upper-most S cell (S, 1, 3), as it represents the search space of translation hypotheses covering the whole source sentence.</S>
          <S ID="S-3570">Two rules (R 4 , R 5 ) are in this cell, so the lattice L(S, 1, 3) will be obtained by the union of the two lattices found by the backpointers of these two rules.</S>
          <S ID="S-3571">This process is explicitly derived in the right-hand side of Figure 1.</S>
        </P>
        <P>
          <S ID="S-3572">2.1.2 An Example of Hierarchical Translation</S>
        </P>
        <P>
          <S ID="S-3573">Figure 2 shows a hierarchical scenario for the same sentence.</S>
          <S ID="S-3574">Three rules, R 6 , R 7 , R 8 , are added to the example of Figure 1, thus providing two additional derivations.</S>
          <S ID="S-3575">This makes use of sublattices already produced in the creation of L(S, 1, 3, 5) and L(X, 1, 3, 1) in Figure 1; these are within {}.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>2.2 A Procedure for Lattice Construction</HEADER>
        <P>
          <S ID="S-3576">Figure 3 presents an algorithm to build the lattice for every cell.</S>
          <S ID="S-3577">The algorithm uses memoization: if a lattice for a requested cell already exists, it is returned (line 2); otherwise it is constructed via equations 1,2,3.</S>
          <S ID="S-3578">For every rule, each element of the target side (lines 3,4) is checked as terminal or nonterminal (equation 2).</S>
          <S ID="S-3579">If it is a terminal element (line 5), a simple acceptor is built.</S>
          <S ID="S-3580">If it is a nonterminal (line 6), the lattice associated to its backpointer is returned (lines 7 and 8).</S>
          <S ID="S-3581">The complete lattice L(N, x, y, r) for each rule is built by equation 1 (line 9).</S>
          <S ID="S-3582">The lattice L(N, x, y) for this cell is then found by union of all the component rules (line 10, equation 3); this lattice is then reduced by</S>
        </P>
        <P>
          <S ID="S-3583">R 6 : X &#8594; &#12296;s 1,t 20&#12297; R 7 : X &#8594; &#12296;X 1 s 2 X 2,X 1 t 10 X 2&#12297; R 8 : X &#8594; &#12296;X 1 s 2 X 2,X 2 t 10 X 1&#12297; L(S, 1, 3) = L(S, 1, 3, 4) &#8853;{L(S, 1, 3, 5)}</S>
        </P>
        <P>
          <S ID="S-3584">L(S, 1, 3, 4) = L(X, 1, 3) = ={L(X, 1, 3, 1)} &#8853;L(X, 1, 3, 7) &#8853; L(X, 1, 3, 8)</S>
        </P>
        <P>
          <S ID="S-3585">L(X, 1, 3, 7) = L(X, 1, 1, 6) &#8855; A(t 10) &#8855; L(X, 3, 1, 3) = = A(t 20) &#8855; A(t 10) &#8855; A(t 9)</S>
        </P>
        <P>
          <S ID="S-3586">L(X, 1, 3, 8) = A(t 9) &#8855; A(t 10) &#8855; A(t 20)</S>
        </P>
        <P>
          <S ID="S-3587">L(S, 1, 3) = {(A(t 1) &#8855; A(t 2))} &#8853; &#8853;(A(t 20) &#8855; A(t 10) &#8855; A(t 9)) &#8853; (A(t 9) &#8855; A(t 10) &#8855; A(t 20))&#8853; &#8853;{(A(t 7) &#8855; A(t 8) &#8855; A(t 9))}</S>
        </P>
        <P>
          <S ID="S-3588">standard WFST operations (lines 11,12,13).</S>
          <S ID="S-3589">It is important at this point to remove any epsilon arcs which may have been introduced by the various WFST union, concatenation, and replacement operations (<REF ID="R-01" RPTR="3">Allauzen et al., 2007</REF>).</S>
        </P>
        <P>
          <S ID="S-3590">1 function buildFst(N,x,y) 2 if &#8707; L(N, x, y) return L(N, x, y) 3 for r &#8712; R(N, x, y), R r : N &#8594; &#12296;&#947;,&#945;&#12297; 4 for i = 1...|&#945;| 5 if &#945; i &#8712; T, L(N, x, y, r, i) = A(&#945; i ) 6 else 7 (N &#8242; , x &#8242; , y &#8242; ) = BP (&#945; i ) 8 L(N, x, y, r, i) = buildFst(N &#8242; , x &#8242; , y &#8242; ) 9 L(N, x, y, r)= &#8855; i=1..|&#945;| L(N, x, y, r, i) 10 L(N, x, y) = &#8853; r&#8712;R(N,x,y) L(N, x, y, r) 11 fstRmEpsilon L(N, x, y) 12 fstDeterminize L(N, x, y) 13 fstMinimize L(N, x, y) 14 return L(N, x, y)</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>2.3 Delayed Translation</HEADER>
        <P>
          <S ID="S-3591">Equation 2 leads to the recursive construction of lattices in upper-levels of the grid through the union and concatenation of lattices from lower levels.</S>
          <S ID="S-3592">If equations 1 and 3 are actually carried out over fully expanded word lattices, the memory required by the upper lattices will increase exponentially.</S>
        </P>
        <P>
          <S ID="S-3593">To avoid this, we use special arcs that serve as pointers to the low-level lattices.</S>
          <S ID="S-3594">This effectively builds a skeleton of the desired lattice and delays the creation of the final word lattice until a single replacement operation is carried out in the top cell (S, 1, J).</S>
          <S ID="S-3595">To make this exact, we define a function g(N, x, y) which returns a unique tag for each lattice in each cell, and use it to redefine equation 2.</S>
          <S ID="S-3596">With the backpointer (N &#8242; , x &#8242; , y &#8242; ) = BP (N, x, y, r, i), these special arcs are introduced as:</S>
        </P>
        <P>
          <S ID="S-3597">{ A(&#945; L(N, x, y, r, i) = i ) if &#945; i &#8712; T A(g(N &#8242; , x &#8242; , y &#8242; )) else (4)</S>
        </P>
        <P>
          <S ID="S-3598">The resulting lattices L(N, x, y) are a mix of target language words and lattice pointers (Figure 4, top).</S>
          <S ID="S-3599">However each still represents the entire search space of all translation hypotheses covering the span.</S>
          <S ID="S-3600">Importantly, operations on these lattices &#8211; such as lossless size reduction via determinization and minimization &#8211; can still be performed.</S>
          <S ID="S-3601">Owing to the existence of multiple hierarchical rules which share the same low-level dependencies, these operations can greatly reduce the size of the skeleton lattice; Figure 4 shows the effect on the translation example.</S>
          <S ID="S-3602">This process is carried out for the lattice at every cell, even at the lowest level where there are only sequences of word terminals.</S>
          <S ID="S-3603">As stated, size reductions can be significant.</S>
          <S ID="S-3604">However not all redudancy is removed, since duplicate paths may arise through the concatenation and union of sublattices with different spans.</S>
        </P>
        <P>
          <S ID="S-3605">At the upper-most cell, the lattice L(S, 1, J) contains pointers to lower-level lattices.</S>
          <S ID="S-3606">A single FST replace operation (<REF ID="R-01" RPTR="4">Allauzen et al., 2007</REF>) recursively substitutes all pointers by their lower-level lattices until no pointers are left, thus producing the complete target word lattice for the whole source sentence.</S>
          <S ID="S-3607">The use of the lattice pointer arc was inspired by the &#8216;lazy evaluation&#8217; techniques developed by <REF ID="R-21" RPTR="32">Mohri et al (2000)</REF>.</S>
          <S ID="S-3608">Its implementation uses the infrastructure provided by the OpenFST libraries for</S>
        </P>
        <P>
          <S ID="S-3609">0</S>
        </P>
        <P>
          <S ID="S-3610">0</S>
        </P>
        <P>
          <S ID="S-3611">t1</S>
        </P>
        <P>
          <S ID="S-3612">g(X,1,2)</S>
        </P>
        <P>
          <S ID="S-3613">g(X,1,1)</S>
        </P>
        <P>
          <S ID="S-3614">g(X,3,1)</S>
        </P>
        <P>
          <S ID="S-3615">g(X,1,1)</S>
        </P>
        <P>
          <S ID="S-3616">t1</S>
        </P>
        <P>
          <S ID="S-3617">g(X,3,1)</S>
        </P>
        <P>
          <S ID="S-3618">g(X,1,2)</S>
        </P>
        <P>
          <S ID="S-3619">t10</S>
        </P>
        <P>
          <S ID="S-3620">t10</S>
        </P>
        <P>
          <S ID="S-3621">t10</S>
        </P>
        <P>
          <S ID="S-3622">t10</S>
        </P>
        <P>
          <S ID="S-3623">t2</S>
        </P>
        <P>
          <S ID="S-3624">g(X,3,1)</S>
        </P>
        <P>
          <S ID="S-3625">t2</S>
        </P>
        <P>
          <S ID="S-3626">g(X,3,1)</S>
        </P>
        <P>
          <S ID="S-3627">g(X,1,1)</S>
        </P>
        <P>
          <S ID="S-3628">g(X,3,1)</S>
        </P>
        <P>
          <S ID="S-3629">g(X,1,1)</S>
        </P>
        <P>
          <S ID="S-3630">delayed composition, etc.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>2.4 Pruning in Lattice Construction</HEADER>
        <P>
          <S ID="S-3631">The final translation lattice L(S, 1, J) can grow very large after the pointer arcs are expanded.</S>
          <S ID="S-3632">We therefore apply a word-based language model, via WFST composition, and perform likelihood-based pruning (<REF ID="R-01" RPTR="5">Allauzen et al., 2007</REF>) based on the combined translation and language model scores.</S>
        </P>
        <P>
          <S ID="S-3633">Pruning can also be performed on sublattices during search.</S>
          <S ID="S-3634">One simple strategy is to monitor the number of states in the determinized lattices L(N, x, y).</S>
          <S ID="S-3635">If this number is above a threshold, we expand any pointer arcs and apply a word-based language model via composition.</S>
          <S ID="S-3636">The resulting lattice is then reduced by likelihood-based pruning, after which the LM scores are removed.</S>
          <S ID="S-3637">This search pruning can be very selective.</S>
          <S ID="S-3638">For example, the pruning threshold can depend on the height of the cell in the grid.</S>
          <S ID="S-3639">In this way the risk of search errors can be controlled.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>3 Translation Experiments</HEADER>
      <P>
        <S ID="S-3716">We report experiments on the NIST MT08 Arabicto-English and Chinese-to-English translation tasks.</S>
        <S ID="S-3717">We contrast two hierarchical phrase-based decoders.</S>
        <S ID="S-3718">The first decoder, Hiero Cube Pruning (HCP), is a k-</S>
      </P>
      <P>
        <S ID="S-3719">best decoder using cube pruning implemented as described by <REF ID="R-10" RPTR="20">Chiang (2007)</REF>.</S>
        <S ID="S-3720">In our implementation, k- best lists contain unique hypotheses.</S>
        <S ID="S-3721">The second decoder, Hiero FST (HiFST), is a lattice-based decoder implemented with Weighted Finite State Transducers as described in the previous section.</S>
        <S ID="S-3722">Hypotheses are generated after determinization under the tropical semiring so that scores assigned to hypotheses arise from single minimum cost / maximum likelihood derivations.</S>
        <S ID="S-3723">We also use a variant of the k-best decoder which works in alignment mode: given an input k-best list, it outputs the feature scores of each hypothesis in the list without applying any pruning.</S>
        <S ID="S-3724">This is used for Minimum Error Training (MET) with the HiFST system.</S>
      </P>
      <P>
        <S ID="S-3725">These two language pairs pose very different translation challenges.</S>
        <S ID="S-3726">For example, Chineseto-English translation requires much greater word movement than Arabic-to-English.</S>
        <S ID="S-3727">In the framework of hierarchical translation systems, we have found that shallow decoding (see section 3.2) is as good as full hierarchical decoding in Arabicto-English (Iglesias et al., 2009).</S>
        <S ID="S-3728">In Chinese-to- English, we have not found this to be the case.</S>
        <S ID="S-3729">Therefore, we contrast the performance of HiFST and HCP under shallow hierarchical decoding for Arabic-to-English, while for Chinese-to-English we perform full hierarchical decoding.</S>
      </P>
      <P>
        <S ID="S-3730">Both hierarchical translation systems share a common architecture.</S>
        <S ID="S-3731">For both language pairs, alignments are generated over the parallel data.</S>
        <S ID="S-3732">The following features are extracted and used in translation: target language model, source-to-target and target-to-source phrase translation models, word and rule penalties, number of usages of the glue rule, source-to-target and target-to-source lexical models, and three rule count features inspired by <REF ID="R-03" RPTR="7">Bender et al. (2007)</REF>.</S>
        <S ID="S-3733">The initial English language model is a 4-gram estimated over the parallel text and a 965 million word subset of monolingual data from the English Gigaword Third Edition.</S>
        <S ID="S-3734">Details of the parallel corpus and development sets used for each language pair are given in their respective section.</S>
        <S ID="S-3735">Standard MET (<REF ID="R-23" RPTR="33">Och, 2003</REF>) iterative parameter estimation under IBM BLEU (<REF ID="R-24" RPTR="34">Papineni et al., 2001</REF>) is performed on the corresponding development set.</S>
        <S ID="S-3736">For the HCP system, MET is done following <REF ID="R-10" RPTR="21">Chiang (2007)</REF>.</S>
        <S ID="S-3737">For the HiFST system, we obtain a k-</S>
      </P>
      <P>
        <S ID="S-3738">best list from the translation lattice and extract each feature score with the aligner variant of the k-best decoder.</S>
        <S ID="S-3739">After translation with optimized feature weights, we carry out the two following rescoring steps.</S>
      </P>
      <P>
        <S ID="S-3740">&#8226; Large-LM rescoring.</S>
        <S ID="S-3741">We build sentencespecific zero-cutoff stupid-backoff (<REF ID="R-05" RPTR="9">Brants et al., 2007</REF>) 5-gram language models, estimated using &#8764;4.7B words of English newswire text, and apply them to rescore either 10000-best lists generated by HCP or word lattices generated by HiFST.</S>
        <S ID="S-3742">Lattices provide a vast search space relative to k-best lists, with translation lattice sizes of 10 81 hypotheses reported in the literature (<REF ID="R-29" RPTR="39">Tromble et al., 2008</REF>).</S>
      </P>
      <P>
        <S ID="S-3743">&#8226; Minimum Bayes Risk (MBR).</S>
        <S ID="S-3744">We rescore the first 1000-best hypotheses with MBR, taking the negative sentence level BLEU score as the loss function (<REF ID="R-15" RPTR="26">Kumar and Byrne, 2004</REF>).</S>
      </P>
      <DIV DEPTH="1">
        <HEADER>3.1 Building the Rule Sets</HEADER>
        <P>
          <S ID="S-3658">We extract hierarchical phrases from word alignments, applying the same restrictions as introduced by <REF ID="R-09" RPTR="14">Chiang (2005</REF><REF ID="R-09" RPTR="15">Chiang (2005)</REF>.</S>
          <S ID="S-3659">Additionally, following Iglesias et al. (2009) we carry out two rule filtering strategies:</S>
        </P>
        <P>
          <S ID="S-3660">&#8226; we exclude rules with two non-terminals with the same order on the source and target side</S>
        </P>
        <P>
          <S ID="S-3661">&#8226; we consider only the 20 most frequent translations for each rule</S>
        </P>
        <P>
          <S ID="S-3662">For each development set, this produces approximately 4.3M rules in Arabic-to-English and 2.0M rules in Chinese-to-English.</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.2 Arabic-to-English Translation</HEADER>
        <P>
          <S ID="S-3663">We translate Arabic-to-English with shallow hierarchical decoding, i.e. only phrases are allowed to be substituted into non-terminals.</S>
          <S ID="S-3664">The rules used in this case are, in addition to the glue rules:</S>
        </P>
        <P>
          <S ID="S-3665">X &#8594; &#12296;&#947; s ,&#945; s &#12297; X &#8594; &#12296;V ,V &#12297; V &#8594; &#12296;s,t&#12297; s, t &#8712; T + ; &#947; s , &#945; s &#8712; ({V } &#8746; T) +</S>
        </P>
        <P>
          <S ID="S-3666">For translation model training, we use all allowed parallel corpora in the NIST MT08 Arabic track (&#8764;150M words per language).</S>
          <S ID="S-3667">In addition to the MT08 set itself, we use a development set mt02-05- tune formed from the odd numbered sentences of the NIST MT02 through MT05 evaluation sets; the even numbered sentences form the validation set mt02- 05-test.</S>
          <S ID="S-3668">The mt02-05-tune set has 2,075 sentences.</S>
        </P>
        <P>
          <S ID="S-3669">The cube pruning decoder, HCP, employs k-best lists of depth k=10000 (unique).</S>
          <S ID="S-3670">Using deeper lists results in excessive memory and time requirements.</S>
          <S ID="S-3671">In contrast, the WFST-based decoder, HiFST, requires no local pruning during lattice construction for this task and the language model is not applied until the lattice is fully built at the upper-most cell of the CYK grid.</S>
          <S ID="S-3672">Table 1 shows results for mt02-05-tune, mt02- 05-test and mt08, as measured by lowercased IBM BLEU and TER (<REF ID="R-28" RPTR="38">Snover et al., 2006</REF>).</S>
          <S ID="S-3673">MET parameters are optimized for the HCP decoder.</S>
          <S ID="S-3674">As shown in rows &#8216;a&#8217; and &#8216;b&#8217;, results after MET are comparable.</S>
        </P>
        <P>
          <S ID="S-3675">Search Errors Since both decoders use exactly the same features, we can measure their search errors on a sentence-by-sentence basis.</S>
          <S ID="S-3676">A search error is assigned to one of the decoders if the other has found a hypothesis with lower cost.</S>
          <S ID="S-3677">For mt02-05-tune, we find that in 18.5% of the sentences HiFST finds a hypothesis with lower cost than HCP.</S>
          <S ID="S-3678">In contrast, HCP never finds any hypothesis with lower cost for any sentence.</S>
          <S ID="S-3679">This is as expected: the HiFST decoder requires no pruning prior to applying the language model, so search is exact.</S>
          <S ID="S-3680">Lattice/k-best Quality Rescoring results are different for cube pruning and WFST-based decoders.</S>
          <S ID="S-3681">Whereas HCP improves by 0.9 BLEU, HiFST improves over 1.5 BLEU.</S>
          <S ID="S-3682">Clearly, search errors in HCP not only affect the 1-best output but also the quality of the resulting k-best lists.</S>
          <S ID="S-3683">For HCP, this limits the possible gain from subsequent rescoring steps such as large LMs and MBR.</S>
        </P>
        <P>
          <S ID="S-3684">Translation Speed HCP requires an average of 1.1 seconds per input word.</S>
          <S ID="S-3685">HiFST cuts this time by half, producing output at a rate of 0.5 seconds per word.</S>
          <S ID="S-3686">It proves much more efficient to process compact lattices contaning many hypotheses rather than to independently processing each one of them in k- best form.</S>
        </P>
        <P>
          <S ID="S-3687">The mixed case NIST BLEU-4 for the HiFST system on mt08 is 42.9.</S>
          <S ID="S-3688">This is directly comparable to the official MT08 Constrained Training Track evaluation results 1 .</S>
        </P>
      </DIV>
      <DIV DEPTH="1">
        <HEADER>3.3 Chinese-to-English Translation</HEADER>
        <P>
          <S ID="S-3689">We translate Chinese-to-English with full hierarchical decoding, i.e. hierarchical rules are allowed to be substituted into non-terminals.</S>
          <S ID="S-3690">We consider a maximum span of 10 words for the application of hierarchical rules and only glue rules are allowed at upper levels of the CYK grid.</S>
          <S ID="S-3691">For translation model training, we use all available data for the GALE 2008 evaluation 2 , approx.</S>
          <S ID="S-3692">250M words per language.</S>
          <S ID="S-3693">In addition to the MT08 set itself, we use a development set tune-nw and a validation set test-nw.</S>
          <S ID="S-3694">These contain a mix of the newswire portions of MT02 through MT05 and additional developments sets created by translation within the GALE program.</S>
          <S ID="S-3695">The tune-nw set has 1,755 sentences.</S>
          <S ID="S-3696">Again, the HCP decoder employs k-best lists of depth k=10000.</S>
          <S ID="S-3697">The HiFST decoder applies pruning in search as described in Section 2.4, so that any lattice in the CYK grid is pruned if it covers at least 3 source words and contains more than 10k states.</S>
          <S ID="S-3698">The likelihood pruning threshold relative to the best path in the lattice is 9.</S>
          <S ID="S-3699">This is a very broad threshold so that very few paths are discarded.</S>
        </P>
        <P>
          <S ID="S-3700">1 Full MT08 results are available at http://www.nist.gov/</S>
        </P>
        <P>
          <S ID="S-3701">speech/tests/mt/2008/doc/mt08 official results v0.html.</S>
          <S ID="S-3702">It is worth noting that many of the top entries make use of system combination; the results reported here are for single system translation.</S>
          <S ID="S-3703">2 See http://projects.ldc.upenn.edu/gale/data/catalog.html.</S>
        </P>
        <P>
          <S ID="S-3704">Improved Optimization Table 2 shows results for tune-nw, test-nw and mt08, as measured by lowercased IBM BLEU and TER.</S>
          <S ID="S-3705">The first two rows show results for HCP when using MET parameters optimized over k-best lists produced by HCP (row &#8216;a&#8217;) and by HiFST (row &#8216;b&#8217;).</S>
          <S ID="S-3706">We find that using the k- best list obtained by the HiFST decoder yields better parameters during optimization.</S>
          <S ID="S-3707">Tuning on the HiFST k-best lists improves the HCP BLEU score, as well.</S>
          <S ID="S-3708">We find consistent improvements in BLEU; TER also improves overall, although less consistently.</S>
        </P>
        <P>
          <S ID="S-3709">Search Errors Measured over the tune-nw development set, HiFST finds a hypothesis with lower cost in 48.4% of the sentences.</S>
          <S ID="S-3710">In contrast, HCP never finds any hypothesis with a lower cost for any sentence, indicating that the described pruning strategy for HiFST is much broader than that of HCP.</S>
          <S ID="S-3711">Note that HCP search errors are more frequent for this language pair.</S>
          <S ID="S-3712">This is due to the larger search space required in fully hierarchical translation; the larger the search space, the more search errors will be produced by the cube pruning k-best implementation.</S>
        </P>
        <P>
          <S ID="S-3713">Lattice/k-best Quality The lattices produced by HiFST yield greater gains in LM rescoring than the k-best lists produced by HCP.</S>
          <S ID="S-3714">Including the subsequent MBR rescoring, translation improves as much as 1.2 BLEU, compared to 0.7 BLEU with HCP.</S>
          <S ID="S-3715">The mixed case NIST BLEU-4 for the HiFST system on mt08 is 27.8, comparable to official results in the UnConstrained Training Track of the NIST 2008 evaluation.</S>
        </P>
      </DIV>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>4 Conclusions</HEADER>
      <P>
        <S ID="S-3745">The lattice-based decoder for hierarchical phrasebased translation described in this paper can be easily implemented using Weighted Finite State Transducers.</S>
        <S ID="S-3746">We find many benefits in this approach to translation.</S>
        <S ID="S-3747">From a practical perspective, the computational operations required can be easily carried out using standard operations already implemented in general purpose libraries.</S>
        <S ID="S-3748">From a modeling perspective, the compact representation of multiple translation hypotheses in lattice form requires less pruning in hierarchical search.</S>
        <S ID="S-3749">The result is fewer search errors and reduced overall memory use relative to cube pruning over k-best lists.</S>
        <S ID="S-3750">We also find improved performance of subsequent rescoring procedures which rely on the translation scores.</S>
        <S ID="S-3751">In direct comparison to k-best lists generated under cube pruning, we find that MET parameter optimization, rescoring with large language models, and MBR decoding, are all improved when applied to translations generated by the lattice-based hierarchical decoder.</S>
      </P>
    </DIV>
  </BODY>
  <ACKNOWLEDGMENTS>
    <P>
      <S ID="S-3752">This work was supported in part by the GALE program of the Defense Advanced Research Projects Agency, Contract No.</S>
      <S ID="S-3753">HR0011- 06-C-0022.</S>
      <S ID="S-3754">G. Iglesias supported by Spanish Government research grant BES-2007-15956 (project TEC2006-13694- C03-03).</S>
    </P>
  </ACKNOWLEDGMENTS>
  <REFERENCES>
    <REFERENCE ID="0">
      <RAUTHOR>Cyril Allauzen</RAUTHOR>
      <REFTITLE>Generalized algorithms for constructing statistical language models.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="1">
      <RAUTHOR>Cyril Allauzen</RAUTHOR>
      <REFTITLE>OpenFst: A general and efficient weighted finite-state transducer library.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="2">
      <RAUTHOR>Srinivas Bangalore</RAUTHOR>
      <REFTITLE>A finite-state approach to machine translation.</REFTITLE>
      <DATE>2001</DATE>
    </REFERENCE>
    <REFERENCE ID="3">
      <RAUTHOR>Oliver Bender</RAUTHOR>
      <REFTITLE>The RWTH Arabic-to-English spoken language translation system.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="4">
      <RAUTHOR>Phil Blunsom</RAUTHOR>
      <REFTITLE>A discriminative latent variable model for statistical machine translation.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="5">
      <RAUTHOR>Thorsten Brants</RAUTHOR>
      <REFTITLE>Large language models in machine translation.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="6">
      <RAUTHOR>Francisco Casacuberta</RAUTHOR>
      <REFTITLE>Finite-state transducers for speech-input translation.</REFTITLE>
      <DATE>2001</DATE>
    </REFERENCE>
    <REFERENCE ID="7">
      <RAUTHOR>Jean-C&#233;dric Chappelier</RAUTHOR>
      <REFTITLE>A generalized CYK algorithm for parsing stochastic CFG.</REFTITLE>
      <DATE>1998</DATE>
    </REFERENCE>
    <REFERENCE ID="8">
      <RAUTHOR>Jean-C&#233;dric Chappelier</RAUTHOR>
      <REFTITLE>Lattice parsing for speech recognition.</REFTITLE>
      <DATE>1999</DATE>
    </REFERENCE>
    <REFERENCE ID="9">
      <RAUTHOR>David Chiang</RAUTHOR>
      <REFTITLE>A hierarchical phrase-based model for statistical machine translation.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="10">
      <RAUTHOR>Chiang</RAUTHOR>
      <REFTITLE>Hierarchical phrase-based translation.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="11">
      <RAUTHOR>Christopher Dyer</RAUTHOR>
      <REFTITLE>Generalizing word lattice translation.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="12">
      <RAUTHOR>Jonathan Graehl</RAUTHOR>
      <REFTITLE>Training tree transducers.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="13">
      <RAUTHOR>Liang Huang</RAUTHOR>
      <REFTITLE>Forest rescoring: Faster decoding with integrated language models.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="14">
      <RAUTHOR>Gonzalo Iglesias</RAUTHOR>
      <REFTITLE>Rule filtering by pattern for efficient hierarchical translation.</REFTITLE>
      <DATE>2009</DATE>
    </REFERENCE>
    <REFERENCE ID="15">
      <RAUTHOR>Shankar Kumar</RAUTHOR>
      <REFTITLE>Minimum Bayes-risk decoding for statistical machine translation.</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="16">
      <RAUTHOR>Shankar Kumar</RAUTHOR>
      <REFTITLE>Local phrase reordering models for statistical machine translation.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="17">
      <RAUTHOR>Zhifei Li</RAUTHOR>
      <REFTITLE>A scalable decoder for parsing-based machine translation with equivalent language model state maintenance.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="18">
      <RAUTHOR>Adam Lopez</RAUTHOR>
      <REFTITLE>Tera-scale translation models via pattern matching.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="19">
      <RAUTHOR>Yuval Marton</RAUTHOR>
      <REFTITLE>Soft syntactic constraints for hierarchical phrased-based translation.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="20">
      <RAUTHOR>Lambert Mathias</RAUTHOR>
      <REFTITLE>Statistical phrase-based speech translation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="21">
      <RAUTHOR>Mehryar Mohri</RAUTHOR>
      <REFTITLE>The design principles of a weighted finitestate transducer library.</REFTITLE>
      <DATE>2000</DATE>
    </REFERENCE>
    <REFERENCE ID="22">
      <RAUTHOR>Mehryar Mohri</RAUTHOR>
      <REFTITLE>Weighted finite-state transducers in speech recognition.</REFTITLE>
      <DATE>2002</DATE>
    </REFERENCE>
    <REFERENCE ID="23">
      <RAUTHOR>Franz J Och</RAUTHOR>
      <REFTITLE>Minimum error rate training in statistical machine translation.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="24">
      <RAUTHOR>Kishore Papineni</RAUTHOR>
      <REFTITLE>BLEU: a method for automatic evaluation of machine translation.</REFTITLE>
      <DATE>2001</DATE>
    </REFERENCE>
    <REFERENCE ID="25">
      <RAUTHOR>Antti-Veikko Rosti</RAUTHOR>
      <REFTITLE>Combining outputs from multiple machine translation systems.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="26">
      <RAUTHOR>Libin Shen</RAUTHOR>
      <REFTITLE>A new string-to-dependency machine translation algorithm with a target dependency language model.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="27">
      <RAUTHOR>Khe Chai Sim</RAUTHOR>
      <REFTITLE>Consensus network decoding for statistical machine translation system combination.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="28">
      <RAUTHOR>Matthew Snover</RAUTHOR>
      <REFTITLE>A study of translation edit rate with targeted human annotation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="29">
      <RAUTHOR>Roy Tromble</RAUTHOR>
      <REFTITLE>Lattice Minimum Bayes-Risk decoding for statistical machine translation.</REFTITLE>
      <DATE>2008</DATE>
    </REFERENCE>
    <REFERENCE ID="30">
      <RAUTHOR>Ashish Venugopal</RAUTHOR>
      <REFTITLE>An efficient two-pass approach to synchronous-CFG driven statistical MT.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="31">
      <RAUTHOR>Hao Zhang</RAUTHOR>
      <REFTITLE>Synchronous binarization for machine translation.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="32">
      <RAUTHOR>Andreas Zollmann</RAUTHOR>
      <REFTITLE>Syntax augmented machine translation via chart parsing.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
  </REFERENCES>
</PAPER>
