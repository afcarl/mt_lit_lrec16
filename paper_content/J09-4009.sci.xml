<PAPER>
  <FILENO/>
  <TITLE>Binarization of Synchronous Context-Free Grammars</TITLE>
  <AUTHORS>
    <AUTHOR>Liang Huang</AUTHOR>
    <AUTHOR>Hao Zhang</AUTHOR>
    <AUTHOR>Daniel Gildea</AUTHOR>
  </AUTHORS>
  <ABSTRACT/>
  <BODY>
    <DIV DEPTH="0">
      <HEADER>1. Introduction</HEADER>
      <P>
        <S ID="S-21016">Several recent syntax-based models for machine translation (<REF ID="R-04" RPTR="2">Chiang 2005</REF>; <REF ID="R-07" RPTR="12">Galley et al. 2004</REF>) can be seen as instances of the general framework of synchronous grammars and tree transducers.</S>
        <S ID="S-21017">In this framework, both alignment (synchronous parsing) and decoding can be thought of as parsing problems, whose complexity is in general exponential in the number of nonterminals on the right-hand side of a grammar rule.</S>
        <S ID="S-21018">To alleviate this problem, we investigate bilingual binarization as a technique to factor each synchronous grammar rule into a series of binary rules.</S>
        <S ID="S-21019">Although monolingual context-free grammars (CFGs) can always be binarized, this is not the case</S>
      </P>
      <P>
        <S ID="S-21020">We develop a technique called synchronous binarization and devise a linear-time binarization algorithm such that the resulting rule set allows efficient algorithms for both synchronous parsing and decoding with integrated n-gram language models.</S>
        <S ID="S-21021">We examine the effect of this binarization method on end-to-end translation quality on a large-scale Chinese-to-English syntax-based system, compared to a more typical baseline method, and a state-of-the-art phrase-based system.</S>
        <S ID="S-21022">We examine the ratio of binarizability in large, empirically derived rule sets, and show that the vast majority is binarizable.</S>
        <S ID="S-21023">However, we also provide, for the first time, real examples of non-binarizable cases verified by native speakers.</S>
        <S ID="S-21024">In the final, theoretical, sections of this article, we investigate the general problem of finding the most efficient synchronous parsing or decoding strategy for arbitrary synchronous context-free grammar (SCFG) rules, including non-binarizable cases.</S>
        <S ID="S-21025">Although this problem is believed to be NP-complete, we prove two results that substantially reduce the search space over strategies.</S>
        <S ID="S-21026">We also present an optimal algorithm that runs tractably in practice and a polynomial-time algorithm that is a good approximation of the former.</S>
        <S ID="S-21027"><REF ID="R-17" RPTR="20">Melamed (2003)</REF> discusses binarization of multi-text grammars on a theoretical level, showing the importance and difficulty of binarization for efficient synchronous parsing.</S>
        <S ID="S-21028">One way around this difficulty is to stipulate that all rules must be binary from the outset, as in Inversion Transduction Grammar (ITG) (<REF ID="R-30" RPTR="44">Wu 1997</REF>) and the binary SCFG employed by the Hiero system (<REF ID="R-04" RPTR="3">Chiang 2005</REF>) to model the hierarchical phrases.</S>
        <S ID="S-21029">In contrast, the rule extraction method of <REF ID="R-07" RPTR="9">Galley et al. (2004)</REF> aims to incorporate more syntactic information by providing parse trees for the target language and extracting tree transducer rules that apply to the parses.</S>
        <S ID="S-21030">This approach results in rules with many nonterminals, making good binarization techniques critical.</S>
        <S ID="S-21031">We explain how synchronous rule binarization interacts with n-gram language models and affects decoding for machine translation in Section 2.</S>
        <S ID="S-21032">We define binarization formally in Section 3, and present an efficient algorithm for the problem in Section 4.</S>
        <S ID="S-21033">Experiments described in Section 5 1 show that binarization improves machine translation speed and quality.</S>
        <S ID="S-21034">Some rules cannot be binarized, and we present a decoding strategy for these rules in Section 6.</S>
        <S ID="S-21035">Section 7 gives a solution to the general theoretical problem of finding optimal decoding and synchronous parsing strategies for arbitrary SCFGs, and presents complexity results on the nonbinarizable rules from our Chinese&#8211;English data.</S>
        <S ID="S-21036">These final two sections are of primarily theoretical interest, as nonbinarizable rules have not been shown to benefit real-world machine translation systems.</S>
        <S ID="S-21037">However, the algorithms presented may become relevant as machine translation systems improve.</S>
      </P>
      <P>
        <S ID="S-21038">Suppose we have the following SCFG, where superscripts indicate reorderings (formal definitions of SCFGs with a more flexible notation can be found in Section 3): (2)</S>
      </P>
      <P>
        <S ID="S-21039">Decoding can be cast as a (monolingual) parsing problem because we only need to parse the source-language side of the SCFG, as if we were constructing a CFG by projecting the SCFG onto its Chinese side:</S>
      </P>
      <P>
        <S ID="S-21040">The only extra work we need to do for decoding is to build corresponding targetlanguage (English) subtrees in parallel.</S>
        <S ID="S-21041">In other words, we build synchronous trees when parsing the source-language input, as shown in Figure 1.</S>
        <S ID="S-21042">For efficient parsing, we need to binarize the projected CFG either explicitly into Chomsky Normal Form as required by the CKY algorithm, or implicitly into a dotted representation as in the Earley algorithm.</S>
        <S ID="S-21043">To simplify the presentation, we will focus on the former, but the following discussion can be easily adapted to the latter.</S>
        <S ID="S-21044">Rules can be binarized in different ways.</S>
        <S ID="S-21045">For example, we could binarize the first rule left to right or right to left (see Figure 2):</S>
      </P>
      <P>
        <S ID="S-21046">We call these intermediate symbols (e.g., PP-VP) virtual nonterminals and corresponding rules virtual rules, whose probabilities are all set to 1.</S>
        <S ID="S-21047">Figure 1 A pair of synchronous parse trees in the SCFG (2).</S>
        <S ID="S-21048">The superscript symbols ( &#8900;&#8902;&#9702;&#8226; ) indicate pairs of synchronous nonterminals (and subtrees).</S>
      </P>
      <P>
        <S ID="S-21049">Figure 2 The alignment matrix and two binarization schemes, with virtual nonterminals in gray.</S>
        <S ID="S-21050">(a) A two-dimensional matrix representation of the first SCFG rule in grammar 2.</S>
        <S ID="S-21051">Rows are positions in Chinese: columns are positions in English, and black cells indicate positions linked by the SCFG rule.</S>
        <S ID="S-21052">(b) This scheme groups NP and PP into an intermediate state which contains a gap on the English side.</S>
        <S ID="S-21053">(c) This scheme groups PP and VP into an intermediate state which is contiguous on both sides.</S>
        <S ID="S-21054">These two binarizations are no different in the translation-model-only decoding described previously, just as in monolingual parsing.</S>
        <S ID="S-21055">However, in the source-channel approach to machine translation, we need to combine probabilities from the translation model (TM) (an SCFG) with the language model (an n-gram), which has been shown to be very important for translation quality (<REF ID="R-04" RPTR="4">Chiang 2005</REF>).</S>
        <S ID="S-21056">To do bigram-integrated decoding (<REF ID="R-29" RPTR="37">Wu 1996</REF>), we need to augment each chart item (X, i, j) with two targetlanguage boundary words u and v to produce a bigram-item which we denote ( )</S>
      </P>
      <P>
        <S ID="S-21057">where p and q are the scores of antecedent items.</S>
        <S ID="S-21058">This situation is unpleasant because in the target language NP and PP are not contiguous so we cannot apply language model scoring when we build the NP-PP item.</S>
        <S ID="S-21059">Instead, we have to maintain all four boundary words (rather than two) and postpone the language model scoring till the next step where NP-PP is combined with ( held &#183;&#183;&#183; meeting</S>
      </P>
      <P>
        <S ID="S-21060">to form an S item.</S>
        <S ID="S-21061">We call this binarization method monolingual binarization because it works only on the source-language projection of the rule without respecting the constraints from the other side.</S>
        <S ID="S-21062">This scheme generalizes to the case where we have n nonterminals in a SCFG rule, and the decoder conservatively assumes nothing can be done on language model scoring (because target-language spans are non-contiguous in general) until the real nonterminal has been recognized.</S>
        <S ID="S-21063">In other words, target-language boundary words ) 2 An alternative to integrated decoding is rescoring, where one first computes the k-best translations according to the TM only, and then reranks the k-best list with the language model costs.</S>
        <S ID="S-21064">This method runs very fast in practice (<REF ID="R-11" RPTR="18">Huang and Chiang 2005</REF><REF ID="R-04" RPTR="5">Chiang 2005</REF>), but often produces a considerable number of search errors because the true best translation is often outside of the k-best list, especially for longer sentences.</S>
        <S ID="S-21065">562 Huang et al. Binarization of Synchronous Context-Free Grammars from each child nonterminal of the rule will be cached in all virtual nonterminals derived from this rule.</S>
        <S ID="S-21066">In the case of m-gram integrated decoding, we have to maintain 2(m &#8722; 1) boundary words for each child nonterminal, which leads to a prohibitive overall complexity of O(|w |3+2n(m&#8722;1) ), which is exponential in rule size (Huang, Zhang, and Gildea 2005).</S>
        <S ID="S-21067">Aggressive pruning must be used to make it tractable in practice, which in general introduces many search errors and adversely affects translation quality.</S>
        <S ID="S-21068">In the second case, however, we have:</S>
      </P>
      <P>
        <S ID="S-21069">Here, because PP and VP are contiguous (but swapped) in the target language, we can include the language model score by multiplying in Pr(with  |meeting), and the resulting item again has two boundary words.</S>
        <S ID="S-21070">Later we multiply in Pr(held  |Powell) when the resulting item is combined with ( )</S>
      </P>
      <P>
        <S ID="S-21071">In this case m-gram integrated decoding can be done in O(|w |3+4(m&#8722;1) ) time, which is a much lower-order polynomial and no longer depends on rule size (<REF ID="R-29" RPTR="38">Wu 1996</REF>), allowing the search to be much faster and more accurate, as is evidenced in the Hiero system of <REF ID="R-04" RPTR="6">Chiang (2005)</REF>, which restricts the hierarchical phrases to form binary-branching SCFG rules.</S>
        <S ID="S-21072">Some recent syntax-based MT systems (<REF ID="R-07" RPTR="13">Galley et al. 2004</REF>) have adopted the formalism of tree transducers (<REF ID="R-22" RPTR="26">Rounds 1970</REF>), modeling translation as a set of rules for a transducer that takes a syntax tree in one language as input and transforms it into a tree (or string) in the other language.</S>
        <S ID="S-21073">The same decoding algorithms are used for machine translation in this formalism, and the following example shows that the same issues of binarization arise.</S>
        <S ID="S-21074">Suppose we have the following transducer rules:</S>
      </P>
      <P>
        <S ID="S-21075">where the reorderings of nonterminals are denoted by variables x i .</S>
        <S ID="S-21076">In the treetransducer formalism of Rounds (1970), the right-hand (target) side subtree can have multiple levels, as in the first rule above.</S>
        <S ID="S-21077">This system can model non-isomorphic transformations on English parse trees to &#8220;fit&#8221; another language, learning, for example, that the (V S O) structure in Arabic should be transformed into a (S (V O)) structure in English, by looking at two-level tree fragments (Knight and Graehl 2005).</S>
        <S ID="S-21078">From a synchronous rewriting point of view, this is more akin to synchronous tree substitution grammar (STSG) (<REF ID="R-06" RPTR="7">Eisner 2003</REF>; <REF ID="R-26" RPTR="35">Shieber 2004</REF>) (see Figure 3).</S>
        <S ID="S-21079">This larger locality captures more linguistic phenomena and leads to better parameter estimation.</S>
        <S ID="S-21080">By creating a</S>
      </P>
      <P>
        <S ID="S-21081">Figure 3 Two equivalent representations of the first rule in Example (5): (a) tree transducer; (b) Synchronous Tree Subsitution Grammar (STSG).</S>
        <S ID="S-21082">The &#8595; arrows denote substitution sites, which correspond to variables in tree transducers.</S>
        <S ID="S-21083">nonterminal for each right-hand-side tree, we can convert the transducer representation to an SCFG with the same generative capacity.</S>
        <S ID="S-21084">We can again create a projected CFG which will be exactly the same as in Example (3), and build English subtrees while parsing the Chinese input.</S>
        <S ID="S-21085">In this sense we can neglect the tree structures when binarizing a tree-transducer rule, and consider only the alignment (or permutation) of the nonterminal variables.</S>
        <S ID="S-21086">Again, rightmost binarization is preferable for the first rule.</S>
        <S ID="S-21087">In SCFG-based frameworks, the problem of finding a word-level alignment between two sentences is an instance of the synchronous parsing problem: Given two strings and a synchronous grammar, find a parse tree that generates both input strings.</S>
        <S ID="S-21088">The benefit of binary grammars also applies in this case.</S>
        <S ID="S-21089"><REF ID="R-30" RPTR="39">Wu (1997</REF><REF ID="R-30" RPTR="46">Wu (1997)</REF> shows that parsing a binary-branching SCFG is in O(|w |6 ), while parsing SCFG with arbitrary rules is NP-hard (<REF ID="R-23" RPTR="27">Satta and Peserico 2005</REF>).</S>
        <S ID="S-21090">For example, in Figure 2, the complexity of synchronous parsing for the original grammar (a) is O(|w |8 ), because we have to maintain four indices on either side, giving a total of eight; parsing the monolingually binarized grammar (b) involves seven indices, three on the Chinese side and four on the English side.</S>
        <S ID="S-21091">In contrast, the synchronously binarized version (c) requires only 3 + 3 = 6 indices, which can be thought of as &#8220;CKY in two dimensions.&#8221; An efficient alignment algorithm is guaranteed if a binarization is found, and the same binarization can be used for decoding and alignment.</S>
        <S ID="S-21092">We show how to find optimal alignment algorithms for non-binarizable rules in Section 7; in this case different grammar factorizations may be optimal for alignment and for decoding with n-gram models of various orders.</S>
        <S ID="S-21093">Handling difficult rules may in fact be more important for alignment than for decoding, because although we may be able to find good translations during decoding within the space permitted by computationally friendly rules, during alignment we must handle the broader spectrum of phenomena found in real bitext data.</S>
        <S ID="S-21094">In general, if we are given an arbitrary synchronous rule with many nonterminals, what are the good decompositions that lead to a binary grammar?</S>
        <S ID="S-21095">Figure 2 suggests that a binarization is good if every virtual nonterminal has contiguous spans on both sides.</S>
        <S ID="S-21096">We formalize this idea in the next section.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>3. Synchronous Binarization</HEADER>
      <P>
        <S ID="S-21097">Definition 1 A synchronous CFG (SCFG) is a context-free rewriting system for generating string pairs.</S>
        <S ID="S-21098">Each rule (synchronous production) A &#8594; &#945;, B &#8594; &#946; 564 Huang et al. Binarization of Synchronous Context-Free Grammars rewrites a pair of synchronous nonterminals (A, B) in two dimensions subject to the constraint that there is a one-to-one mapping between the nonterminal occurrences in &#945; and the nonterminal occurrences in &#946;.</S>
        <S ID="S-21099">Each co-indexed child nonterminal pair is a pair of synchronous nonterminals and will be further rewritten as a unit.</S>
        <S ID="S-21100">Note that this notation, due to <REF ID="R-23" RPTR="28">Satta and Peserico (2005)</REF>, is more flexible than those in the previous section, in the sense that we can allow different symbols to be synchronized, which is essential to capture the syntactic divergences between languages.</S>
        <S ID="S-21101">For example, the following rule from Chinese to English</S>
      </P>
      <P>
        <S ID="S-21102">We define the language L(G) produced by an SCFG G as the pairs of terminal strings produced by rewriting exhaustively from the start nonterminal pair.</S>
        <S ID="S-21103">As shown in Section 4.2, terminals do not play an important role in binarization.</S>
        <S ID="S-21104">So we now write rules in the following notation:</S>
      </P>
      <P>
        <S ID="S-21105">where X i and Y i are variables ranging over nonterminals in the source and target projections of the synchronous grammar, respectively, and &#960; is the permutation of the rule.</S>
        <S ID="S-21106">For example, in rule (6), we have n = 2, X = Y = VP, X 1 = VB, X 2 = NN, Y 1 = VBZ, Y 2 = NNS, and &#960; is the identity permutation.</S>
        <S ID="S-21107">Note that this general notation includes cases where a nonterminal occurs more than once in the right-hand side, for example, when n = 2, X = Y = A, and X 1 = X 2 = Y 1 = Y 2 = B, we can have the following two rules: A &#8594; B 1 B 2 , A &#8594; B 2 B 1 ; A &#8594; B 1 B 2 , A &#8594; B 1 B 2 .</S>
        <S ID="S-21108">We also define an SCFG rule as n-ary if its permutation is of n and call an SCFG n-ary if its longest rule is n-ary.</S>
        <S ID="S-21109">Our goal is to produce an equivalent binary SCFG for an input n-ary SCFG.</S>
        <S ID="S-21110">However, not every SCFG can be binarized.</S>
        <S ID="S-21111">In fact, the binarizability of an n- ary rule is determined by the structure of its permutation, which can sometimes be resistant to factorization (<REF ID="R-00" RPTR="0">Aho and Ullman 1972</REF>).</S>
        <S ID="S-21112">We now turn to rigorously defining the binarizability of permutations.</S>
        <S ID="S-21113">Definition 2 A permuted sequence is a permutation of consecutive integers.</S>
        <S ID="S-21114">If a permuted sequence a can be split into the concatenation of two permuted sequences b and c, then (b; c) is called a proper split of a.</S>
        <S ID="S-21115">We say b &amp;lt; c if each element in b is smaller than any element in c.</S>
      </P>
      <P>
        <S ID="S-21116">For example, (3, 5, 4) is a permuted sequence whereas (2, 5) is not.</S>
        <S ID="S-21117">As special cases, single numbers are permuted sequences as well.</S>
        <S ID="S-21118">(3; 5, 4) is a proper split of (3, 5, 4) whereas (3, 5; 4) is not.</S>
        <S ID="S-21119">A proper split has the following property: Lemma 1 For a permuted sequence a, a = (b; c) is a proper split if and only if b &amp;lt; c or c &amp;lt; b. Proof The &#8658; direction is trivial by the definition of proper split.</S>
        <S ID="S-21120">We prove the &#8656; direction by contradiction.</S>
        <S ID="S-21121">If b &amp;lt; c but b is not a permuted sequence, i.e., the set of b&#8217;s elements is not consecutive, then there must be some x &#8712; c such that min b &amp;lt; x &amp;lt; max b, which contradicts the fact that b &amp;lt; c.</S>
        <S ID="S-21122">We have a similar contradiction if c is not a permuted sequence.</S>
        <S ID="S-21123">Now that both b and c are permuted sequences, (b; c) is a proper split.</S>
        <S ID="S-21124">The case when b &amp;gt; c is similar.</S>
        <S ID="S-21125">&#65533; Definition 3 A permuted sequence a is said to be binarizable if either</S>
      </P>
      <P>
        <S ID="S-21126">such split a binarizable split.</S>
        <S ID="S-21127">This is a recursive definition, and it implies that there is a hierarchical binarization pattern associated with each binarizable sequence, which we now rigorously define.</S>
        <S ID="S-21128">Definition 4 A binarization tree bi(a) of a binarizable sequence a is either</S>
      </P>
      <P>
        <S ID="S-21129">1. a if a = (a), or 2.</S>
        <S ID="S-21130">[bi(b), bi(c)] if b &amp;lt; c, or &#12296;bi(b), bi(c)&#12297; otherwise, where a = (b; c) is a</S>
      </P>
      <P>
        <S ID="S-21131">binarizable split, and bi(b) is a binarization tree of b and bi(c) a binarization tree of c.</S>
        <S ID="S-21132">Here we use [] and &#12296;&#12297; for straight (b &amp;lt; c) and inverted (b &amp;gt; c) combinations, respectively, following the ITG notation of <REF ID="R-30" RPTR="40">Wu (1997</REF><REF ID="R-30" RPTR="47">Wu (1997)</REF>.</S>
        <S ID="S-21133">Note that a binarizable sequence might have multiple binarization trees.</S>
        <S ID="S-21134">See Figure 4 for a binarizable sequence (1, 2, 4, 3) with its two possible binarization trees and a non-binarizable sequence (2, 4, 1, 3).</S>
        <S ID="S-21135">We are now able to define the binarizability of SCFGs: Definition 5 An SCFG is said to be binarizable if the permutation of each synchronous production is binarizable.</S>
        <S ID="S-21136">We denote the class of binarizable SCFGs as bSCFG.</S>
        <S ID="S-21137">This set, bSCFG, represents an important subclass of SCFG that is easy to handle (for example, parsable in O(|w |6 )) and covers many interesting longer-than-two rules.</S>
        <S ID="S-21138">The goal of synchronous binarization, then, is to convert a binarizable grammar G in bSCFG, which might be n-ary with n &#8805; 2, into an equivalent binary grammar G &#8242; that</S>
      </P>
      <P>
        <S ID="S-21139">Figure 5 Subclasses of SCFG.</S>
        <S ID="S-21140">The thick arrow denotes the direction of synchronous binarization and indicates bSCFG can collapse to binary SCFG.</S>
        <S ID="S-21141">decomposes the original permutation into a set of binary ones.</S>
        <S ID="S-21142">All that remains is to decorate the skeleton binarization tree with nonterminal symbols and attach terminals to the skeleton appropriately (see the next section for details).</S>
        <S ID="S-21143">We state this result as the following theorem: Theorem 1 For each grammar G in bSCFG, there exists a binary SCFG G &#8242; , such that L(G &#8242; ) = L(G).</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>4. Binarization Algorithms</HEADER>
      <P>
        <S ID="S-21144">We have reduced the problem of binarizing an SCFG rule into the problem of binarizing its permutation.</S>
        <S ID="S-21145">The simplest algorithm for this problem is to try all bracketings of a permutation and pick one that corresponds to a binarization tree.</S>
        <S ID="S-21146">The number of all possible bracketings of a sequence of length n is known to be the Catalan Number</S>
      </P>
      <P>
        <S ID="S-21147">which grows exponentially with n.</S>
        <S ID="S-21148">A better approach is to reduce this problem to an instance of synchronous ITG parsing (<REF ID="R-30" RPTR="45">Wu 1997</REF>).</S>
        <S ID="S-21149">Here the parallel string pair that we are parsing is the integer sequence (1...n) and its permutation (&#960;(1)...&#960;(n)).</S>
        <S ID="S-21150">The goal of the ITG parsing is to find a synchronous tree that agrees with the alignment indicated by the permutation.</S>
        <S ID="S-21151">Synchronous ITG parsing runs in time O(n 6 ) but can be improved to O(n 4 ) because there is no insertion or deletion in a permutation.</S>
      </P>
      <P>
        <S ID="S-21152">Another problem besides efficiency is that there are possibly multiple binarization trees for many permutations whereas we just need one.</S>
        <S ID="S-21153">We would prefer a consistent pattern of binarization trees across different permutations so that sub-binarizations (virtual nonterminals) can be shared.</S>
        <S ID="S-21154">For example, permutations (1, 3, 2, 5, 4) and (1, 3, 2, 4) can share the common sub-binarization tree [1, &#12296;3, 2&#12297;].</S>
        <S ID="S-21155">To this end, we can borrow the non-ambiguous ITG of <REF ID="R-30" RPTR="41">Wu (1997</REF>, Section 7) that prefers left-heavy binarization trees so that for each permutation there is a unique synchronous derivation.</S>
        <S ID="S-21156">3 We now refine the definition of binarization trees accordingly.</S>
        <S ID="S-21157">Definition 6 A binarization tree bi(a) is said to be canonical if the split at each non-leaf node of the tree is the rightmost binarizable split.</S>
        <S ID="S-21158">For example, for sequence (1, 2, 4, 3), the binarization tree [[1, 2], &#12296;4, 3&#12297;] is canonical, whereas [1, [2, &#12296;4, 3&#12297;]] is not, because its top-level split is not at the rightmost binarizable split (1, 2; 4, 3).</S>
        <S ID="S-21159">By definition, there is a unique canonical binarization tree for each binarizable sequence.</S>
        <S ID="S-21160">We next present an algorithm that is both fast and consistent.</S>
      </P>
      <P>
        <S ID="S-21161"><REF ID="R-25" RPTR="33">Shapiro and Stephens (1991</REF>, page 277) informally present an iterative procedure that, in each pass, scans the permuted sequence from left to right and combines two adjacent subsequences whenever possible.</S>
        <S ID="S-21162">This procedure produces canonical binarization trees and runs in O(n 2 ) time because we need n passes in the worst case.</S>
        <S ID="S-21163">Inspired by the Graham Scan Algorithm (<REF ID="R-09" RPTR="15">Graham 1972</REF>) for computing convex hulls from computational geometry, we modify this procedure and improve it into a linear-time algorithm that only needs one pass through the sequence.</S>
        <S ID="S-21164">The skeleton binarization algorithm is an instance of the widely used left-to-right shift-reduce algorithm.</S>
        <S ID="S-21165">It maintains a stack for contiguous subsequences discovered so far; for example: 2&#8211;5, 1.</S>
        <S ID="S-21166">In each iteration, it shifts the next number from the input and repeatedly tries to reduce the top two elements on the stack if they are consecutive.</S>
        <S ID="S-21167">See Algorithm 1 for the pseudo-code and Figures 6 and 7 for example runs on binarizable and non-binarizable permutations, respectively.</S>
        <S ID="S-21168">We need the following lemma to prove the properties of the algorithm:</S>
      </P>
      <P>
        <S ID="S-21169">We prove by induction on the length of a.</S>
        <S ID="S-21170">Base case: |a |= 2, a (proper) subsequence of a, has length 1, so it is binarizable.</S>
        <S ID="S-21171">For |a |&amp;gt; 2, because a has a binarization tree, there 3 We are not aiming at optimal sharing, that is, a strategy that produces the smallest binarized grammar for a given ruleset, which would require a global optimization problem over the whole set.</S>
        <S ID="S-21172">In practice, we can only use online algorithms that binarize rules one by one.</S>
        <S ID="S-21173">The left-heavy (or its symmetric variant, right-heavy) preference we choose here is one of the obvious candidates for consistency.</S>
      </P>
      <P>
        <S ID="S-21174">568 Huang et al. Binarization of Synchronous Context-Free Grammars Algorithm 1 The linear-time binarization algorithm.</S>
        <S ID="S-21175">1: function SYNCHRONOUSBINARIZER(&#960;) 2: top &#8592; 0 &#8882; stack top pointer 3: PUSH(stack, (&#960;(1), &#960;(1))) &#8882; initial shift 4: for i &#8592; 2 to |&#960; |do &#8882; for each remaining element 5: PUSH(stack, (&#960;(i), &#960;(i))) &#8882; shift 6: while top &amp;gt; 1 and CONSECUTIVE(stack[top], stack[top &#8722; 1]) do 7: &#8882; keep reducing if possible 8: (p, q) &#8592; COMBINE(stack[top], stack[top &#8722; 1]) 9: top &#8592; top &#8722; 2 10: PUSH(stack, (p, q)) 11: return (top = 1) &#8882; returns true iff.</S>
        <S ID="S-21176">the input is reduced to a single element 12: 13: function CONSECUTIVE((a, b), (c, d)) 14: return (b = c &#8722; 1) or (d = a &#8722; 1) &#8882; either straight or inverted 15: function COMBINE((a, b), (c, d)) 16: A = {min(a, c)...max(b, d)} 17: B = {a...b} 18: C = {c...d} 19: rule[A] = A &#8594; B C 20: return (min(a, c), max(b, d))</S>
      </P>
      <P>
        <S ID="S-21177">Figure 6 Example of Algorithm 1 on the binarizable input (1, 5, 3, 4, 2).</S>
        <S ID="S-21178">The rightmost column shows the binarization-trees generated at each reduction step.</S>
        <S ID="S-21179">exists a (binarizable) split which is nearest to the root and splits c into two parts.</S>
        <S ID="S-21180">Let the split be (b 1 , c 1 ; c 2 , b 2 ), where c = (c 1 ; c 2 ), and either b 1 or b 2 can be empty.</S>
        <S ID="S-21181">By Lemma 1, we have c 1 &amp;lt; c 2 or c 1 &amp;gt; c 2 .</S>
        <S ID="S-21182">By Lemma 1 again, we have that (c 1 ; c 2 ) is a proper split of c, i.e., both c 1 and c 2 are themselves permuted sequences.</S>
        <S ID="S-21183">We also know both (b 1 , c 1 ) and (c 2 , b 2 ) are binarizable.</S>
        <S ID="S-21184">By the induction hypothesis, c 1 and c 2 are both binarizable.</S>
        <S ID="S-21185">So we conclude that c = (c 1 ; c 2 ) is binarizable (See figure 8).</S>
        <S ID="S-21186">&#65533; We now state the central result of this work.</S>
        <S ID="S-21187">Theorem 2 Algorithm 1 runs in time linear to the length of the input, and succeeds (i.e., it reduces the input into one single element) if and only if the input permuted sequence a is binarizable, in which case the binarization tree recovered is canonical.</S>
      </P>
      <P>
        <S ID="S-21188">Illustration of the proof of Lemma 2.</S>
        <S ID="S-21189">The arrangement of (b 1 , c 1 ; c 2 , b 2 ) must be either all straight as in (a) or all inverted as in (b).</S>
        <S ID="S-21190">Proof We prove the following three parts of this theorem:</S>
      </P>
      <P>
        <S ID="S-21191">1.</S>
        <S ID="S-21192">If Algorithm 1 succeeds, then a is binarizable because we can recover a binarization tree from the algorithm.</S>
        <S ID="S-21193">2.</S>
        <S ID="S-21194">If a is binarizable, then Algorithm 1 must succeed and the binarization tree</S>
      </P>
      <P>
        <S ID="S-21195">recovered must be canonical: We prove by a complete induction on n, the length of a.</S>
        <S ID="S-21196">Base case: n = 1, trivial.</S>
        <S ID="S-21197">Assume it holds for all n &#8242; &amp;lt; n.</S>
        <S ID="S-21198">If a is binarizable, then let a = (b; c) be its rightmost binarizable split.</S>
        <S ID="S-21199">By definition, both b and c are binarizable.</S>
        <S ID="S-21200">By the induction hypothesis, the algorithm succeeds on the partial input b, reducing it to the single element stack[0] on the stack and recovering its canonical binarization tree bi(b).</S>
        <S ID="S-21201">If c is a singleton, the algorithm will combine it with the element stack[0] and succeed.</S>
        <S ID="S-21202">The final binarization tree is canonical because the top-level split is at the rightmost binarizable split, and both subtrees are canonical.</S>
        <S ID="S-21203">If c is not a singleton, we want to show by contradiction that the algorithm will never combine b with a proper prefix of c.</S>
        <S ID="S-21204">Because a = (b; c) is a proper split, we know that either b &amp;lt; c or c &amp;lt; b.</S>
        <S ID="S-21205">Now if the algorithm makes a combination of (b; c 1 ) for some proper prefix c 1 where c = (c 1 ; c 2 ), we have either c 1 &amp;lt; c 2 or c 1 &amp;gt; c 2 .</S>
        <S ID="S-21206">By Lemma 1, (c 1 ; c 2 ) is a proper split.</S>
        <S ID="S-21207">Because c is binarizable, by Lemma 2, c 2 is also binarizable.</S>
        <S ID="S-21208">So (b, c 1 ; c 2 ) is a binarizable split to the right of (b; c), which contradicts the assumption that the latter is the rightmost binarizable split (see Figure 9).</S>
        <S ID="S-21209">570 Huang et al. Binarization of Synchronous Context-Free Grammars Figure 9 Illustration of the proof of Theorem 2.</S>
        <S ID="S-21210">The combination of (b; c 1 ) (in dashed squares) contradicts the assumption that (b; c) is the rightmost binarizable split of a.</S>
        <S ID="S-21211">&#65533; Therefore, the algorithm will scan through the whole c as if from the empty stack.</S>
        <S ID="S-21212">By the induction hypothesis again, it will reduce c into stack[1] on the stack and recover its canonical binarization tree bi(c).</S>
        <S ID="S-21213">Because b and c are combinable, the algorithm reduces stack[0] and stack[1] in the last step, forming the canonical binarization tree for a, which is either [bi(b), bi(c)] or &#12296;bi(b), bi(c)&#12297;.</S>
      </P>
      <P>
        <S ID="S-21214">By amortized analysis (Cormen, Leiserson, and Rivest 1990), there are exactly n shifts and at most n &#8722; 1 reductions, and each shift or reduction takes O(1) time.</S>
        <S ID="S-21215">So the total time complexity is O(n).</S>
      </P>
      <P>
        <S ID="S-21216">Thus far we have discussed how to binarize synchronous productions involving only nonterminals through binarizing the corresponding skeleton permutations.</S>
        <S ID="S-21217">We now turn to technical details for the implementation of a synchronous binarizer in real MT systems.</S>
        <S ID="S-21218">We will first show how to deal with the terminal symbols, and then describe how to adapt it to tree transducers.</S>
        <S ID="S-21219">Consider the following SCFG rule: (7) ADJP &#8594; RB 1 # / f&#249;z&#233; PP 2 &#8222; / de NN 3 , ADJP &#8594; RB 1 responsible for the NN 3 PP 2 whose permutation is (1, 3, 2).</S>
        <S ID="S-21220">We run the skeleton binarization algorithm and get the (canonical) binarization tree [1, &#12296;3, 2&#12297;], which corresponds to [RB, &#12296;NN, PP&#12297;] (see Figure 10(a)).</S>
        <S ID="S-21221">The alignment matrix is shown in Figure 11.</S>
        <S ID="S-21222">We will then do a post-order traversal of the skeleton tree, and attach the terminals from both languages when appropriate.</S>
        <S ID="S-21223">It turns out we can do this quite freely as long as we can uniquely reconstruct the original rule from its binary parse tree.</S>
        <S ID="S-21224">We use the following rules for this step: 1.</S>
        <S ID="S-21225">Attach source-language terminals to the leaf nodes of the skeleton tree.</S>
        <S ID="S-21226">Consecutive terminals are attached to the nonterminal on their left</S>
      </P>
      <P>
        <S ID="S-21227">Figure 10 Attaching terminals in SCFG binarization.</S>
        <S ID="S-21228">(a) The skeleton binarization tree, (b) attaching Chinese words at leaf nodes, (c) attaching English words at internal nodes.</S>
        <S ID="S-21229">Figure 11 Alignment matrix of the SCFG rule (7).</S>
        <S ID="S-21230">Areas shaded in gray and light gray denote virtual nonterminals (see rules in Example (8)).</S>
        <S ID="S-21231">(except for the initial ones which are attached to the nonterminal on their right).</S>
        <S ID="S-21232">2.</S>
        <S ID="S-21233">Attach target-language terminals to the internal nodes (virtual nonterminals) of the skeleton tree.</S>
        <S ID="S-21234">These terminals are attached greedily: When combining two nonterminals, all target-side terminal strings neighboring either nonterminal will be included.</S>
        <S ID="S-21235">This greedy merging is motivated by the idea that the language model score helps to guide the decoder and should be computed as early as possible.</S>
        <S ID="S-21236">For example, at the leaf nodes, the Chinese word # / f&#249;z&#233; is attached to RB 1 , and &#8222; / de to PP 1 (Figure 10(b)).</S>
        <S ID="S-21237">Next, when combining NN 3 and the virtual nonterminal PP-&#8222; / de, we also include the English-side string responsible for the (Figure 10(c)).</S>
        <S ID="S-21238">In order to do this rigorously we need to keep track of sub-alignments including both aligned nonterminals and incorporated terminals.</S>
        <S ID="S-21239">A pre-order traversal of the fully decorated binarization tree gives us the following binary SCFG rules:</S>
      </P>
      <P>
        <S ID="S-21240">Analogous to the &#8220;dotted rules&#8221; in Earley parsing for monolingual CFGs, the names we create for the virtual nonterminals reflect the underlying sub-alignments, ensuring intermediate states can be shared across different string-to-tree rules without causing ambiguity.</S>
        <S ID="S-21241">The whole binarization algorithm still runs in time linear in the number of symbols in the rule (including both terminals and nonterminals).</S>
        <S ID="S-21242">We now turn to tree transducer rules.</S>
        <S ID="S-21243">We view each left-hand side subtree as a monolithic nonterminal symbol and factor each transducer rule into two SCFG rules: one from the root nonterminal to the subtree, and the other from the subtree to the leaves.</S>
        <S ID="S-21244">In this way we can uniquely reconstruct the transducer derivation using the two-step SCFG derivation.</S>
        <S ID="S-21245">For example, consider the following tree transducer rule: We create a specific nonterminal, say, T 859 , which uniquely identifies the left-hand side subtree.</S>
        <S ID="S-21246">This gives the following two SCFG rules:</S>
      </P>
      <P>
        <S ID="S-21247">The newly created nonterminals ensure that the newly created rules can only combine with one another to reconstruct the original rule, leaving the output of the transducer, as well as the probabilities it assigns to transductions, unchanged.</S>
        <S ID="S-21248">The problem of binarizing tree transducers is now reduced to the binarization of SCFG rules, which we solved previously.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>5. Experiments</HEADER>
      <P>
        <S ID="S-21249">In this section, we investigate two empirical questions with regard to synchronous binarization.</S>
      </P>
      <P>
        <S ID="S-21250"><REF ID="R-25" RPTR="32">Shapiro and Stephens (1991)</REF><REF ID="R-25" RPTR="34">Shapiro and Stephens (1991</REF>) and <REF ID="R-30" RPTR="42">Wu (1997</REF>, Section 4) show that the percentage of binarizable cases over all permutations of length n quickly approaches 0 as n grows</S>
      </P>
      <P>
        <S ID="S-21251">(see Figure 12).</S>
        <S ID="S-21252">However, for machine translation, the percentage of synchronous rules that are binarizable is what we care about.</S>
        <S ID="S-21253">We answer this question in both large-scale automatically aligned data and small-scale hand-aligned data.</S>
        <S ID="S-21254">Automatically Aligned Data.</S>
        <S ID="S-21255">Our rule set here is obtained by first doing word alignment using GIZA++ on a Chinese&#8211;English parallel corpus containing 50 million words in English, then parsing the English sentences using a variant of the Collins parser, and finally extracting rules using the graph-theoretic algorithm of <REF ID="R-07" RPTR="10">Galley et al. (2004)</REF>.</S>
        <S ID="S-21256">We did a spectrum analysis on the resulting rule set with 50,879,242 rules.</S>
        <S ID="S-21257">Figure 12 shows how the rules are distributed against their lengths (number of nonterminals).</S>
        <S ID="S-21258">We can see that the percentage of non-binarizable rules in each bucket of the same length does not exceed 25%.</S>
        <S ID="S-21259">Overall, 99.7% of the rules are binarizable.</S>
        <S ID="S-21260">Even for the 0.3% of rules that are not binarizable, human evaluations show that the majority are due to alignment errors.</S>
        <S ID="S-21261">Because the rule extraction process looks for rules that are consistent with both the automatic parses of the English sentences, and automatic word level alignments from GIZA++, errors in either parsing or word-level alignment can lead to noisy rules being input to the binarizer.</S>
        <S ID="S-21262">It is also interesting to know that 86.8% of the rules have monotonic permutations, i.e., either taking identical or totally inverted order.</S>
      </P>
      <P>
        <S ID="S-21263">One might wonder whether automatic alignments computed by GIZA++ are systematically biased toward or against binarizability.</S>
        <S ID="S-21264">If syntactic constraints not taken into account by GIZA++ enforce binarizability, automatic alignments could tend to contain spurious non-binarizable cases.</S>
        <S ID="S-21265">On the other hand, simply by preferring monotonic alignments, GIZA++ might tend to miss complex non-binarizable patterns.</S>
        <S ID="S-21266">To test this, we carried out experiments on hand-aligned sentence pairs with three language pairs: Chinese&#8211;English, French&#8211;English, and German&#8211;English.</S>
        <S ID="S-21267">Chinese&#8211;English Data.</S>
        <S ID="S-21268">For Chinese&#8211;English, we used the data of Liu, Liu, and Lin (2005) which contains 935 pairs of parallel sentences.</S>
        <S ID="S-21269">Of the 13,713 rules extracted using the same method described herein, 0.3% (44) are non-binarizable, which is exactly the Figure 12 The solid-line curve represents the distribution of all rules against permutation lengths.</S>
        <S ID="S-21270">The dashed-line stairs indicate the percentage of non-binarizable rules in our initial rule set, and the dotted line denotes that percentage among all permutations.</S>
        <S ID="S-21271">574 Huang et al. Binarization of Synchronous Context-Free Grammars same ratio as the GIZA-aligned data.</S>
        <S ID="S-21272">The following is an interesting example of nonbinarizable rules: where ... in with ... Mishira is the long phrase in shadow modifying Mishira.</S>
        <S ID="S-21273">Here the non-binarizable permutation is (3, 2, 5, 1, 4), which is reducible to (2, 4, 1, 3).</S>
        <S ID="S-21274">The SCFG version of the tree-transducer rule is as follows: where we indicate dependency links in solid arcs and permutation in dashed lines.</S>
        <S ID="S-21275">It is interesting to examine dependency structures, as some authors have argued that they are more likely to generalize across languages than phrase structures.</S>
        <S ID="S-21276">The Chinese ADVP 1 S) / d&#257;ngti&#257;n (lit., that day) is translated into an English PP 1 (on the same day), but the dependency structures on both sides are isomorphic (i.e., this is an extremely literal translation).</S>
        <S ID="S-21277">A simpler but slightly non-literal example is the following:</S>
      </P>
      <P>
        <S ID="S-21278">where the SCFG version of the tree-transducer rule (in the same format as the previous example) is: Note that the Chinese ADVP 1 &#219; e / j&#236;ny&#299;b&#249; modifying the verb VB 3 becomes a JJ 1 ( further) in the English translation modifying the object of the verb, NNS 4 , and this change also happens to PP 2 .</S>
        <S ID="S-21279">This is an example of syntactic divergence, where the dependency structures are not isomorphic between the two languages (<REF ID="R-06" RPTR="8">Eisner 2003</REF>).</S>
        <S ID="S-21280"><REF ID="R-30" RPTR="43">Wu (1997</REF>, page 158) has &#8220;been unable to find real examples&#8221; of non-binarizable cases, at least in &#8220;fixed-word-order languages that are lightly inflected, such as English</S>
      </P>
      <P>
        <S ID="S-21281">and Chinese.&#8221; Our empirical results not only confirm that this is largely correct (99.7% in our data sets), but also provide, for the first time, &#8220;real examples&#8221; between English and Chinese, verified by native speakers.</S>
        <S ID="S-21282">It is interesting to note that our non-binarizable examples include both cases of isomorphic and non-isomorphic dependency structures, indicating that it is difficult to find any general linguistic explanation that covers all such examples.</S>
        <S ID="S-21283">Wellington, Waxmonsky, and Melamed (2006) used a different measure of non-binarizability, which is on the sentence-level permutations, as opposed to rulelevel permutation as in our case, and reported 5% non-binarizable cases for a different hand-aligned English&#8211;Chinese data set, but they did not provide real examples.</S>
        <S ID="S-21284">French&#8211;English Data.</S>
        <S ID="S-21285">We analyzed 447 hand-aligned French&#8211;English sentences from the NAACL 2003 alignment workshop (<REF ID="R-18" RPTR="23">Mihalcea and Pederson 2003</REF>).</S>
        <S ID="S-21286">We found only 2 out of 2,659 rules to be non-binarizable, or 0.1%.</S>
        <S ID="S-21287">One of these two is an instance of topicalization: The second instance is due to movement of an adverbial: German&#8211;English Data.</S>
        <S ID="S-21288">We analyzed 220 sentences from the Europarl corpus, handaligned by a native German speaker (Callison-Burch, personal communication).</S>
        <S ID="S-21289">Of 2,328 rules extracted, 13 were non-binarizable, or 0.6%.</S>
        <S ID="S-21290">Some cases are due to separable German verb prefixes: Here the German prefix auf is separated from the verb auffordern (request).</S>
        <S ID="S-21291">Another cause of non-binarizability is verb-final word order in German in embedded clauses: Although fewer than 1% of the rules were non-binarizable in each language pair we studied, German&#8211;English had the highest percentage with 0.6%.</S>
        <S ID="S-21292">The fact that the German&#8211;English examples are due to syntactic phenomena such as separable prefixes and verb-final word order may indicate that an MT system would have less freedom to choose an equivalent binarizable reordering than in the case of the examples due to adverbial placement, heavy NP shift, and topicalization that we see in the Chinese&#8211; 576 Huang et al. Binarization of Synchronous Context-Free Grammars English and French&#8211;English data.</S>
        <S ID="S-21293">The results on binarizability of hand-aligned data for the three language pairs are summarized in Table 1.</S>
        <S ID="S-21294">It is worth noting that for most of these non-binarizable examples, there do exist alternative translations that only involve binarizable permutations.</S>
        <S ID="S-21295">For example, in Chinese&#8211;English Example (9), we can move the English PP on the same day to the first position (before will), which results in a binarizable permutation (1, 3, 2, 5, 4).</S>
        <S ID="S-21296">Similarly, we can avoid non-binarizability in French&#8211;English Example (12) by moving the English adverbial still under private ownership to the third position.</S>
        <S ID="S-21297">German&#8211;English Example (13) would also become binarizable by replacing call on with a single word request on the English side.</S>
        <S ID="S-21298">However, the point of this experiment is to test the ITG hypothesis by attempting to explain existing real data (the hand-aligned parallel text), rather than to generate fresh translations for a given source sentence, which is the topic of the subsequent decoding experiment.</S>
        <S ID="S-21299">This subsection not only provides the first solid confirmation of the existence of linguistically-motivated non-binarizable reorderings, but also motivates further theoretical studies on parsing and decoding with these nonbinarizable synchronous grammars, which is the topic of Sections 6 and 7.</S>
      </P>
      <P>
        <S ID="S-21300">We did experiments on our CKY-based decoder with two binarization methods.</S>
        <S ID="S-21301">It is the responsibility of the binarizer to instruct the decoder how to compute the language model scores from children nonterminals in each rule.</S>
        <S ID="S-21302">The baseline method is monolingual left-to-right binarization.</S>
        <S ID="S-21303">As shown in Section 2, decoding complexity with this method is exponential in the size of the longest rule, and because we postpone all the language model scorings, pruning in this case is also biased.</S>
        <S ID="S-21304">To move on to synchronous binarization, we first did an experiment using this baseline system without the 0.3% of rules that are non-binarizable and did not observe any difference in BLEU scores.</S>
        <S ID="S-21305">This indicates that we can safely focus on the binarizable rules, discarding the rest.</S>
        <S ID="S-21306">The decoder now works on the binary translation rules supplied by an external synchronous binarizer.</S>
        <S ID="S-21307">As shown in Section 1, this results in a simplified decoder with a polynomial time complexity, allowing less aggressive and more effective pruning based on both translation model and language model scores.</S>
        <S ID="S-21308">We compare the two binarization schemes in terms of translation quality with various pruning thresholds.</S>
        <S ID="S-21309">The rule set is that of the previous section.</S>
        <S ID="S-21310">The test set has 116 Chinese sentences of no longer than 15 words, taken from the NIST 2002 test set.</S>
        <S ID="S-21311">Both systems use trigram as the integrated language model.</S>
        <S ID="S-21312">Figure 13 demonstrates that decoding accuracy is significantly improved after synchronous binarization.</S>
        <S ID="S-21313">The number of edges (or items, in the deductive parsing terminology) proposed during</S>
      </P>
      <P>
        <S ID="S-21314">decoding is used as a measure of the size of search space, or time efficiency.</S>
        <S ID="S-21315">Our system is consistently faster and more accurate than the baseline system.</S>
        <S ID="S-21316">We also compare the top result of our synchronous binarization system with the state-of-the-art alignment-template system (ATS) (<REF ID="R-20" RPTR="24">Och and Ney 2004</REF>).</S>
        <S ID="S-21317">The results are shown in Table 2.</S>
        <S ID="S-21318">Our system has a promising improvement over the ATS system, which is trained on a larger data set but tuned independently.</S>
        <S ID="S-21319">A larger-scale system based on our best result performs very well in the 2006 NIST MT Evaluation (ISI Machine Translation Team 2006), achieving the best overall BLEU scores in the Chineseto-English track among all participants.</S>
        <S ID="S-21320">4 The readers are referred to <REF ID="R-07" RPTR="11">Galley et al. (2004)</REF> for details of the decoder and the overall system.</S>
      </P>
    </DIV>
    <DIV DEPTH="0">
      <HEADER>6. One-Sided Binarization</HEADER>
      <P>
        <S ID="S-21321">In this section and the following section, we discuss techniques for handling rules that are not binarizable.</S>
        <S ID="S-21322">This is primarily of theoretical interest, as we found that they constitute a small fraction of all rules, and removing these did not affect our Chinese-to- English translation results.</S>
        <S ID="S-21323">However, non-binarizable rules are shown to be important in explaining existing hand-aligned data, especially for other language pairs such as German&#8211;English (see Section 5.2, as well as Wellington, Waxmonsky, and Melamed [2006]).</S>
        <S ID="S-21324">Non-binarizable rules may also become more important as machine translation</S>
      </P>
      <P>
        <S ID="S-21325">A summary of the four factorization algorithms, and the &#8220;incremental relaxation&#8221; theme of the whole paper.</S>
        <S ID="S-21326">Algorithms 2&#8211;4 are for non-binarizable SCFGs, and are mainly of theoretical interest.</S>
        <S ID="S-21327">Algorithms 1&#8211;3 make fewer and fewer assumptions on the strategy space, and produce parsing strategies closer and closer to the optimal.</S>
        <S ID="S-21328">Algorithm 4 further improves Algorithm 3.</S>
      </P>
      <P>
        <S ID="S-21329">systems improve.</S>
        <S ID="S-21330">Synchronous grammars that go beyond the power of SCFG (and therefore binary SCFG) have been defined by <REF ID="R-27" RPTR="36">Shieber and Schabes (1990)</REF> and <REF ID="R-21" RPTR="25">Rambow and Satta (1999)</REF>, and motivated for machine translation by <REF ID="R-17" RPTR="21">Melamed (2003)</REF>, although previous work has not given algorithms for finding efficient and optimal parsing strategies for general SCFGs, which we believe is an important problem.</S>
        <S ID="S-21331">In the remainder of this section and the next section, we will present a series of algorithms that produce increasingly faster parsing strategies, by gradually relaxing the strong &#8220;continuity&#8221; constraint made by the synchronous binarization technique.</S>
        <S ID="S-21332">As that technique requires continuity on both languages, we will first study a relaxation where binarized rules are always continuous in one of the two languages, but may be discontinuous in the other.</S>
        <S ID="S-21333">We will present a CKY-style algorithm (Section 6.2) for finding the best parsing strategy under this new constraint, which we call one-sided binarization.</S>
        <S ID="S-21334">In practice, this factorization has the advantage that we need to maintain only one set of language model boundary words for each partial hypothesis.</S>
        <S ID="S-21335">We will see, however, that it is not always possible to achieve the best asymptotic complexity within this constraint.</S>
        <S ID="S-21336">But most importantly, as the synchronous binarization algorithm covers most of the SCFG rules in real data, the one-sided binarization we discuss in this section is able to achieve optimal parsing complexity for most of the non-binarizable rules in real data.</S>
        <S ID="S-21337">So this section can be viewed as a middle step between the synchronous binarization we focus on in the previous sections and the optimal factorization coming in Section 7, and also a trade-off point between simplicity and asymptotic complexity for parsing strategies of SCFGs.</S>
        <S ID="S-21338">Table 3 summarizes this incremental structure of the whole paper.</S>
      </P>
      <P>
        <S ID="S-21339">The complexity for decoding given a grammar factorization can be expressed in terms of the number of spans of the items being combined at each step.</S>
        <S ID="S-21340">As an example, Figure 14 shows the three combination steps for one factorization of the non-binarizable rule:</S>
      </P>
      <P>
        <S ID="S-21341">the rule&#8217;s child nonterminals.</S>
        <S ID="S-21342">Each step combines two dynamic programming items covering disjoint spans of the Chinese input, and creates a new item covering the union of the spans.</S>
        <S ID="S-21343">For example, in the first combination step shown in Figure 14, where nonterminals A and B are combined, A has one span in Chinese, from position y 1 to y 2 in the string, and B has one span from y 3 to y 4 .</S>
        <S ID="S-21344">The chart entry for the nonterminal</S>
      </P>
      <P>
        <S ID="S-21345">The tree at the top of the figure defines a three-step decoding strategy for rule (15), building an English output string on the horizontal axis as we process the Chinese input on the vertical axis.</S>
        <S ID="S-21346">In each step, the two subsets of nonterminals in the inner marked spans are combined into a new chart item with the outer spans.</S>
        <S ID="S-21347">The intersection of the outer spans, shaded, has now been processed.</S>
        <S ID="S-21348">pair {A, B} must record a total of four string indices: positions y 1 , y 2 , y 3 , and y 4 in the Chinese string.</S>
        <S ID="S-21349">Any combination of two subsets of the rule&#8217;s nonterminals involves the indices for the spans of each subset.</S>
        <S ID="S-21350">However, some of the indices are tied together: If we are joining two spans into one span in the new item, one of the original spans&#8217; end-points must be equal to another span&#8217;s beginning point.</S>
        <S ID="S-21351">For example, the index y 2 is the end-point of A in Chinese, as well as the beginning position of D.</S>
        <S ID="S-21352">In general, if we are combining a subset B of nonterminals having b spans with a subset C having c spans, to produce a spans for a combined subset A = B &#8746; C, the number of linked indices is b + c &#8722; a.</S>
        <S ID="S-21353">In the example of the first step of Figure 14, subset {A} has two spans (one in each language) so b = 1, and {B} also has two spans, so c = 1.</S>
        <S ID="S-21354">The combined subset {A, B} has two spans, so a = 2.</S>
        <S ID="S-21355">The total number of indices involved in a combination of two subsets is</S>
      </P>
      <P>
        <S ID="S-21356">number of shared indices.</S>
        <S ID="S-21357">In the first step of Figure 14, a + b + c = 1 + 1 + 2 = 4 total indices, and therefore the complexity of this step is O(|w |4 ) where |w |is the length of the input Chinese strings, and we ignore the language model for the moment.</S>
        <S ID="S-21358">Applying this formula to the second and third step, we see that the second is O(|w |5 ), and the third is again O(|w |4 ).</S>
        <S ID="S-21359">In order to find a good decoding strategy for a given grammar rule, we need to search over possible orders in which partial translation hypotheses can be built by successively combining nonterminals.</S>
        <S ID="S-21360">Any strategy we find can be used for synchronous parsing as well as decoding.</S>
        <S ID="S-21361">For example, the strategy shown in Figure 14 can be used to parse an input Chinese/English string pair.</S>
        <S ID="S-21362">The complexity of each step is determined by the total number of indices into both the Chinese and English strings.</S>
        <S ID="S-21363">Each step in</S>
      </P>
      <P>
        <S ID="S-21364">1: function BESTCONTINUOUSPARSER(&#960;) 2: n = |&#960;| 3: for span &#8592; 1 to n &#8722; 1 do 4: for i &#8592; 1 to n &#8722; span do 5: A = {i...i + span} 6: best[A] = &#8734; 7: for j &#8592; i + 1 to i + span do 8: B = {i...j &#8722; 1} 9: C = {j...i + span} 10: Let a &#960; , b &#960; , and c &#960; denote the number of &#960;(A), &#960;(B), and &#960;(C)&#8217;s spans 11: compl[A &#8594; B C] = max {a &#960; + b &#960; + c &#960; , best[B], best[C]} 12: if compl[A &#8594; B C] &amp;lt; best[A] then 13: best[A] = compl[A &#8594; B C] 14: rule[A] = A &#8594; B C 15: return best[{1...n}] the diagram has three indices into the English string, so the complexity of the first step is O(|w |4+3 ) = O(|w |7 ), the second step is O(|w |8 ), and the third is again O(|w |7 ).</S>
      </P>
      <P>
        <S ID="S-21365">The O(n 3 ) algorithm we present in this section can find good factorizations for most non-binarizable rules; we discuss optimal factorization in the next section.</S>
        <S ID="S-21366">This algorithm, shown in Algorithm 2, considers only factorizations that have only one span in one of the two languages, and efficiently searches over all such factorizations by combining adjacent spans with CKY-style parsing.</S>
        <S ID="S-21367">5 The input is an SCFG grammar rule in its abstract form, which is a permutation, and best is a dynamic programming table used to store the lowest complexity with which we can parse a given subset of the input rule&#8217;s child nonterminals.</S>
        <S ID="S-21368">Although this CKY-style algorithm finds the best grammar factorization maintaining continuous spans in one of the two dimensions, in general the best factorization may require discontinuous spans in both dimensions.</S>
        <S ID="S-21369">As an example, the following pattern causes problems for the algorithm regardless of which of the dimensions it parses across:</S>
      </P>
      <P>
        <S ID="S-21370">Left, a general pattern of non-binarizable permutations.</S>
        <S ID="S-21371">Center, a partially completed chart item with two spans in each dimension; the intersection of the completed spans is shaded.</S>
        <S ID="S-21372">Right, the combination of the item from the center panel with a singleton item.</S>
        <S ID="S-21373">The two subsets of nonterminals in the inner marked spans are combined into a new chart item with the outer spans.</S>
        <S ID="S-21374">beginning at position 1 and one beginning at position n 2 + 1, and adding one nonterminal at a time to the partially completed item, as shown in Figure 15 (right).</S>
        <S ID="S-21375">However, our CKY factorization algorithm will give a factorization with n/2 discontinuous spans in one dimension.</S>
        <S ID="S-21376">Thus in the worst case, the number of spans found by the cubic-time algorithm grows with n, even when a constant number of spans is possible, implying that there is no approximation ratio on how close the algorithm will get to the optimal solution.</S>
      </P>
      <P>
        <S ID="S-21377">The method presented in the previous section is not optimal for all permutations, because in some cases it is better to maintain multiple spans in the output language (despite the extra language model state that is needed) in order to maintain continuous spans in the input language.</S>
        <S ID="S-21378">In this section we give a method for finding decoding strategies that are guaranteed to be optimal in their asymptotic complexity.</S>
        <S ID="S-21379">This method can also be used to find the optimal strategy for synchronous parsing (alignment) using complex rules.</S>
        <S ID="S-21380">This answers a question left open by earlier work in synchronous grammars: Although <REF ID="R-23" RPTR="29">Satta and Peserico (2005)</REF> show that tabular parsing of a worst-case SCFG can be NP-hard, they do not give a procedure for finding the complexity of an arbitrary input grammar.</S>
        <S ID="S-21381">Similarly, <REF ID="R-17" RPTR="22">Melamed (2003)</REF> defines the cardinality of a grammar, and discusses the interaction of this property with parsing complexity, but does not show how to find a normal form for a grammar with the lowest possible cardinality.</S>
        <S ID="S-21382">We show below how to analyze parsing and decoding strategies for a given SCFG rule in Section 7.1, and then present an exponential-time dynamic programming algorithm for finding the best strategy in Section 7.2.</S>
        <S ID="S-21383">We prove that factorizing an SCFG rule into smaller SCFG rules is a safe preprocessing step for finding the best strategy in Section 7.4, which leads to much faster computation in many cases.</S>
        <S ID="S-21384">First, however, we take a brief detour to discuss modifying our a + b + c formula from the previous section in order to take the state from an m-gram language model into account during</S>
      </P>
      <P>
        <S ID="S-21385">First, how do we analyze algorithms that create discontinuous spans in both the source and target language?</S>
        <S ID="S-21386">It turns out that the analysis in Section 6.1 for counting string indices in terms of spans in fact applies in the same way to both of our languages.</S>
        <S ID="S-21387">For synchronous parsing, if we are combining item B with b e target spans and b f source spans with item C having c e target spans and c f source spans to form new item A having a e target spans and a f source spans, the complexity of the operation is O(|w |a e+b e +c e +a f +b f +c f ).</S>
        <S ID="S-21388">The a + b + c formula can also be generalized for decoding with an integrated m-gram language model.</S>
        <S ID="S-21389">At first glance, because we need to maintain (m &#8722; 1) boundary words at both the left and right edges of each target span, the total number of interacting variables is: 2(m &#8722; 1)(b e + c e ) + a f + b f + c f However, by using the &#8220;hook trick&#8221; suggested by Huang, Zhang, and Gildea (2005), we can optimize the decoding algorithm by factorizing the dynamic programming combination rule into two steps.</S>
        <S ID="S-21390">One step incorporates the language model probability, and the other step combines adjacent spans in the input language and incorporates the SCFG rule probability.</S>
        <S ID="S-21391">The hook trick for a bigram language model and binary SCFG is shown in Figure 16.</S>
        <S ID="S-21392">In the equations of Figure 16, i,j,k range over 1 to |w|, the length of the input foreign sentence, and u,v,v 1 ,u 2 (or u,v,v 2 ,u 1 ) range over possible English words, which we assume to take O(|w|) possible values.</S>
        <S ID="S-21393">There are seven free variables related to input size for doing the maximization computation, hence the algorithmic complexity is O(|w |7 ).</S>
        <S ID="S-21394">The two terms in Figure 16 (top) within the first level of the max operator correspond to straight and inverted ITG rules.</S>
        <S ID="S-21395">Figure 16 (bottom) shows how to decompose the first term; the same method applies to the second term.</S>
        <S ID="S-21396">Counting the free variables enclosed in the innermost max operator, we get five: i, k, u, v 1 , and u 2 .</S>
        <S ID="S-21397">The where</S>
      </P>
      <P>
        <S ID="S-21398">The hook trick for machine translation decoding with a binary SCFG (equivalent to Inversion Transduction Grammar).</S>
        <S ID="S-21399">The fundamental dynamic programming equation is shown at the top, with an efficient factorization shown below.</S>
      </P>
      <P>
        <S ID="S-21400">decomposition eliminates one free variable, v 1 .</S>
        <S ID="S-21401">In the outermost level, there are six free variables left.</S>
        <S ID="S-21402">The maximum number of interacting variables is six overall.</S>
        <S ID="S-21403">So, we have reduced the complexity of ITG decoding using the bigram language model from O(|w |7 ) to O(|w |6 ).</S>
        <S ID="S-21404">When we generalize the hook trick for any m-gram language model and more complex SCFGs, each left boundary for a substring of an output language hypothesis contains m &#8722; 1 words of language model state, and each right boundary contains a &#8220;hook&#8221; specifying what the next m &#8722; 1 words must be.</S>
        <S ID="S-21405">This yields a complexity analysis similar to that for synchronous parsing, based on the total number of boundaries, but now multiplied by a factor of m &#8722; 1: for translation from source to target.</S>
        <S ID="S-21406">(m &#8722; 1)(a e + b e + c e ) + a f + b f + c f (17)</S>
      </P>
      <P>
        <S ID="S-21407">The number of m-gram weighted spans of a constituent, denoted a m , is defined as the number of source spans plus the number target spans weighted by the language model factor (m &#8722; 1): a m = a f + (m &#8722; 1)a e (18) Using this notation, we can rewrite the expression for the complexity of decoding in Equation 17 as a simple sum of the numbers of weighted spans of constituent subsets A, B, and C: a m + b m + c m (19) and more generally when k &#8805; 2 constituents are combined together:</S>
      </P>
      <P>
        <S ID="S-21408">It can be seen that, as m grows, the parsing/decoding strategies that favor contiguity on the output side will prevail.</S>
        <S ID="S-21409">This effect is demonstrated by the experimental results in Section 7.5.</S>
        <S ID="S-21410">This analysis applies to one combination of two subsets of a rule&#8217;s children during parsing or decoding.</S>
        <S ID="S-21411">A strategy for parsing (or decoding) the entire rule must build up the complete set of the rule&#8217;s children through a sequence of such combinations.</S>
        <S ID="S-21412">Thus a parsing strategy corresponds to a recursive partitioning of the rule&#8217;s children, that is, an unordered rooted tree having the child nonterminals as leaves.</S>
        <S ID="S-21413">Each node in the partition tree represents a subset of nonterminals used as a partial result in the chart for parsing, built by combining the subsets corresponding to the node&#8217;s children.</S>
        <S ID="S-21414">This combination step at each node has complexity determined by the number of spans, and the overall complexity of a parsing strategy is the complexity of the strategy&#8217;s worst combination step.</S>
        <S ID="S-21415">We wish to find the recursive partition with the lowest overall complexity.</S>
        <S ID="S-21416">Unfortunately, the number of recursive partitions of n items grows super- i=1 584 Huang et al. Binarization of Synchronous Context-Free Grammars exponentially, as 0.175n!n &#8722;3/2 2.59 n = &#920;(&#915;(n + 1)2.59 n ) (<REF ID="R-24" RPTR="30">Schr&#246;der 1870</REF>, Problem IV).</S>
        <S ID="S-21417">6 More formally, the optimization over the space of all recursive partitions is expressed as:</S>
      </P>
      <P>
        <S ID="S-21418">where compl(A &#8594; B 1 ...B k ) is given by Equation (20).</S>
        <S ID="S-21419">This recursive equation implies that we can solve the optimization problem using dynamic programming techniques.</S>
      </P>
      <P>
        <S ID="S-21420">In this section we show that a branching factor of more than two is not necessary in our recursive partitions, by showing that any ternary combination can be factored into two binary combinations with no increase in complexity.</S>
        <S ID="S-21421">This fact leads to a more efficient, but still exponential, algorithm for finding the best parsing strategy for a given SCFG rule.</S>
        <S ID="S-21422">Theorem 3 For any SCFG rule, if there exists a recursive partition of child nonterminals which enables tabular parsing of an input sentence w in time O(|w |k ), then there exists a recursive binary partition whose corresponding parser is also O(|w |k ).</S>
        <S ID="S-21423">Proof We use the notion of number of weighted spans (Equation (20)) to concisely analyze the complexity of synchronous parsing/decoding.</S>
        <S ID="S-21424">For any fixed m, we count a constituent&#8217;s number of spans using the weighted span value from Equation (18), and we drop both the adjective &#8220;weighted&#8221; and the m subscript from this point forward.</S>
        <S ID="S-21425">If we are combining k subsets B i (i = 1, ..., k, k &#8805; 2) together to produce a new subset A = &#8899; i B i, the generalized formula for counting the total number of indices is</S>
      </P>
      <P>
        <S ID="S-21426">where b i is the number of spans for B i and a is the number of spans for the resulting item A.</S>
        <S ID="S-21427">Consider a ternary rule X &#8594; A B C where X has x spans, A has a spans, B has b spans, and C has c spans.</S>
        <S ID="S-21428">In the example shown in Figure 17, x = 2, a = 2, b = 1, and c =</S>
      </P>
      <P>
        <S ID="S-21429">and refer to the number of spans in partial constituent Y as y.</S>
        <S ID="S-21430">Parsing Y &#8594; A B takes time O(|w |y+a+b ), so we need to show that y + a + b &#8804; a + b + c + x to show that we can parse this new rule in no more time than the original ternary rule.</S>
        <S ID="S-21431">Subtracting a + b from both sides, we need to prove that y &#8804; c + x Each of the y spans in Y corresponds to a left edge.</S>
        <S ID="S-21432">(In the case of decoding, each edge has a multiplicity of (m &#8722; 1) on the output language side.</S>
        <S ID="S-21433">) The left edge in each span of Y corresponds to the left edge of a span in X or to the right edge of a span in C.</S>
        <S ID="S-21434">Therefore, Y has at most one span for each span in C &#8746; X , so y &#8804; c + x. Returning to the first rule in our factorization, the time to parse X &#8594; Y C is O(|w |x+y+c ).</S>
        <S ID="S-21435">We know that y &#8804; a + b since Y was formed from A and B.</S>
        <S ID="S-21436">Therefore x + y + c &#8804; x + (a + b) + c so parsing X &#8594; Y C also takes no more time than the original rule X &#8594; A B C.</S>
        <S ID="S-21437">By induction over the number of subsets, a rule having any number of subsets on the righthand side can be converted into a series of binary rules.</S>
        <S ID="S-21438">&#65533; Our finding that combining no more than two subsets of children at a time is optimal implies that we need consider only binary recursive partitions, which correspond to unordered binary rooted trees having the SCFG rule&#8217;s child nonterminals as leaves.</S>
        <S ID="S-21439">The (2n&#8722;3)!</S>
        <S ID="S-21440">total number of binary recursive partitions of n nodes is 2 n&#8722;2 (n&#8722;2)!</S>
        <S ID="S-21441">= &#920;(&#915;(n &#8722; 2 1 )2n&#8722;1 ) (<REF ID="R-24" RPTR="31">Schr&#246;der 1870</REF>, Problem III).</S>
        <S ID="S-21442">Note that this number grows much faster than the Catalan Number, which characterizes the number of bracketings representing the search space of synchronous binarization (Section 4).</S>
        <S ID="S-21443">Although the total number of binary recursive partitions is still superexponential, the binary branching property also enables a straightforward dynamic programming algorithm, shown in Algorithm 3.</S>
        <S ID="S-21444">The same algorithm can be used to find optimal strategies for synchronous parsing or for m-gram decoding: for parsing, the variables a, b, and c in Line 9 refer to the total number of spans of A, B, and C (Equation (16)), Figure 17 Left, example spans for a ternary rule decomposition X &#8594; A B C.</S>
        <S ID="S-21445">Each symbol represents a subset of nonterminals from the original SCFG rule, and the subsets may cover discontinuous spans in either language.</S>
        <S ID="S-21446">Line segments represent the projection of each set of child nonterminals into a single language, as in Figure 15.</S>
        <S ID="S-21447">Right, factorization into X &#8594; Y C and Y &#8594; A B.</S>
      </P>
      <P>
        <S ID="S-21448">2: n = |&#960;| 3: for i &#8592; 2 to n do 4: for A &#8834; {1...n} s.t.</S>
        <S ID="S-21449">|A |= i do 5: best[A] &#8592; &#8734; 6: for B, C s.t.</S>
        <S ID="S-21450">A = B &#8746; C &#8743; B &#8745; C = &#8709; do 7: Let a, b, and c denote the number of 8: (A, &#960;(A)), (B, &#960;(B)), and (C, &#960;(C))&#8217;s spans 9: compl[A &#8594; B C] = max {a + b + c, best[B], best[C]} 10: if compl[A &#8594; B C] &amp;lt; best[A] then 11: best[A] &#8592; compl[A &#8594; B C] 12: rule[A] &#8592; A &#8594; B C 13: return best[{1...n}]</S>
      </P>
      <P>
        <S ID="S-21451">while for decoding, a, b, and c refer to weighted spans (Equation (19)).</S>
        <S ID="S-21452">The dynamic programming states correspond to subsets of the input rule&#8217;s children, for which an optimal strategy has already been computed.</S>
        <S ID="S-21453">In each iteration of the algorithm&#8217;s inner loop, each of the child nonterminals is identified as belonging to B, C, or neither B nor C, making the total running time of the algorithm O(3 n ).</S>
        <S ID="S-21454">Although this is exponential in n, it is a significant improvement over considering all recursive partitions.</S>
        <S ID="S-21455">The algorithm can be improved by adopting a best-first exploration strategy (<REF ID="R-15" RPTR="19">Knuth 1977</REF>), in which dynamic programming items are placed on a priority queue sorted according to their complexity, and only used to build further items after all items of lower complexity have been exhausted.</S>
        <S ID="S-21456">This technique, shown in Algorithm 4, guarantees polynomial-time processing on input permutations of bounded complexity.</S>
        <S ID="S-21457">To see why this is, observe that each rule of the form A &#8594; B C that has complexity no greater than k can be written using a string of k e &amp;lt; k indices into the target nonterminal string to represent the spans&#8217; boundaries.</S>
        <S ID="S-21458">For each index we must specify whether the corresponding nonterminal either starts a span of subset B, starts a span of subset C, or ends a span of B &#8746; C.</S>
        <S ID="S-21459">Therefore there are O((3n) k ) rules of complexity no greater than k.</S>
        <S ID="S-21460">If there exists a parsing strategy for the entire rule with complexity k, the best-first algorithm will find it after, in the worst case, popping all O((3n) k ) rules of complexity less than or equal to k off of the heap in the outer loop, and combining each one with all other O((3n) k ) such rules in the inner loop, for a total running time of O(9 k n 2k ).</S>
        <S ID="S-21461">Although the algorithm is still exponential in the rule length n in the worst case (when k is linearly correlated to n), the best-first behavior makes it much more practical for our empirically observed rules.</S>
      </P>
      <P>
        <S ID="S-21462">One might wonder whether it is necessary to consider all combinations of all subsets of nonterminals, or whether an optimal parsing strategy can be found by adding one nonterminal at a time to an existing subset of nonterminals until the entire permutation has been covered.</S>
        <S ID="S-21463">Were such an assumption warranted, this would enable an O(n2 n ) dynamic programming algorithm.</S>
        <S ID="S-21464">It turns out that one-at-a-time parsing strategies are sometimes not optimal.</S>
        <S ID="S-21465">For example, the permutation (4, 7, 3, 8, 1, 6, 2, 5), shown in Figure 18, can be parsed in time O(|w |8 ) using unconstrained subsets, but only in</S>
      </P>
      <P>
        <S ID="S-21466">The permutation (4, 7, 3, 8, 1, 6, 2, 5) cannot be efficiently parsed by adding one nonterminal at a time.</S>
        <S ID="S-21467">The optimal grouping of nonterminals is shown on the right.</S>
        <S ID="S-21468">time O(|w |10 ) by adding one nonterminal at a time.</S>
        <S ID="S-21469">All permutations of less than eight elements can be optimally parsed by adding one element at a time.</S>
      </P>
      <P>
        <S ID="S-21470">In this subsection, we show that an optimal parsing strategy can be found by first factoring an SCFG rule into a sequence of shorter SCFG rules, if possible, and then considering each of the new rules independently.</S>
        <S ID="S-21471">The first step can be done efficiently using the algorithms of <REF ID="R-31" RPTR="48">Zhang and Gildea (2007)</REF><REF ID="R-10" RPTR="16">(2007)</REF>.</S>
        <S ID="S-21472">The second step can be done in time O(9 k c &#183; n 2k c) using Algorithm 4, where k c is the complexity of the longest SCFG rule after factorizations, implying that k c &#8804; (n + 4).</S>
        <S ID="S-21473">We show that this two-step process is optimal, by proving that the optimal parsing strategy for the initial rule will not need to build subsets of children that cross the boundaries of the factorization into shorter SCFG rules.</S>
        <S ID="S-21474">Figure 19 shows a permutation that contains permutations of fewer numbers within itself so that the entire permutation can be decomposed hierarchically.</S>
        <S ID="S-21475">We prove that if there is a contiguous block of numbers that are permuted within a permutation, the Algorithm 4 Best-first search for the optimal parsing strategy.</S>
      </P>
      <P>
        <S ID="S-21476">1: function BESTDISCONTINUOUSPARSER(&#960;) 2: n = |&#960;| 3: for A &#8834; {1...n} do 4: chart[A] = &#8734; 5: for i &#8592; 1...n do 6: push[heap, 0, {i}] &#8882; Priority queue of good subsets 7: while chart[{1 .</S>
        <S ID="S-21477">.</S>
        <S ID="S-21478">.</S>
        <S ID="S-21479">n}] = &#8734; do 8: B &#8592; pop(heap) 9: chart[B] &#8592; best[B] &#8882; guaranteed to have found optimal analysis for subset B 10: for C s.t.</S>
        <S ID="S-21480">B &#8745; C = &#8709; &#8743; chart[C] &amp;lt; &#8734; do 11: A &#8592; B &#8746; C 12: Let a, b, and c denote the number of 13: (A, &#960;(A)), (B, &#960;(B)), and (C, &#960;(C))&#8217;s spans 14: compl[A &#8594; B C] = max {a + b + c, best[B], best[C]} 15: if compl[A &#8594; B C] &amp;lt; best[A] then 16: best[A] &#8592; compl[A &#8594; B C] 17: rule[A] &#8592; A &#8594; B C 18: push(heap, best[A], A) 19: return best[{1...n}] 588 Huang et al.</S>
      </P>
      <P>
        <S ID="S-21481">A permutation that can be decomposed into smaller permutations hierarchically.</S>
        <S ID="S-21482">We prove that this decomposition corresponds to the optimal parsing strategy for an SCFG rule with this permutation.</S>
        <S ID="S-21483">optimal parsing strategy for the entire permutation does not have to involve interactions between subsets of numbers inside and outside the block.</S>
        <S ID="S-21484">We call filled entries in the permutation matrix pebbles; the contiguous blocks are shaded in Figure 19, and form submatrices with a pebble in each row and column.</S>
        <S ID="S-21485">We can first decompose a given permutation into a hierarchy of smaller permutations as the tree shown in Figure 19 and then apply the discontinuous strategy to the non-decomposable permutations in the tree.</S>
        <S ID="S-21486">So, in this example, we just need to focus on the optimal parsing strategy for (2, 4, 1, 3), which is applied to permute (4, 5, 6, 7) into (5, 7, 4, 6).</S>
        <S ID="S-21487">By doing this kind of minimization, we can effectively reduce the search space without losing optimality of the parsing strategy for the original permutation.</S>
        <S ID="S-21488">Theorem 4 For any SCFG rule, if there exists a recursive partition of child nonterminals which enables tabular parsing of an input sentence w in time O(|w |k ), and if S is a subset of child nonterminals forming a single continuous span in each language, then there exists a recursive partition containing S as a member whose corresponding parser is also O(|w |k ).</S>
        <S ID="S-21489">See the Appendix for the proof.</S>
        <S ID="S-21490">See Table 3 for a summary of the four factorization algorithms presented in this article (Algorithms 3 and 4 can be improved by first factorizing the permutation into smaller permutations [Section 7.4]).</S>
      </P>
      <P>
        <S ID="S-21491">The combination of minimizing SCFG rule length as a preprocessing step and then applying the best-first version of Algorithm 3 makes it possible to find optimal parsing strategies for all of the rules in the large Chinese&#8211;English rule set used for our decoding experiments.</S>
        <S ID="S-21492">For the 157,212 non-binarizable rules (0.3% of the total), the complexity of the optimal parsing strategies is shown in Table 4.</S>
        <S ID="S-21493">Although the worst parsing complexity is O(|w |12 ), this is only achieved by a single rule.</S>
        <S ID="S-21494">The best-first analyzer takes approximately five minutes of CPU time to analyze this single rule, but processes all others in less than one second.</S>
        <S ID="S-21495">We tested the CKY-based factorization algorithm on our set of non-binarizable rules extracted from the Chinese&#8211;English data.</S>
        <S ID="S-21496">The CKY-on-English method found an optimal parsing strategy for 98% of the rules, and its worst-case complexity over the entire ruleset was O(|w |15 ), rather than the optimal O(|w |12 ).</S>
        <S ID="S-21497">If we run CKY factorization from two directions (one for the permutation &#960; and the other for the permutation &#960; &#8722;1 ) and take the minimum of both, we can get an even better approximation.</S>
        <S ID="S-21498">In Table 4, we compare the approximate strategy which takes the minimum of CKY runs for 589 Computational Linguistics Volume 35, Number 4 Table 4 The distribution of parsing complexities of non-binarizable rules extracted from the GIZA-aligned Chinese&#8211;English data in Section 5.</S>
        <S ID="S-21499">The first column denotes the exponent of the time complexity&#8212;for example, 10 means O(|w |10 ).</S>
        <S ID="S-21500">opt denotes the optimal parsing strategy and cky-min denotes the approximation strategy that takes the better of the CKY results on both sides.</S>
      </P>
      <P>
        <S ID="S-21501">two languages, which we call CKY-min, with the optimal strategy.</S>
        <S ID="S-21502">For synchronous parsing, for 99.77% of the rules, the CKY-min method found an optimal strategy.</S>
        <S ID="S-21503">When generalized for m-gram integrated decoding, CKY maintains continuous spans on the output language and allows for discontinuous parsing on the input sentence.</S>
        <S ID="S-21504">The difference between CKY-on-output and the optimal decoding strategy was negligible in the situation of trigram-integrated decoding for the given rules.</S>
        <S ID="S-21505">The worst-case complexity for decoding into English by CKY-on-English was O(|w |18 ), versus O(|w |17 ) from the optimal strategy.</S>
        <S ID="S-21506">The CKY-on-English approach found an optimal decoding strategy for 99.97% of the non-binarizable rules.</S>
        <S ID="S-21507">The CKY-min strategy was even better, only finding sub-optimal results for six rules out of all rules, which translates to 99.996%.</S>
        <S ID="S-21508">In Table 4, we have also included the comparison for translating into Chinese, in which case the inverted permutations are used and the language model weight is put on the Chinese side.</S>
        <S ID="S-21509">A similar approximation accuracy was achieved.</S>
        <S ID="S-21510">7.6 Bounds on Complexity of Factorization Given that our algorithms for optimal factorization are exponential, it is natural to ask whether the problem is provably NP-complete.</S>
        <S ID="S-21511"><REF ID="R-08" RPTR="14">Gildea and &#352;tefankovi&#269; (2007)</REF><REF ID="R-10" RPTR="17">(2007)</REF> relate the problem of finding the optimal parsing strategy for a rule to computing the treewidth of a graph derived from the rule&#8217;s permutation.</S>
        <S ID="S-21512">Computing treewidth of arbitrary graphs is NP-complete (Arnborg, Corneil, and Proskurowski 1987), but the graphs derived from SCFG permutations have a restricted structure that it might be possible to exploit.</S>
        <S ID="S-21513">In particular, the graphs have degree no greater than six.</S>
        <S ID="S-21514">While computing treewidth for graphs of bounded degree nine was shown to be NP-complete by <REF ID="R-02" RPTR="1">Bodlaender and Thilikos (1997)</REF>, whether the treewidth problem for graphs of degree between three and eight is NP-complete is not known.</S>
        <S ID="S-21515">Thus, whether computing the optimal parsing strategy for an SCFG rule is NP-complete remains an interesting open problem.</S>
      </P>
      <P>
        <S ID="S-21516">This work develops a theory of binarization for synchronous context-free grammars.</S>
        <S ID="S-21517">We present a technique called synchronous binarization along with an efficient binarization algorithm.</S>
        <S ID="S-21518">Empirical study shows that the vast majority of syntactic reorderings, at least between languages like English and Chinese, can be efficiently decomposed into hierarchical binary reorderings.</S>
        <S ID="S-21519">As a result, decoding with n-gram models can be fast and accurate, making it possible for our syntax-based system to overtake a comparable phrase-based system in BLEU score.</S>
        <S ID="S-21520">There are, however, some interesting rules that are not binarizable, and we provide, for the first time, real examples verified by native speakers.</S>
        <S ID="S-21521">For these remaining rules, we have shown an exponential time algorithm for finding optimal parsing strategies, which runs quite fast with the help of two optimality-maintaining operations and the A* search strategy.</S>
        <S ID="S-21522">We also provide an efficient approximation, which usually finds optimal parsing strategies in practice.</S>
        <S ID="S-21523">As non-binarizable rules did not improve our translation system, these parsing strategies are primarily of theoretical interest, though they may become more important in future systems.</S>
      </P>
    </DIV>
  </BODY>
  <ACKNOWLEDGMENTS>
    <P>
      <S ID="S-21524">Much of this work was done while the first two authors were visiting USC/ISI.</S>
      <S ID="S-21525">This work was partially funded by NSF grants IIS-0428020 and EIA-0205456.</S>
      <S ID="S-21526">Appendix A. Proof of Theorem 4 We prove by contradiction.</S>
      <S ID="S-21527">Let us suppose that the optimal parsing strategy for a permutation P splits a contiguous block S of P into two subtrees T L and T R , as shown at the top of Figure 20, in either or both of which there are some pebbles from outside S.</S>
      <S ID="S-21528">As in Section 7, we count spans in this section using the weighted span value of Equation (18) to account for m-gram language model state.</S>
      <S ID="S-21529">We use d LO to denote the number of spans of the pebbles outside of S in T L .</S>
      <S ID="S-21530">d LI is the number of spans of the pebbles inside S for T L .</S>
      <S ID="S-21531">We use r L to denote the reduction in the number of spans achieved by merging the pebbles inside and outside of S for T L .</S>
      <S ID="S-21532">So, the number of spans of the root of T L is d LO + d LI &#8722; r L .</S>
      <S ID="S-21533">We have symmetric notions for T R .</S>
      <S ID="S-21534">We use d to denote the number of spans of the root of the subtree T after merging T L and T R .</S>
      <S ID="S-21535">The number of spans is annotated for each node in Figure 20.</S>
      <S ID="S-21536">Notice that (r R + r L ) &#8804; 2m because there are at most two boundaries shared by inside pebbles and outside pebbles in each language.</S>
      <S ID="S-21537">Each boundary in the source corresponds to the reduction of one span.</S>
      <S ID="S-21538">Each boundary in the target corresponds to the reduction of one weighted span of (m &#8722; 1).</S>
      <S ID="S-21539">In total, we can reduce the number of (weighted) spans by no more than 2(m &#8722; 1) + 2 = 2m.</S>
      <S ID="S-21540">This inequality implies either</S>
    </P>
    <P>
      <S ID="S-21541">Reorganization of a parsing strategy to build a continuous span S first.</S>
      <S ID="S-21542">Figure 21 gives a concrete example.</S>
      <S ID="S-21543">The permutation is (5, 7, 4, 6, 1, 2, 3).</S>
      <S ID="S-21544">The block S we focus on is (5, 7, 4, 6).</S>
      <S ID="S-21545">The original strategy at the top of the figure splits the block into T L and T R .</S>
      <S ID="S-21546">The improved strategy on the bottom merges the pebbles inside S together before making combinations with pebbles outside S.</S>
      <S ID="S-21547">Figure 21 An actual example of reorganization of a parsing strategy to build a continuous span S first.</S>
      <S ID="S-21548">Before, the overall strategy cost is (7m &#8722; 3).</S>
      <S ID="S-21549">After, the cost is (5m &#8722; 2).</S>
      <S ID="S-21550">Note that (m &#8805; 2).</S>
      <S ID="S-21551">We use black to represent pebbles in the right branch of the root node and white for the left branch.</S>
      <S ID="S-21552">Gray areas are continuous blocks within the permutation.</S>
      <S ID="S-21553">The reorganized strategy can be further improved by making another such transformation to allow for the lower right corner pebbles to group before interacting with the upper left corner.</S>
      <S ID="S-21554">592 Huang et al. Binarization of Synchronous Context-Free Grammars In general, we argue that we can have an equally good or better strategy by separating each of T L and T R into two trees involving pebbles purely inside or outside of S, as shown at the bottom of Figure 20.</S>
      <S ID="S-21555">The separation works by simply ignoring the pebbles that are not inside when creating the inside half of the tree or outside when doing the outside half throughout T L and T R .</S>
      <S ID="S-21556">Then we have four elementary subtrees T LO , T LI , T RI , and T RO .</S>
      <S ID="S-21557">In our new strategy, we recombine the four elementary trees by merging T LI and T RI to create a pebble first and merging the resulting pebble back into T LO to make a T &#8242; LO , and finally merging T&#8242; LO with T RO.</S>
      <S ID="S-21558">The elementary trees yield better strategies because the number of spans of each node in these trees is reduced or not changed as compared to that before separation.</S>
      <S ID="S-21559">Using the a + b + c formula with reduced a, b, and c will produce lower complexity.</S>
      <S ID="S-21560">Roughly speaking, the reason is the inside pebbles and outside pebbles are positioned side by side instead of mixed together.</S>
      <S ID="S-21561">Mathematically, the reduction of spans by combining both sides is upper-bounded by 2m, considering there are two boundaries in each language.</S>
      <S ID="S-21562">At the same time, the number of spans of either the inside pebbles or the outside pebbles is lower-bounded by 2m because both T L and T R only partially cover S.</S>
      <S ID="S-21563">Hence, we have the following set of inequalities:</S>
    </P>
    <P>
      <S ID="S-21564">Now we consider what happens when the pebble of S joins T LO .</S>
      <S ID="S-21565">Because T LO is created from T L by pruning away the pebbles that are inside S, the pebble of S can join T LO by taking the place of any trace of the pruned leaves and making the number of spans from the bottom up to the root no greater than in the counterpart nodes in T L .</S>
      <S ID="S-21566">So the fragment of the new left subtree T LO &#8242; with S being its leaf has a better yield than the original T L :</S>
    </P>
    <P>
      <S ID="S-21567">where we use T LO &#8242; /S to denote the tree fragment excluding the nodes under S.</S>
      <S ID="S-21568">The number of spans for each node in the reorganized tree is shown in Figure 20 (bottom), where r (&#8804; 2m) is the reduction in spans after combining the new pebble S with T LO .</S>
      <S ID="S-21569">r sums up the reductions achievable on the four boundaries of S with T LO , while r L sums up the reductions on some of the four boundaries.</S>
      <S ID="S-21570">Thus, r L &#8804; r The final yield of the updated strategy is</S>
    </P>
    <P>
      <S ID="S-21571">This simplifies to m &#8722; r &#8804; d LI + d RI &#8722; r R &#8722; r L This inequality is true because m &#8804; d LI , since there is at least one inside pebble in T L , and d RI &#8805; r R because d RI &#8805; m &#8805; r R , referring to Equation (A.1), and finally r &#8805; r L , as shown in Equation (A.7).</S>
      <S ID="S-21572">Figure 20 also demonstrates the re-distribution of numbers of spans after the reorganization.</S>
      <S ID="S-21573">In the example, the updated parsing/decoding complexity is O(|w |5m&#8722;2 ), better than before (O(|w |7m&#8722;3 )).</S>
      <S ID="S-21574">Therefore, any synchronous parsing/decoding strategy that crosses decomposition boundaries cannot be better than an optimized strategy that respects such boundaries.</S>
      <S ID="S-21575">&#65533;</S>
    </P>
  </ACKNOWLEDGMENTS>
  <REFERENCES>
    <REFERENCE ID="0">
      <RAUTHOR>Albert V Aho</RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE>1972</DATE>
    </REFERENCE>
    <REFERENCE ID="1">
      <RAUTHOR>Stefen Arnborg</RAUTHOR>
      <REFTITLE>Complexity of finding embeddings in a k-tree.</REFTITLE>
      <DATE>1987</DATE>
    </REFERENCE>
    <REFERENCE ID="2">
      <RAUTHOR>H L Bodlaender</RAUTHOR>
      <REFTITLE>Treewidth for graphs with small chordality.</REFTITLE>
      <DATE>1997</DATE>
    </REFERENCE>
    <REFERENCE ID="3">
      <RAUTHOR></RAUTHOR>
      <REFTITLE>Note extraite d&#8217;une lettre adress&#233;e.</REFTITLE>
      <DATE></DATE>
    </REFERENCE>
    <REFERENCE ID="4">
      <RAUTHOR>David Chiang</RAUTHOR>
      <REFTITLE>A hierarchical phrase-based model for statistical machine translation.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="5">
      <RAUTHOR>Thomas H Cormen</RAUTHOR>
      <REFTITLE>Introduction to Algorithms.</REFTITLE>
      <DATE>1990</DATE>
    </REFERENCE>
    <REFERENCE ID="6">
      <RAUTHOR>Jason Eisner</RAUTHOR>
      <REFTITLE>Learning non-isomorphic tree mappings for machine translation.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="7">
      <RAUTHOR>Michel Galley</RAUTHOR>
      <REFTITLE>What&#8217;s in a translation rule?</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="8">
      <RAUTHOR>Daniel Gildea</RAUTHOR>
      <REFTITLE>Worst-case synchronous grammar rules.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="9">
      <RAUTHOR>Ronald Graham</RAUTHOR>
      <REFTITLE>An efficient algorithm for determining the convex hull of a finite planar set. Information Processing Letters, 1:132&#8211;133. 594 et al.</REFTITLE>
      <DATE>1972</DATE>
    </REFERENCE>
    <REFERENCE ID="10">
      <RAUTHOR></RAUTHOR>
      <REFTITLE>Binarization of Synchronous Context-Free Grammars Huang, Liang.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
    <REFERENCE ID="11">
      <RAUTHOR>Liang Huang</RAUTHOR>
      <REFTITLE>Better k-best parsing.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="12">
      <RAUTHOR>Liang Huang</RAUTHOR>
      <REFTITLE>Machine translation as lexicalized parsing with hooks.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="13">
      <RAUTHOR>ISI Machine</RAUTHOR>
      <REFTITLE>Translation Team.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="14">
      <RAUTHOR>D C Knight Washington</RAUTHOR>
      <REFTITLE>An overview of probabilistic tree transducers for natural language processing.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="15">
      <RAUTHOR>D Knuth</RAUTHOR>
      <REFTITLE>A generalization of Dijkstra&#8217;s algorithm.</REFTITLE>
      <DATE>1977</DATE>
    </REFERENCE>
    <REFERENCE ID="16">
      <RAUTHOR>Yang Liu</RAUTHOR>
      <REFTITLE>Log-linear models for word alignment.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="17">
      <RAUTHOR>I Dan Melamed</RAUTHOR>
      <REFTITLE>Multitext grammars and synchronous parsers.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="18">
      <RAUTHOR>Rada Mihalcea</RAUTHOR>
      <REFTITLE>An evaluation exercise for word alignment.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="19">
      <RAUTHOR>M-J Nederhof</RAUTHOR>
      <REFTITLE>Weighted deductive parsing and knuth&#8217;s algorithm.</REFTITLE>
      <DATE>2003</DATE>
    </REFERENCE>
    <REFERENCE ID="20">
      <RAUTHOR>Franz Josef Och</RAUTHOR>
      <REFTITLE>The alignment template approach to statistical machine translation.</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="21">
      <RAUTHOR>Owen Rambow</RAUTHOR>
      <REFTITLE>Independent parallelism in finite copying parallel rewriting systems.</REFTITLE>
      <DATE>1999</DATE>
    </REFERENCE>
    <REFERENCE ID="22">
      <RAUTHOR>William C Rounds</RAUTHOR>
      <REFTITLE>Mappings and grammars on trees.</REFTITLE>
      <DATE>1970</DATE>
    </REFERENCE>
    <REFERENCE ID="23">
      <RAUTHOR>Giorgio Satta</RAUTHOR>
      <REFTITLE>Some computational complexity results for synchronous context-free grammars.</REFTITLE>
      <DATE>2005</DATE>
    </REFERENCE>
    <REFERENCE ID="24">
      <RAUTHOR>E Schr&#246;der</RAUTHOR>
      <REFTITLE></REFTITLE>
      <DATE>1870</DATE>
    </REFERENCE>
    <REFERENCE ID="25">
      <RAUTHOR>L Shapiro</RAUTHOR>
      <REFTITLE>Bootstrap percolation, the Schr&#246;der numbers, and the n-kings problem.</REFTITLE>
      <DATE>1991</DATE>
    </REFERENCE>
    <REFERENCE ID="26">
      <RAUTHOR>Stuart M Shieber</RAUTHOR>
      <REFTITLE>Synchronous grammars as tree transducers.</REFTITLE>
      <DATE>2004</DATE>
    </REFERENCE>
    <REFERENCE ID="27">
      <RAUTHOR>Stuart Shieber</RAUTHOR>
      <REFTITLE>Synchronous tree-adjoining grammars.</REFTITLE>
      <DATE>1990</DATE>
    </REFERENCE>
    <REFERENCE ID="28">
      <RAUTHOR>Benjamin Wellington</RAUTHOR>
      <REFTITLE>Empirical lower bounds on the complexity of translational equivalence.</REFTITLE>
      <DATE>2006</DATE>
    </REFERENCE>
    <REFERENCE ID="29">
      <RAUTHOR>Dekai Wu</RAUTHOR>
      <REFTITLE>A polynomial&#8211;time algorithm for statistical machine translation.</REFTITLE>
      <DATE>1996</DATE>
    </REFERENCE>
    <REFERENCE ID="30">
      <RAUTHOR>Dekai Wu</RAUTHOR>
      <REFTITLE>Stochastic inversion transduction grammars and bilingual parsing of parallel corpora.</REFTITLE>
      <DATE>1997</DATE>
    </REFERENCE>
    <REFERENCE ID="31">
      <RAUTHOR>Hao Zhang</RAUTHOR>
      <REFTITLE>Factorization of synchronous context-free grammars in linear time.</REFTITLE>
      <DATE>2007</DATE>
    </REFERENCE>
  </REFERENCES>
</PAPER>
